<?xml version="1.0"?>
<doc>
    <assembly>
        <name>dnlib</name>
    </assembly>
    <members>
        <member name="T:dnlib.DotNet.AllTypesHelper">
            <summary>
            Returns types without getting stuck in an infinite loop
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AllTypesHelper.Types(System.Collections.Generic.IEnumerable{dnlib.DotNet.TypeDef})">
            <summary>
            Gets a list of all types and nested types
            </summary>
            <param name="types">A list of types</param>
        </member>
        <member name="T:dnlib.DotNet.AssemblyAttributes">
            <summary>
            Assembly flags from Assembly.Flags column.
            </summary>
            <remarks>See CorHdr.h/CorAssemblyFlags</remarks>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.None">
            <summary>No flags set</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.PublicKey">
            <summary>The assembly ref holds the full (unhashed) public key.</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.PA_None">
            <summary>Processor Architecture unspecified</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.PA_MSIL">
            <summary>Processor Architecture: neutral (PE32)</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.PA_x86">
            <summary>Processor Architecture: x86 (PE32)</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.PA_IA64">
            <summary>Processor Architecture: Itanium (PE32+)</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.PA_AMD64">
            <summary>Processor Architecture: AMD X64 (PE32+)</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.PA_ARM">
            <summary>Processor Architecture: ARM (PE32)</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.PA_NoPlatform">
            <summary>applies to any platform but cannot run on any (e.g. reference assembly), should not have "specified" set</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.PA_Specified">
            <summary>Propagate PA flags to AssemblyRef record</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.PA_Mask">
            <summary>Bits describing the processor architecture</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.PA_FullMask">
            <summary>Bits describing the PA incl. Specified</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.PA_Shift">
            <summary>NOT A FLAG, shift count in PA flags &lt;--&gt; index conversion</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.EnableJITcompileTracking">
            <summary>From "DebuggableAttribute".</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.DisableJITcompileOptimizer">
            <summary>From "DebuggableAttribute".</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.Retargetable">
            <summary>The assembly can be retargeted (at runtime) to an assembly from a different publisher.</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.ContentType_Default">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.ContentType_WindowsRuntime">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.AssemblyAttributes.ContentType_Mask">
            <summary>Bits describing ContentType</summary>
        </member>
        <member name="T:dnlib.DotNet.AssemblyDef">
            <summary>
            A high-level representation of a row in the Assembly table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyDef.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.HasDeclSecurityTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.HashAlgorithm">
            <summary>
            From column Assembly.HashAlgId
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyDef.hashAlgorithm">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.Version">
            <summary>
            From columns Assembly.MajorVersion, Assembly.MinorVersion, Assembly.BuildNumber,
            Assembly.RevisionNumber.
            </summary>
            <exception cref="T:System.ArgumentNullException">If <paramref name="value"/> is <c>null</c></exception>
        </member>
        <member name="F:dnlib.DotNet.AssemblyDef.version">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.Attributes">
            <summary>
            From column Assembly.Flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyDef.attributes">
            <summary>Attributes</summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.PublicKey">
            <summary>
            From column Assembly.PublicKey
            </summary>
            <remarks>An empty <see cref="P:dnlib.DotNet.AssemblyDef.PublicKey"/> is created if the caller writes <c>null</c></remarks>
        </member>
        <member name="F:dnlib.DotNet.AssemblyDef.publicKey">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.PublicKeyToken">
            <summary>
            Gets the public key token which is calculated from <see cref="P:dnlib.DotNet.AssemblyDef.PublicKey"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.Name">
            <summary>
            From column Assembly.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyDef.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.Culture">
            <summary>
            From column Assembly.Locale
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyDef.culture">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.DeclSecurities">
            <inheritdoc/>
        </member>
        <member name="F:dnlib.DotNet.AssemblyDef.declSecurities">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.InitializeDeclSecurities">
            <summary>Initializes <see cref="F:dnlib.DotNet.AssemblyDef.declSecurities"/></summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.PublicKeyOrToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.FullName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.FullNameToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.Modules">
            <summary>
            Gets all modules. The first module is always the <see cref="P:dnlib.DotNet.AssemblyDef.ManifestModule"/>.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyDef.modules">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.InitializeModules">
            <summary>Initializes <see cref="F:dnlib.DotNet.AssemblyDef.modules"/></summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyDef.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.AssemblyDef.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyDef.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.AssemblyDef.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.HasDeclSecurities">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.HasModules">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.AssemblyDef.Modules"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.ManifestModule">
            <summary>
            Gets the manifest (main) module. This is always the first module in <see cref="P:dnlib.DotNet.AssemblyDef.Modules"/>.
            <c>null</c> is returned if <see cref="P:dnlib.DotNet.AssemblyDef.Modules"/> is empty.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.ModifyAttributes(dnlib.DotNet.AssemblyAttributes,dnlib.DotNet.AssemblyAttributes)">
            <summary>
            Modify <see cref="F:dnlib.DotNet.AssemblyDef.attributes"/> property: <see cref="F:dnlib.DotNet.AssemblyDef.attributes"/> =
            (<see cref="F:dnlib.DotNet.AssemblyDef.attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
            </summary>
            <param name="andMask">Value to <c>AND</c></param>
            <param name="orMask">Value to OR</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.ModifyAttributes(System.Boolean,dnlib.DotNet.AssemblyAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.AssemblyDef.attributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.HasPublicKey">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.PublicKey"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.ProcessorArchitecture">
            <summary>
            Gets/sets the processor architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.ProcessorArchitectureFull">
            <summary>
            Gets/sets the processor architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.IsProcessorArchitectureNone">
            <summary>
            <c>true</c> if unspecified processor architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.IsProcessorArchitectureMSIL">
            <summary>
            <c>true</c> if neutral (PE32) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.IsProcessorArchitectureX86">
            <summary>
            <c>true</c> if x86 (PE32) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.IsProcessorArchitectureIA64">
            <summary>
            <c>true</c> if IA-64 (PE32+) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.IsProcessorArchitectureX64">
            <summary>
            <c>true</c> if x64 (PE32+) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.IsProcessorArchitectureARM">
            <summary>
            <c>true</c> if ARM (PE32) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.IsProcessorArchitectureNoPlatform">
            <summary>
            <c>true</c> if eg. reference assembly (not runnable)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.IsProcessorArchitectureSpecified">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.PA_Specified"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.EnableJITcompileTracking">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.EnableJITcompileTracking"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.DisableJITcompileOptimizer">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.DisableJITcompileOptimizer"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.IsRetargetable">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.Retargetable"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.ContentType">
            <summary>
            Gets/sets the content type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.IsContentTypeDefault">
            <summary>
            <c>true</c> if content type is <c>Default</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDef.IsContentTypeWindowsRuntime">
            <summary>
            <c>true</c> if content type is <c>WindowsRuntime</c>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.FindModule(dnlib.DotNet.UTF8String)">
            <summary>
            Finds a module in this assembly
            </summary>
            <param name="name">Name of module</param>
            <returns>A <see cref="T:dnlib.DotNet.ModuleDef"/> instance or <c>null</c> if it wasn't found.</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.Load(System.String,dnlib.DotNet.ModuleContext)">
            <summary>
            Creates an <see cref="T:dnlib.DotNet.AssemblyDef"/> instance from a file
            </summary>
            <param name="fileName">File name of an existing .NET assembly</param>
            <param name="context">Module context or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.AssemblyDef"/> instance</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="fileName"/> is <c>null</c></exception>
            <exception cref="T:System.BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.Load(System.String,dnlib.DotNet.ModuleCreationOptions)">
            <summary>
            Creates an <see cref="T:dnlib.DotNet.AssemblyDef"/> instance from a file
            </summary>
            <param name="fileName">File name of an existing .NET assembly</param>
            <param name="options">Module creation options or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.AssemblyDef"/> instance</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="fileName"/> is <c>null</c></exception>
            <exception cref="T:System.BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.Load(System.Byte[],dnlib.DotNet.ModuleContext)">
            <summary>
            Creates an <see cref="T:dnlib.DotNet.AssemblyDef"/> instance from a byte[]
            </summary>
            <param name="data">Contents of a .NET assembly</param>
            <param name="context">Module context or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.AssemblyDef"/> instance</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="data"/> is <c>null</c></exception>
            <exception cref="T:System.BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.Load(System.Byte[],dnlib.DotNet.ModuleCreationOptions)">
            <summary>
            Creates an <see cref="T:dnlib.DotNet.AssemblyDef"/> instance from a byte[]
            </summary>
            <param name="data">Contents of a .NET assembly</param>
            <param name="options">Module creation options or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.AssemblyDef"/> instance</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="data"/> is <c>null</c></exception>
            <exception cref="T:System.BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.Load(System.IntPtr,dnlib.DotNet.ModuleContext)">
            <summary>
            Creates an <see cref="T:dnlib.DotNet.AssemblyDef"/> instance from a memory location
            </summary>
            <param name="addr">Address of a .NET assembly</param>
            <param name="context">Module context or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.AssemblyDef"/> instance</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="addr"/> is <c>null</c></exception>
            <exception cref="T:System.BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.Load(System.IntPtr,dnlib.DotNet.ModuleCreationOptions)">
            <summary>
            Creates an <see cref="T:dnlib.DotNet.AssemblyDef"/> instance from a memory location
            </summary>
            <param name="addr">Address of a .NET assembly</param>
            <param name="options">Module creation options or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.AssemblyDef"/> instance</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="addr"/> is <c>null</c></exception>
            <exception cref="T:System.BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.Load(System.IO.Stream,dnlib.DotNet.ModuleContext)">
            <summary>
            Creates an <see cref="T:dnlib.DotNet.AssemblyDef"/> instance from a stream
            </summary>
            <remarks>This will read all bytes from the stream and call <see cref="M:dnlib.DotNet.AssemblyDef.Load(System.Byte[],dnlib.DotNet.ModuleContext)"/>.
            It's better to use one of the other Load() methods.</remarks>
            <param name="stream">The stream</param>
            <param name="context">Module context or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.AssemblyDef"/> instance</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
            <exception cref="T:System.BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.Load(System.IO.Stream,dnlib.DotNet.ModuleCreationOptions)">
            <summary>
            Creates an <see cref="T:dnlib.DotNet.AssemblyDef"/> instance from a stream
            </summary>
            <remarks>This will read all bytes from the stream and call <see cref="M:dnlib.DotNet.AssemblyDef.Load(System.Byte[],dnlib.DotNet.ModuleContext)"/>.
            It's better to use one of the other Load() methods.</remarks>
            <param name="stream">The stream</param>
            <param name="options">Module creation options or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.AssemblyDef"/> instance</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
            <exception cref="T:System.BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.GetFullNameWithPublicKey">
            <summary>
            Gets the assembly name with the public key
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.GetFullNameWithPublicKeyToken">
            <summary>
            Gets the assembly name with the public key token
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.Find(System.String,System.Boolean)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeDef"/>. For speed, enable <see cref="P:dnlib.DotNet.ModuleDef.EnableTypeDefFindCache"/>
            if possible (read the documentation first).
            </summary>
            <param name="fullName">Full name of the type (no assembly information)</param>
            <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
            type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
            are separated by a <c>/</c> character.</param>
            <returns>An existing <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if it wasn't found.</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.Find(dnlib.DotNet.TypeRef)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeDef"/>. Its scope (i.e., module or assembly) is ignored when
            looking up the type. For speed, enable <see cref="P:dnlib.DotNet.ModuleDef.EnableTypeDefFindCache"/>
            if possible (read the documentation first).
            </summary>
            <param name="typeRef">The type ref</param>
            <returns>An existing <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if it wasn't found.</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.Write(System.String,dnlib.DotNet.Writer.ModuleWriterOptions)">
            <summary>
            Writes the assembly to a file on disk. If the file exists, it will be truncated.
            </summary>
            <param name="filename">Filename</param>
            <param name="options">Writer options</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.Write(System.IO.Stream,dnlib.DotNet.Writer.ModuleWriterOptions)">
            <summary>
            Writes the assembly to a stream.
            </summary>
            <param name="dest">Destination stream</param>
            <param name="options">Writer options</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.IsFriendAssemblyOf(dnlib.DotNet.AssemblyDef)">
            <summary>
            Checks whether this assembly is a friend assembly of <paramref name="targetAsm"/>
            </summary>
            <param name="targetAsm">Target assembly</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.UpdateOrCreateAssemblySignatureKeyAttribute(dnlib.DotNet.StrongNamePublicKey,dnlib.DotNet.StrongNameKey,dnlib.DotNet.StrongNamePublicKey)">
            <summary>
            Adds or updates an existing <c>System.Reflection.AssemblySignatureKeyAttribute</c>
            attribute. This attribute is used in enhanced strong naming with key migration.
            See http://msdn.microsoft.com/en-us/library/hh415055.aspx
            </summary>
            <param name="identityPubKey">Identity public key</param>
            <param name="identityKey">Identity strong name key pair</param>
            <param name="signaturePubKey">Signature public key</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.TryGetOriginalTargetFrameworkAttribute(System.String@,System.Version@,System.String@)">
            <summary>
            Gets the original <c>System.Runtime.Versioning.TargetFrameworkAttribute</c> custom attribute information if possible.
            It reads this from the original metadata and doesn't use <see cref="P:dnlib.DotNet.AssemblyDef.CustomAttributes"/>.
            Returns false if the custom attribute isn't present or if it is invalid.
            </summary>
            <param name="framework">Framework name</param>
            <param name="version">Version</param>
            <param name="profile">Profile</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.dnlib#Utils#IListListener{dnlib#DotNet#ModuleDef}#OnLazyAdd(System.Int32,dnlib.DotNet.ModuleDef@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.dnlib#Utils#IListListener{dnlib#DotNet#ModuleDef}#OnAdd(System.Int32,dnlib.DotNet.ModuleDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.dnlib#Utils#IListListener{dnlib#DotNet#ModuleDef}#OnRemove(System.Int32,dnlib.DotNet.ModuleDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.dnlib#Utils#IListListener{dnlib#DotNet#ModuleDef}#OnResize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.dnlib#Utils#IListListener{dnlib#DotNet#ModuleDef}#OnClear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDef.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.AssemblyDefUser">
            <summary>
            An Assembly row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDefUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDefUser.#ctor(dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Simple name</param>
            <exception cref="T:System.ArgumentNullException">If any of the args is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDefUser.#ctor(dnlib.DotNet.UTF8String,System.Version)">
            <summary>
            Constructor
            </summary>
            <param name="name">Simple name</param>
            <param name="version">Version</param>
            <exception cref="T:System.ArgumentNullException">If any of the args is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDefUser.#ctor(dnlib.DotNet.UTF8String,System.Version,dnlib.DotNet.PublicKey)">
            <summary>
            Constructor
            </summary>
            <param name="name">Simple name</param>
            <param name="version">Version</param>
            <param name="publicKey">Public key</param>
            <exception cref="T:System.ArgumentNullException">If any of the args is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDefUser.#ctor(dnlib.DotNet.UTF8String,System.Version,dnlib.DotNet.PublicKey,dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Simple name</param>
            <param name="version">Version</param>
            <param name="publicKey">Public key</param>
            <param name="locale">Locale</param>
            <exception cref="T:System.ArgumentNullException">If any of the args is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDefUser.#ctor(System.Reflection.AssemblyName)">
            <summary>
            Constructor
            </summary>
            <param name="asmName">Assembly name info</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="asmName"/> is <c>null</c></exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDefUser.#ctor(dnlib.DotNet.IAssembly)">
            <summary>
            Constructor
            </summary>
            <param name="asmName">Assembly name info</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="asmName"/> is <c>null</c></exception>
        </member>
        <member name="T:dnlib.DotNet.AssemblyDefMD">
            <summary>
            Created from a row in the Assembly table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyDefMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyDefMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDefMD.InitializeDeclSecurities">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDefMD.InitializeModules">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDefMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDefMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDefMD.TryGetOriginalTargetFrameworkAttribute(System.String@,System.Version@,System.String@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyDefMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>Assembly</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.AssemblyHash">
            <summary>
            Hashes some data according to a <see cref="T:dnlib.DotNet.AssemblyHashAlgorithm"/>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyHash.#ctor(dnlib.DotNet.AssemblyHashAlgorithm)">
            <summary>
            Constructor
            </summary>
            <remarks>If <paramref name="hashAlgo"/> is an unsupported hash algorithm, then
            <see cref="F:dnlib.DotNet.AssemblyHashAlgorithm.SHA1"/> will be used as the hash algorithm.</remarks>
            <param name="hashAlgo">The algorithm to use</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyHash.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyHash.Hash(System.Byte[],dnlib.DotNet.AssemblyHashAlgorithm)">
            <summary>
            Hash data
            </summary>
            <remarks>If <paramref name="hashAlgo"/> is an unsupported hash algorithm, then
            <see cref="F:dnlib.DotNet.AssemblyHashAlgorithm.SHA1"/> will be used as the hash algorithm.</remarks>
            <param name="data">The data</param>
            <param name="hashAlgo">The algorithm to use</param>
            <returns>Hashed data or null if <paramref name="data"/> was <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyHash.Hash(System.Byte[])">
            <summary>
            Hash data
            </summary>
            <param name="data">Data</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyHash.Hash(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Hash data
            </summary>
            <param name="data">Data</param>
            <param name="offset">Offset</param>
            <param name="length">Length</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyHash.Hash(System.IO.Stream,System.UInt32,System.Byte[])">
            <summary>
            Hash stream data
            </summary>
            <param name="stream">Stream</param>
            <param name="length">Number of bytes to hash</param>
            <param name="buffer">Temp buffer</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyHash.ComputeHash">
            <summary>
            Computes the hash
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyHash.CreatePublicKeyToken(System.Byte[])">
            <summary>
            Creates a public key token from the hash of some <paramref name="publicKeyData"/>
            </summary>
            <remarks>A public key is hashed, and the last 8 bytes of the hash, in reverse
            order, is used as the public key token</remarks>
            <param name="publicKeyData">The data</param>
            <returns>A new <see cref="T:dnlib.DotNet.PublicKeyToken"/> instance</returns>
        </member>
        <member name="T:dnlib.DotNet.AssemblyHashAlgorithm">
            <summary>
            Any ALG_CLASS_HASH type in WinCrypt.h can be used by Microsoft's CLI implementation
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyHashAlgorithm.None">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.AssemblyHashAlgorithm.MD2">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.AssemblyHashAlgorithm.MD4">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.AssemblyHashAlgorithm.MD5">
            <summary>This is a reserved value in the CLI</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyHashAlgorithm.SHA1">
            <summary>The only algorithm supported by the CLI</summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyHashAlgorithm.MAC">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.AssemblyHashAlgorithm.SSL3_SHAMD5">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.AssemblyHashAlgorithm.HMAC">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.AssemblyHashAlgorithm.TLS1PRF">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.AssemblyHashAlgorithm.HASH_REPLACE_OWF">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.AssemblyHashAlgorithm.SHA_256">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.AssemblyHashAlgorithm.SHA_384">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.AssemblyHashAlgorithm.SHA_512">
            <summary/>
        </member>
        <member name="T:dnlib.DotNet.Extensions">
            <summary>
            Extension methods
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetFieldType(dnlib.DotNet.FieldSig)">
            <summary>
            Gets the field type
            </summary>
            <param name="sig">this</param>
            <returns>Field type or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetRetType(dnlib.DotNet.MethodBaseSig)">
            <summary>
            Gets the return type
            </summary>
            <param name="sig">this</param>
            <returns>Return type or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetParams(dnlib.DotNet.MethodBaseSig)">
            <summary>
            Gets the parameters
            </summary>
            <param name="sig">this</param>
            <returns>The parameters</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetParamCount(dnlib.DotNet.MethodBaseSig)">
            <summary>
            Gets the parameter count
            </summary>
            <param name="sig">this</param>
            <returns>Parameter count</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetGenParamCount(dnlib.DotNet.MethodBaseSig)">
            <summary>
            Gets the generic parameter count
            </summary>
            <param name="sig">this</param>
            <returns>Generic parameter count</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetParamsAfterSentinel(dnlib.DotNet.MethodBaseSig)">
            <summary>
            Gets the parameters after the sentinel
            </summary>
            <param name="sig">this</param>
            <returns>Parameters after sentinel or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetLocals(dnlib.DotNet.LocalSig)">
            <summary>
            Gets the locals
            </summary>
            <param name="sig">this</param>
            <returns>All locals</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetGenericArguments(dnlib.DotNet.GenericInstMethodSig)">
            <summary>
            Gets the generic arguments
            </summary>
            <param name="sig">this</param>
            <returns>All generic arguments</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetIsDefault(dnlib.DotNet.CallingConventionSig)">
            <summary>
            Gets the <see cref="P:dnlib.DotNet.CallingConventionSig.IsDefault"/> property
            </summary>
            <param name="sig">this</param>
            <returns>The type's <see cref="P:dnlib.DotNet.CallingConventionSig.IsDefault"/> property or
            <c>false</c> if input is<c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.IsPrimitive(dnlib.DotNet.ElementType)">
            <summary>
            Returns <c>true</c> if it's an integer or a floating point type
            </summary>
            <param name="etype">Element type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetPrimitiveSize(dnlib.DotNet.ElementType,System.Int32)">
            <summary>
            Returns the size of the element type in bytes or <c>-1</c> if it's unknown
            </summary>
            <param name="etype">Element type</param>
            <param name="ptrSize">Size of a pointer</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.IsValueType(dnlib.DotNet.ElementType)">
            <summary>
            Checks whether it's a value type
            </summary>
            <param name="etype">this</param>
            <returns><c>true</c> if it's a value type, <c>false</c> if it's not a value type or
            if we couldn't determine whether it's a value type. Eg., it could be a generic
            instance type.</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Resolve(dnlib.DotNet.IAssemblyResolver,System.Reflection.AssemblyName,dnlib.DotNet.ModuleDef)">
            <summary>
            Finds and returns an <see cref="T:dnlib.DotNet.AssemblyDef"/>
            </summary>
            <param name="self">this</param>
            <param name="assembly">The assembly to find</param>
            <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
            <returns>An <see cref="T:dnlib.DotNet.AssemblyDef"/> instance owned by the assembly resolver or
            <c>null</c> if the assembly couldn't be found.</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Resolve(dnlib.DotNet.IAssemblyResolver,System.String,dnlib.DotNet.ModuleDef)">
            <summary>
            Finds and returns an <see cref="T:dnlib.DotNet.AssemblyDef"/>
            </summary>
            <param name="self">this</param>
            <param name="asmFullName">The assembly to find</param>
            <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
            <returns>An <see cref="T:dnlib.DotNet.AssemblyDef"/> instance owned by the assembly resolver or
            <c>null</c> if the assembly couldn't be found.</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveThrow(dnlib.DotNet.IAssemblyResolver,dnlib.DotNet.IAssembly,dnlib.DotNet.ModuleDef)">
            <summary>
            Finds and returns an <see cref="T:dnlib.DotNet.AssemblyDef"/>
            </summary>
            <param name="self">this</param>
            <param name="assembly">The assembly to find</param>
            <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
            <returns>An <see cref="T:dnlib.DotNet.AssemblyDef"/> instance owned by the assembly resolver</returns>
            <exception cref="T:dnlib.DotNet.AssemblyResolveException">If the assembly couldn't be found.</exception>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveThrow(dnlib.DotNet.IAssemblyResolver,System.Reflection.AssemblyName,dnlib.DotNet.ModuleDef)">
            <summary>
            Finds and returns an <see cref="T:dnlib.DotNet.AssemblyDef"/>
            </summary>
            <param name="self">this</param>
            <param name="assembly">The assembly to find</param>
            <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
            <returns>An <see cref="T:dnlib.DotNet.AssemblyDef"/> instance owned by the assembly resolver</returns>
            <exception cref="T:dnlib.DotNet.AssemblyResolveException">If the assembly couldn't be found.</exception>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveThrow(dnlib.DotNet.IAssemblyResolver,System.String,dnlib.DotNet.ModuleDef)">
            <summary>
            Finds and returns an <see cref="T:dnlib.DotNet.AssemblyDef"/>
            </summary>
            <param name="self">this</param>
            <param name="asmFullName">The assembly to find</param>
            <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
            <returns>An <see cref="T:dnlib.DotNet.AssemblyDef"/> instance owned by the assembly resolver</returns>
            <exception cref="T:dnlib.DotNet.AssemblyResolveException">If the assembly couldn't be found.</exception>
        </member>
        <member name="M:dnlib.DotNet.Extensions.IsCorLib(dnlib.DotNet.IAssembly)">
            <summary>
            Checks whether <paramref name="asm"/> appears to be the core library (eg.
            mscorlib, System.Runtime or corefx).
            
            If <paramref name="asm"/> is a reference to a private corlib (eg. System.Private.CoreLib),
            this method returns false unless <paramref name="asm"/> is an <see cref="T:dnlib.DotNet.AssemblyDef"/>
            whose manifest (first) module defines <c>System.Object</c>. This check is performed in
            the constructor and the result can be found in <see cref="P:dnlib.DotNet.ModuleDef.IsCoreLibraryModule"/>.
            
            Note that this method also returns true if it appears to be a 'public' corlib,
            eg. mscorlib, etc, even if it internally possibly references a private corlib.
            </summary>
            <param name="asm">The assembly</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToAssemblyRef(dnlib.DotNet.IAssembly)">
            <summary>
            Converts <paramref name="asm"/> to a <see cref="T:dnlib.DotNet.AssemblyRef"/> instance
            </summary>
            <param name="asm">The assembly</param>
            <returns>A new <see cref="T:dnlib.DotNet.AssemblyRef"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToTypeSig(dnlib.DotNet.ITypeDefOrRef,System.Boolean)">
            <summary>
            Converts <paramref name="type"/> to a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="type">The type</param>
            <param name="checkValueType"><c>true</c> if we should try to figure out whether
            <paramref name="type"/> is a <see cref="T:System.ValueType"/></param>
            <returns>A <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if <paramref name="type"/>
            is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetTypeDefOrRefSig(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.TypeDefOrRefSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDefOrRefSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.TypeDefOrRefSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetClassOrValueTypeSig(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.ClassOrValueTypeSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.ClassOrValueTypeSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.ClassOrValueTypeSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetValueTypeSig(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.ValueTypeSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.ValueTypeSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.ValueTypeSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetClassSig(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.ClassSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.ClassSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.ClassSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetGenericSig(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.GenericSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.GenericSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.GenericSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetGenericVar(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.GenericVar"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.GenericVar"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.GenericVar"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetGenericMVar(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.GenericMVar"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.GenericMVar"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.GenericMVar"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetGenericInstSig(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.GenericInstSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.GenericInstSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.GenericInstSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetPtrSig(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.PtrSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.PtrSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.PtrSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetByRefSig(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.ByRefSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.ByRefSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.ByRefSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetArraySig(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.ArraySig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.ArraySig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.ArraySig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetSZArraySig(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.SZArraySig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.SZArraySig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.SZArraySig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetBaseTypeThrow(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns the base type of <paramref name="tdr"/>. Throws if we can't resolve
            a <see cref="T:dnlib.DotNet.TypeRef"/>.
            </summary>
            <param name="tdr">The type</param>
            <returns>The base type or <c>null</c> if there's no base type</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetBaseType(dnlib.DotNet.ITypeDefOrRef,System.Boolean)">
            <summary>
            Returns the base type of <paramref name="tdr"/>
            </summary>
            <param name="tdr">The type</param>
            <param name="throwOnResolveFailure"><c>true</c> if we should throw if we can't
            resolve a <see cref="T:dnlib.DotNet.TypeRef"/>. <c>false</c> if we should ignore the error and
            just return <c>null</c>.</param>
            <returns>The base type or <c>null</c> if there's no base type, or if
            <paramref name="throwOnResolveFailure"/> is <c>true</c> and we couldn't resolve
            a <see cref="T:dnlib.DotNet.TypeRef"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveTypeDef(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Gets the scope type, resolves it, and returns the <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="tdr">Type</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if input was <c>null</c> or if we
            couldn't resolve the reference.</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveTypeDefThrow(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Gets the scope type, resolves it, and returns the <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="tdr">Type</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> instance.</returns>
            <exception cref="T:dnlib.DotNet.TypeResolveException">If the type couldn't be resolved</exception>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveFieldDef(dnlib.DotNet.IField)">
            <summary>
            Resolves an <see cref="T:dnlib.DotNet.IField"/> to a <see cref="T:dnlib.DotNet.FieldDef"/>. Returns <c>null</c> if it
            was not possible to resolve it. See also <see cref="M:dnlib.DotNet.Extensions.ResolveFieldDefThrow(dnlib.DotNet.IField)"/>
            </summary>
            <param name="field">Field to resolve</param>
            <returns>The <see cref="T:dnlib.DotNet.FieldDef"/> or <c>null</c> if <paramref name="field"/> is
            <c>null</c> or if it wasn't possible to resolve it (the field doesn't exist or its
            assembly couldn't be loaded)</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveFieldDefThrow(dnlib.DotNet.IField)">
            <summary>
            Resolves an <see cref="T:dnlib.DotNet.IField"/> to a <see cref="T:dnlib.DotNet.FieldDef"/> and throws an exception if
            it was not possible to resolve it. See also <see cref="M:dnlib.DotNet.Extensions.ResolveFieldDef(dnlib.DotNet.IField)"/>
            </summary>
            <param name="field">Field to resolve</param>
            <returns>The <see cref="T:dnlib.DotNet.FieldDef"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveMethodDef(dnlib.DotNet.IMethod)">
            <summary>
            Resolves an <see cref="T:dnlib.DotNet.IMethod"/> to a <see cref="T:dnlib.DotNet.MethodDef"/>. Returns <c>null</c> if it
            was not possible to resolve it. See also <see cref="M:dnlib.DotNet.Extensions.ResolveMethodDefThrow(dnlib.DotNet.IMethod)"/>. If
            <paramref name="method"/> is a <see cref="T:dnlib.DotNet.MethodSpec"/>, then the
            <see cref="P:dnlib.DotNet.MethodSpec.Method"/> property is resolved and returned.
            </summary>
            <param name="method">Method to resolve</param>
            <returns>The <see cref="T:dnlib.DotNet.MethodDef"/> or <c>null</c> if <paramref name="method"/> is
            <c>null</c> or if it wasn't possible to resolve it (the method doesn't exist or its
            assembly couldn't be loaded)</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveMethodDefThrow(dnlib.DotNet.IMethod)">
            <summary>
            Resolves an <see cref="T:dnlib.DotNet.IMethod"/> to a <see cref="T:dnlib.DotNet.MethodDef"/> and throws an exception
            if it was not possible to resolve it. See also <see cref="M:dnlib.DotNet.Extensions.ResolveMethodDef(dnlib.DotNet.IMethod)"/>. If
            <paramref name="method"/> is a <see cref="T:dnlib.DotNet.MethodSpec"/>, then the
            <see cref="P:dnlib.DotNet.MethodSpec.Method"/> property is resolved and returned.
            </summary>
            <param name="method">Method to resolve</param>
            <returns>The <see cref="T:dnlib.DotNet.MethodDef"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetDefinitionAssembly(dnlib.DotNet.MemberRef)">
            <summary>
            Returns the definition assembly of a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
            <param name="mr">Member reference</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToTypeDefOrRef(dnlib.DotNet.TypeSig)">
            <summary>
            Converts a <see cref="T:dnlib.DotNet.TypeSig"/> to a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="sig">The sig</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.IsPrimitive(dnlib.DotNet.IType)">
            <summary>
            Returns <c>true</c> if it's an integer or a floating point type
            </summary>
            <param name="tdr">Type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetCorLibTypeSig(dnlib.DotNet.ICorLibTypes,dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Gets a <see cref="T:dnlib.DotNet.CorLibTypeSig"/> if <paramref name="type"/> matches a primitive type.
            </summary>
            <param name="self">this</param>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.CorLibTypeSig"/> or <c>null</c> if it didn't match any primitive type</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetCorLibTypeSig(dnlib.DotNet.ICorLibTypes,dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String,dnlib.DotNet.IAssembly)">
            <summary>
            Gets a <see cref="T:dnlib.DotNet.CorLibTypeSig"/> if <paramref name="namespace"/> and
            <paramref name="name"/> matches a primitive type.
            </summary>
            <param name="self">this</param>
            <param name="namespace">Namespace</param>
            <param name="name">Name</param>
            <param name="defAsm">Definition assembly</param>
            <returns>A <see cref="T:dnlib.DotNet.CorLibTypeSig"/> or <c>null</c> if it didn't match any primitive type</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetCorLibTypeSig(dnlib.DotNet.ICorLibTypes,System.String,System.String,dnlib.DotNet.IAssembly)">
            <summary>
            Gets a <see cref="T:dnlib.DotNet.CorLibTypeSig"/> if <paramref name="namespace"/> and
            <paramref name="name"/> matches a primitive type.
            </summary>
            <param name="self">this</param>
            <param name="namespace">Namespace</param>
            <param name="name">Name</param>
            <param name="defAsm">Definition assembly</param>
            <returns>A <see cref="T:dnlib.DotNet.CorLibTypeSig"/> or <c>null</c> if it didn't match any primitive type</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Error(dnlib.DotNet.ILogger,System.Object,System.String)">
            <summary>
            Log an error message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Error(dnlib.DotNet.ILogger,System.Object,System.String,System.Object)">
            <summary>
            Log an error message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Error(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object)">
            <summary>
            Log an error message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Error(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Log an error message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
            <param name="arg3">Message arg #3</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Error(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Log an error message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
            <param name="arg3">Message arg #3</param>
            <param name="arg4">Message arg #4</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Error(dnlib.DotNet.ILogger,System.Object,System.String,System.Object[])">
            <summary>
            Log an error message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="args">Message arguments</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Warning(dnlib.DotNet.ILogger,System.Object,System.String)">
            <summary>
            Log a warning message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Warning(dnlib.DotNet.ILogger,System.Object,System.String,System.Object)">
            <summary>
            Log a warning message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Warning(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object)">
            <summary>
            Log a warning message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Warning(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Log a warning message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
            <param name="arg3">Message arg #3</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Warning(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Log a warning message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
            <param name="arg3">Message arg #3</param>
            <param name="arg4">Message arg #4</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Warning(dnlib.DotNet.ILogger,System.Object,System.String,System.Object[])">
            <summary>
            Log a warning message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="args">Message arguments</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Info(dnlib.DotNet.ILogger,System.Object,System.String)">
            <summary>
            Log an info message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Info(dnlib.DotNet.ILogger,System.Object,System.String,System.Object)">
            <summary>
            Log an info message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Info(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object)">
            <summary>
            Log an info message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Info(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Log an info message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
            <param name="arg3">Message arg #3</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Info(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Log an info message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
            <param name="arg3">Message arg #3</param>
            <param name="arg4">Message arg #4</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Info(dnlib.DotNet.ILogger,System.Object,System.String,System.Object[])">
            <summary>
            Log an info message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="args">Message arguments</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Verbose(dnlib.DotNet.ILogger,System.Object,System.String)">
            <summary>
            Log a verbose message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Verbose(dnlib.DotNet.ILogger,System.Object,System.String,System.Object)">
            <summary>
            Log a verbose message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Verbose(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object)">
            <summary>
            Log a verbose message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Verbose(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Log a verbose message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
            <param name="arg3">Message arg #3</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Verbose(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Log a verbose message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
            <param name="arg3">Message arg #3</param>
            <param name="arg4">Message arg #4</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Verbose(dnlib.DotNet.ILogger,System.Object,System.String,System.Object[])">
            <summary>
            Log a verbose message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="args">Message arguments</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.VeryVerbose(dnlib.DotNet.ILogger,System.Object,System.String)">
            <summary>
            Log a very verbose message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.VeryVerbose(dnlib.DotNet.ILogger,System.Object,System.String,System.Object)">
            <summary>
            Log a very verbose message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.VeryVerbose(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object)">
            <summary>
            Log a very verbose message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.VeryVerbose(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Log a very verbose message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
            <param name="arg3">Message arg #3</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.VeryVerbose(dnlib.DotNet.ILogger,System.Object,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Log a very verbose message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="arg1">Message arg #1</param>
            <param name="arg2">Message arg #2</param>
            <param name="arg3">Message arg #3</param>
            <param name="arg4">Message arg #4</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.VeryVerbose(dnlib.DotNet.ILogger,System.Object,System.String,System.Object[])">
            <summary>
            Log a very verbose message
            </summary>
            <param name="logger">this</param>
            <param name="sender">Sender or <c>null</c></param>
            <param name="message">Message</param>
            <param name="args">Message arguments</param>
        </member>
        <member name="M:dnlib.DotNet.Extensions.Resolve(dnlib.DotNet.ITypeResolver,dnlib.DotNet.TypeRef)">
            <summary>
            Resolves a type
            </summary>
            <param name="self">this</param>
            <param name="typeRef">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveThrow(dnlib.DotNet.ITypeResolver,dnlib.DotNet.TypeRef)">
            <summary>
            Resolves a type
            </summary>
            <param name="self">this</param>
            <param name="typeRef">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> instance</returns>
            <exception cref="T:dnlib.DotNet.TypeResolveException">If the type couldn't be resolved</exception>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveThrow(dnlib.DotNet.ITypeResolver,dnlib.DotNet.TypeRef,dnlib.DotNet.ModuleDef)">
            <summary>
            Resolves a type
            </summary>
            <param name="self">this</param>
            <param name="typeRef">The type</param>
            <param name="sourceModule">The module that needs to resolve the type or <c>null</c></param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> instance</returns>
            <exception cref="T:dnlib.DotNet.TypeResolveException">If the type couldn't be resolved</exception>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveThrow(dnlib.DotNet.IMemberRefResolver,dnlib.DotNet.MemberRef)">
            <summary>
            Resolves a method or a field
            </summary>
            <param name="self">this</param>
            <param name="memberRef">A method/field reference</param>
            <returns>A <see cref="T:dnlib.DotNet.MethodDef"/> or a <see cref="T:dnlib.DotNet.FieldDef"/> instance</returns>
            <exception cref="T:dnlib.DotNet.MemberRefResolveException">If the method/field couldn't be resolved</exception>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveField(dnlib.DotNet.IMemberRefResolver,dnlib.DotNet.MemberRef)">
            <summary>
            Resolves a field
            </summary>
            <param name="self">this</param>
            <param name="memberRef">A field reference</param>
            <returns>A <see cref="T:dnlib.DotNet.FieldDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveFieldThrow(dnlib.DotNet.IMemberRefResolver,dnlib.DotNet.MemberRef)">
            <summary>
            Resolves a field
            </summary>
            <param name="self">this</param>
            <param name="memberRef">A field reference</param>
            <returns>A <see cref="T:dnlib.DotNet.FieldDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
            <exception cref="T:dnlib.DotNet.MemberRefResolveException">If the field couldn't be resolved</exception>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveMethod(dnlib.DotNet.IMemberRefResolver,dnlib.DotNet.MemberRef)">
            <summary>
            Resolves a method
            </summary>
            <param name="self">this</param>
            <param name="memberRef">A method reference</param>
            <returns>A <see cref="T:dnlib.DotNet.MethodDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveMethodThrow(dnlib.DotNet.IMemberRefResolver,dnlib.DotNet.MemberRef)">
            <summary>
            Resolves a method
            </summary>
            <param name="self">this</param>
            <param name="memberRef">A method reference</param>
            <returns>A <see cref="T:dnlib.DotNet.MethodDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
            <exception cref="T:dnlib.DotNet.MemberRefResolveException">If the method couldn't be resolved</exception>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ResolveToken(dnlib.DotNet.ITokenResolver,System.UInt32)">
            <summary>
            Resolves a token
            </summary>
            <param name="self">This</param>
            <param name="token">The metadata token</param>
            <returns>A <see cref="T:dnlib.DotNet.IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetNonNestedTypeRefScope(dnlib.DotNet.IType)">
            <summary>
            Returns <see cref="P:dnlib.DotNet.IType.ScopeType"/>, but if it's a nested <see cref="T:dnlib.DotNet.TypeRef"/>,
            return the non-nested <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="type">this</param>
            <returns>The scope type</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.FindThrow(dnlib.DotNet.ITypeDefFinder,dnlib.DotNet.TypeRef)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeDef"/>. Its scope (i.e., module or assembly) is ignored when
            looking up the type.
            </summary>
            <param name="self">this</param>
            <param name="typeRef">The type ref</param>
            <returns>An existing <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if it wasn't found.</returns>
            <exception cref="T:dnlib.DotNet.TypeResolveException">If type couldn't be found</exception>
        </member>
        <member name="M:dnlib.DotNet.Extensions.FindThrow(dnlib.DotNet.ITypeDefFinder,System.String,System.Boolean)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="self">this</param>
            <param name="fullName">Full name of the type (no assembly information)</param>
            <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
            type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
            are separated by a <c>/</c> character.</param>
            <returns>An existing <see cref="T:dnlib.DotNet.TypeDef"/></returns>
            <exception cref="T:dnlib.DotNet.TypeResolveException">If type couldn't be found</exception>
        </member>
        <member name="M:dnlib.DotNet.Extensions.FindNormal(dnlib.DotNet.ITypeDefFinder,System.String)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="self">this</param>
            <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>/</c></param>
            <returns>An existing <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if it wasn't found.</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.FindNormalThrow(dnlib.DotNet.ITypeDefFinder,System.String)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="self">this</param>
            <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>/</c></param>
            <returns>An existing <see cref="T:dnlib.DotNet.TypeDef"/></returns>
            <exception cref="T:dnlib.DotNet.TypeResolveException">If type couldn't be found</exception>
        </member>
        <member name="M:dnlib.DotNet.Extensions.FindReflection(dnlib.DotNet.ITypeDefFinder,System.String)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="self">this</param>
            <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>+</c></param>
            <returns>An existing <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if it wasn't found.</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.FindReflectionThrow(dnlib.DotNet.ITypeDefFinder,System.String)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="self">this</param>
            <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>+</c></param>
            <returns>An existing <see cref="T:dnlib.DotNet.TypeDef"/></returns>
            <exception cref="T:dnlib.DotNet.TypeResolveException">If type couldn't be found</exception>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TypeExists(dnlib.DotNet.ITypeDefFinder,dnlib.DotNet.TypeRef)">
            <summary>
            Checks whether a <see cref="T:dnlib.DotNet.TypeDef"/> exists. <paramref name="typeRef"/>'s scope (i.e.,
            module or assembly) is ignored when looking up the type.
            </summary>
            <param name="self">this</param>
            <param name="typeRef">The type ref</param>
            <returns><c>true</c> if the <see cref="T:dnlib.DotNet.TypeDef"/> exists, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TypeExists(dnlib.DotNet.ITypeDefFinder,System.String,System.Boolean)">
            <summary>
            Checks whether a <see cref="T:dnlib.DotNet.TypeDef"/> exists
            </summary>
            <param name="self">this</param>
            <param name="fullName">Full name of the type (no assembly information)</param>
            <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
            type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
            are separated by a <c>/</c> character.</param>
            <returns><c>true</c> if the <see cref="T:dnlib.DotNet.TypeDef"/> exists, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TypeExistsNormal(dnlib.DotNet.ITypeDefFinder,System.String)">
            <summary>
            Checks whether a <see cref="T:dnlib.DotNet.TypeDef"/> exists
            </summary>
            <param name="self">this</param>
            <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>/</c></param>
            <returns><c>true</c> if the <see cref="T:dnlib.DotNet.TypeDef"/> exists, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TypeExistsReflection(dnlib.DotNet.ITypeDefFinder,System.String)">
            <summary>
            Checks whether a <see cref="T:dnlib.DotNet.TypeDef"/> exists
            </summary>
            <param name="self">this</param>
            <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>+</c></param>
            <returns><c>true</c> if the <see cref="T:dnlib.DotNet.TypeDef"/> exists, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.RemoveModifiers(dnlib.DotNet.TypeSig)">
            <summary>
            Removes all C optional/required modifiers
            </summary>
            <param name="a">A <see cref="T:dnlib.DotNet.TypeSig"/> instance</param>
            <returns>Input after all modifiers</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.RemovePinned(dnlib.DotNet.TypeSig)">
            <summary>
            Removes pinned signature
            </summary>
            <param name="a">The type</param>
            <returns>Input after pinned signature</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.RemovePinnedAndModifiers(dnlib.DotNet.TypeSig)">
            <summary>
            Removes all modifiers and pinned sig
            </summary>
            <param name="a">The type</param>
            <returns>Inputer after modifiers and pinned signature</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToTypeDefOrRefSig(dnlib.DotNet.TypeSig)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.TypeDefOrRefSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDefOrRefSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.TypeDefOrRefSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToClassOrValueTypeSig(dnlib.DotNet.TypeSig)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.ClassOrValueTypeSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.ClassOrValueTypeSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.ClassOrValueTypeSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToValueTypeSig(dnlib.DotNet.TypeSig)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.ValueTypeSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.ValueTypeSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.ValueTypeSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToClassSig(dnlib.DotNet.TypeSig)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.ClassSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.ClassSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.ClassSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToGenericSig(dnlib.DotNet.TypeSig)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.GenericSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.GenericSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.GenericSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToGenericVar(dnlib.DotNet.TypeSig)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.GenericVar"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.GenericVar"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.GenericVar"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToGenericMVar(dnlib.DotNet.TypeSig)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.GenericMVar"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.GenericMVar"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.GenericMVar"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToGenericInstSig(dnlib.DotNet.TypeSig)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.GenericInstSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.GenericInstSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.GenericInstSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToPtrSig(dnlib.DotNet.TypeSig)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.PtrSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.PtrSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.PtrSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToByRefSig(dnlib.DotNet.TypeSig)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.ByRefSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.ByRefSig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.ByRefSig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToArraySig(dnlib.DotNet.TypeSig)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.ArraySig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.ArraySig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.ArraySig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.ToSZArraySig(dnlib.DotNet.TypeSig)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.SZArraySig"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.SZArraySig"/> or <c>null</c> if it's not a
            <see cref="T:dnlib.DotNet.SZArraySig"/></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetNext(dnlib.DotNet.TypeSig)">
            <summary>
            Gets the next field or <c>null</c>
            </summary>
            <param name="self">this</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetIsValueType(dnlib.DotNet.TypeSig)">
            <summary>
            Gets the <see cref="P:dnlib.DotNet.TypeSig.IsValueType"/> value or <c>false</c> if
            <paramref name="self"/> is <c>null</c>
            </summary>
            <param name="self">this</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetIsPrimitive(dnlib.DotNet.TypeSig)">
            <summary>
            Gets the <see cref="P:dnlib.DotNet.TypeSig.IsPrimitive"/> value or <c>false</c> if
            <paramref name="self"/> is <c>null</c>
            </summary>
            <param name="self">this</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetElementType(dnlib.DotNet.TypeSig)">
            <summary>
            Gets the element type
            </summary>
            <param name="a">this</param>
            <returns>The element type</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetFullName(dnlib.DotNet.TypeSig)">
            <summary>
            Gets the full name of the type
            </summary>
            <param name="a">this</param>
            <returns>Full name of the type</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetName(dnlib.DotNet.TypeSig)">
            <summary>
            Gets the name of the type
            </summary>
            <param name="a">this</param>
            <returns>Name of the type</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.GetNamespace(dnlib.DotNet.TypeSig)">
            <summary>
            Gets the namespace of the type
            </summary>
            <param name="a">this</param>
            <returns>Namespace of the type</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetTypeRef(dnlib.DotNet.TypeSig)">
            <summary>
            Returns the <see cref="T:dnlib.DotNet.TypeRef"/> if it is a <see cref="T:dnlib.DotNet.TypeDefOrRefSig"/>.
            </summary>
            <param name="a">this</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeRef"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetTypeDef(dnlib.DotNet.TypeSig)">
            <summary>
            Returns the <see cref="T:dnlib.DotNet.TypeDef"/> if it is a <see cref="T:dnlib.DotNet.TypeDefOrRefSig"/>.
            Nothing is resolved.
            </summary>
            <param name="a">this</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.Extensions.TryGetTypeSpec(dnlib.DotNet.TypeSig)">
            <summary>
            Returns the <see cref="T:dnlib.DotNet.TypeSpec"/> if it is a <see cref="T:dnlib.DotNet.TypeDefOrRefSig"/>.
            </summary>
            <param name="a">this</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeSpec"/> or <c>null</c> if none found</returns>
        </member>
        <member name="T:dnlib.DotNet.AssemblyNameComparerFlags">
            <summary>
            Flags used by <see cref="T:dnlib.DotNet.AssemblyNameComparer"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyNameComparerFlags.Name">
            <summary>
            Compare assembly simple name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyNameComparerFlags.Version">
            <summary>
            Compare assembly version
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyNameComparerFlags.PublicKeyToken">
            <summary>
            Compare assembly public key token
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyNameComparerFlags.Culture">
            <summary>
            Compare assembly culture
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyNameComparerFlags.ContentType">
            <summary>
            Compare content type
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyNameComparerFlags.All">
            <summary>
            Compare assembly simple name, version, public key token, locale and content type
            </summary>
        </member>
        <member name="T:dnlib.DotNet.AssemblyNameComparer">
            <summary>
            Compares two assembly names
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyNameComparer.CompareAll">
            <summary>
            Compares the name, version, public key token, culture and content type
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyNameComparer.NameAndPublicKeyTokenOnly">
            <summary>
            Compares only the name and the public key token
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyNameComparer.NameOnly">
            <summary>
            Compares only the name
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameComparer.CompareName">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.AssemblyNameComparerFlags.Name"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameComparer.CompareVersion">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.AssemblyNameComparerFlags.Version"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameComparer.ComparePublicKeyToken">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.AssemblyNameComparerFlags.PublicKeyToken"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameComparer.CompareCulture">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.AssemblyNameComparerFlags.Culture"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameComparer.CompareContentType">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.AssemblyNameComparerFlags.ContentType"/> bit
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyNameComparer.#ctor(dnlib.DotNet.AssemblyNameComparerFlags)">
            <summary>
            Constructor
            </summary>
            <param name="flags">Comparison flags</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyNameComparer.CompareTo(dnlib.DotNet.IAssembly,dnlib.DotNet.IAssembly)">
            <summary>
            Compares two assembly names
            </summary>
            <param name="a">First</param>
            <param name="b">Second</param>
            <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyNameComparer.Equals(dnlib.DotNet.IAssembly,dnlib.DotNet.IAssembly)">
            <summary>
            Compares two assembly names
            </summary>
            <param name="a">First</param>
            <param name="b">Second</param>
            <returns><c>true</c> if equal, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyNameComparer.CompareClosest(dnlib.DotNet.IAssembly,dnlib.DotNet.IAssembly,dnlib.DotNet.IAssembly)">
            <summary>
            Figures out which of two assembly names is closer to another assembly name
            </summary>
            <param name="requested">Requested assembly name</param>
            <param name="a">First</param>
            <param name="b">Second</param>
            <returns>-1 if both are equally close, 0 if <paramref name="a"/> is closest, 1 if
            <paramref name="b"/> is closest</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyNameComparer.GetHashCode(dnlib.DotNet.IAssembly)">
            <summary>
            Gets the hash code of an assembly name
            </summary>
            <param name="a">Assembly name</param>
            <returns>The hash code</returns>
        </member>
        <member name="T:dnlib.DotNet.AssemblyNameInfo">
            <summary>
            Stores assembly name information
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.HashAlgId">
            <summary>
            Gets/sets the <see cref="T:dnlib.DotNet.AssemblyHashAlgorithm"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.Version">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.AssemblyNameInfo.Version"/> or <c>null</c> if none specified
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.Attributes">
            <summary>
            Gets/sets the <see cref="T:dnlib.DotNet.AssemblyAttributes"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.PublicKeyOrToken">
            <summary>
            Gets/sets the public key or token
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.Name">
            <summary>
            Gets/sets the name
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.Culture">
            <summary>
            Gets/sets the culture or <c>null</c> if none specified
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.FullName">
            <summary>
            Gets the full name of the assembly
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.FullNameToken">
            <summary>
            Gets the full name of the assembly but use a public key token
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyNameInfo.ModifyAttributes(dnlib.DotNet.AssemblyAttributes,dnlib.DotNet.AssemblyAttributes)">
            <summary>
            Modify <see cref="P:dnlib.DotNet.AssemblyNameInfo.Attributes"/> property: <see cref="P:dnlib.DotNet.AssemblyNameInfo.Attributes"/> =
            (<see cref="P:dnlib.DotNet.AssemblyNameInfo.Attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
            </summary>
            <param name="andMask">Value to <c>AND</c></param>
            <param name="orMask">Value to OR</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyNameInfo.ModifyAttributes(System.Boolean,dnlib.DotNet.AssemblyAttributes)">
            <summary>
            Set or clear flags in <see cref="P:dnlib.DotNet.AssemblyNameInfo.Attributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.HasPublicKey">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.PublicKey"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.ProcessorArchitecture">
            <summary>
            Gets/sets the processor architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.ProcessorArchitectureFull">
            <summary>
            Gets/sets the processor architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.IsProcessorArchitectureNone">
            <summary>
            <c>true</c> if unspecified processor architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.IsProcessorArchitectureMSIL">
            <summary>
            <c>true</c> if neutral (PE32) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.IsProcessorArchitectureX86">
            <summary>
            <c>true</c> if x86 (PE32) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.IsProcessorArchitectureIA64">
            <summary>
            <c>true</c> if IA-64 (PE32+) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.IsProcessorArchitectureX64">
            <summary>
            <c>true</c> if x64 (PE32+) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.IsProcessorArchitectureARM">
            <summary>
            <c>true</c> if ARM (PE32) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.IsProcessorArchitectureNoPlatform">
            <summary>
            <c>true</c> if eg. reference assembly (not runnable)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.IsProcessorArchitectureSpecified">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.PA_Specified"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.EnableJITcompileTracking">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.EnableJITcompileTracking"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.DisableJITcompileOptimizer">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.DisableJITcompileOptimizer"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.IsRetargetable">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.Retargetable"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.ContentType">
            <summary>
            Gets/sets the content type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.IsContentTypeDefault">
            <summary>
            <c>true</c> if content type is <c>Default</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyNameInfo.IsContentTypeWindowsRuntime">
            <summary>
            <c>true</c> if content type is <c>WindowsRuntime</c>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyNameInfo.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyNameInfo.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="asmFullName">An assembly name</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyNameInfo.#ctor(dnlib.DotNet.IAssembly)">
            <summary>
            Constructor
            </summary>
            <param name="asm">The assembly</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyNameInfo.#ctor(System.Reflection.AssemblyName)">
            <summary>
            Constructor
            </summary>
            <param name="asmName">Assembly name info</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyNameInfo.ToString">
            <inhertidoc/>
        </member>
        <member name="T:dnlib.DotNet.AssemblyRef">
            <summary>
            A high-level representation of a row in the AssemblyRef table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyRef.CurrentAssembly">
            <summary>
            An assembly ref that can be used to indicate that it references the current assembly
            when the current assembly is not known (eg. a type string without any assembly info
            when it references a type in the current assembly).
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyRef.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.ImplementationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.ResolutionScopeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.ScopeType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.ScopeName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.Version">
            <summary>
            From columns AssemblyRef.MajorVersion, AssemblyRef.MinorVersion,
            AssemblyRef.BuildNumber, AssemblyRef.RevisionNumber
            </summary>
            <exception cref="T:System.ArgumentNullException">If <paramref name="value"/> is <c>null</c></exception>
        </member>
        <member name="F:dnlib.DotNet.AssemblyRef.version">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.Attributes">
            <summary>
            From column AssemblyRef.Flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyRef.attributes">
            <summary>Attributes</summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.PublicKeyOrToken">
            <summary>
            From column AssemblyRef.PublicKeyOrToken
            </summary>
            <exception cref="T:System.ArgumentNullException">If <paramref name="value"/> is <c>null</c></exception>
        </member>
        <member name="F:dnlib.DotNet.AssemblyRef.publicKeyOrToken">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.Name">
            <summary>
            From column AssemblyRef.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyRef.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.Culture">
            <summary>
            From column AssemblyRef.Locale
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyRef.culture">
            <summary>Culture</summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.Hash">
            <summary>
            From column AssemblyRef.HashValue
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyRef.hashValue">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyRef.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRef.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.AssemblyRef.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyRef.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRef.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.AssemblyRef.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.FullName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.RealFullName">
            <summary>
            Same as <see cref="P:dnlib.DotNet.AssemblyRef.FullName"/>, except that it uses the <c>PublicKey</c> if available.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.FullNameToken">
            <summary>
            Gets the full name of the assembly but use a public key token
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRef.ModifyAttributes(dnlib.DotNet.AssemblyAttributes,dnlib.DotNet.AssemblyAttributes)">
            <summary>
            Modify <see cref="F:dnlib.DotNet.AssemblyRef.attributes"/> property: <see cref="F:dnlib.DotNet.AssemblyRef.attributes"/> =
            (<see cref="F:dnlib.DotNet.AssemblyRef.attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
            </summary>
            <param name="andMask">Value to <c>AND</c></param>
            <param name="orMask">Value to OR</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRef.ModifyAttributes(System.Boolean,dnlib.DotNet.AssemblyAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.AssemblyRef.attributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.HasPublicKey">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.PublicKey"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.ProcessorArchitecture">
            <summary>
            Gets/sets the processor architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.ProcessorArchitectureFull">
            <summary>
            Gets/sets the processor architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.IsProcessorArchitectureNone">
            <summary>
            <c>true</c> if unspecified processor architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.IsProcessorArchitectureMSIL">
            <summary>
            <c>true</c> if neutral (PE32) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.IsProcessorArchitectureX86">
            <summary>
            <c>true</c> if x86 (PE32) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.IsProcessorArchitectureIA64">
            <summary>
            <c>true</c> if IA-64 (PE32+) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.IsProcessorArchitectureX64">
            <summary>
            <c>true</c> if x64 (PE32+) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.IsProcessorArchitectureARM">
            <summary>
            <c>true</c> if ARM (PE32) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.IsProcessorArchitectureNoPlatform">
            <summary>
            <c>true</c> if eg. reference assembly (not runnable)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.IsProcessorArchitectureSpecified">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.PA_Specified"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.EnableJITcompileTracking">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.EnableJITcompileTracking"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.DisableJITcompileOptimizer">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.DisableJITcompileOptimizer"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.IsRetargetable">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.Retargetable"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.ContentType">
            <summary>
            Gets/sets the content type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.IsContentTypeDefault">
            <summary>
            <c>true</c> if content type is <c>Default</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRef.IsContentTypeWindowsRuntime">
            <summary>
            <c>true</c> if content type is <c>WindowsRuntime</c>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRef.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.AssemblyRefUser">
            <summary>
            An AssemblyRef row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefUser.CreateMscorlibReferenceCLR10">
            <summary>
            Creates a reference to CLR 1.0's mscorlib
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefUser.CreateMscorlibReferenceCLR11">
            <summary>
            Creates a reference to CLR 1.1's mscorlib
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefUser.CreateMscorlibReferenceCLR20">
            <summary>
            Creates a reference to CLR 2.0's mscorlib
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefUser.CreateMscorlibReferenceCLR40">
            <summary>
            Creates a reference to CLR 4.0's mscorlib
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefUser.#ctor(dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Simple name</param>
            <exception cref="T:System.ArgumentNullException">If any of the args is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefUser.#ctor(dnlib.DotNet.UTF8String,System.Version)">
            <summary>
            Constructor
            </summary>
            <param name="name">Simple name</param>
            <param name="version">Version</param>
            <exception cref="T:System.ArgumentNullException">If any of the args is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefUser.#ctor(dnlib.DotNet.UTF8String,System.Version,dnlib.DotNet.PublicKeyBase)">
            <summary>
            Constructor
            </summary>
            <param name="name">Simple name</param>
            <param name="version">Version</param>
            <param name="publicKey">Public key or public key token</param>
            <exception cref="T:System.ArgumentNullException">If any of the args is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefUser.#ctor(dnlib.DotNet.UTF8String,System.Version,dnlib.DotNet.PublicKeyBase,dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Simple name</param>
            <param name="version">Version</param>
            <param name="publicKey">Public key or public key token</param>
            <param name="locale">Locale</param>
            <exception cref="T:System.ArgumentNullException">If any of the args is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefUser.#ctor(System.Reflection.AssemblyName)">
            <summary>
            Constructor
            </summary>
            <param name="asmName">Assembly name info</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="asmName"/> is <c>null</c></exception>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefUser.#ctor(dnlib.DotNet.IAssembly)">
            <summary>
            Constructor
            </summary>
            <param name="assembly">Assembly</param>
        </member>
        <member name="T:dnlib.DotNet.AssemblyRefMD">
            <summary>
            Created from a row in the AssemblyRef table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.AssemblyRefMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyRefMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyRefMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>AssemblyRef</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.AssemblyResolver">
            <summary>
            Resolves assemblies
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyResolver.DefaultModuleContext">
            <summary>
            Gets/sets the default <see cref="T:dnlib.DotNet.ModuleContext"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyResolver.FindExactMatch">
            <summary>
            <c>true</c> if <see cref="M:dnlib.DotNet.AssemblyResolver.Resolve(dnlib.DotNet.IAssembly,dnlib.DotNet.ModuleDef)"/> should find an assembly that matches exactly.
            <c>false</c> if it first tries to match exactly, and if that fails, it picks an
            assembly that is closest to the requested assembly.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyResolver.EnableFrameworkRedirect">
            <summary>
            <c>true</c> if resolved .NET framework assemblies can be redirected to the source
            module's framework assembly version. Eg. if a resolved .NET 3.5 assembly can be
            redirected to a .NET 4.0 assembly if the source module is a .NET 4.0 assembly. This is
            ignored if <see cref="P:dnlib.DotNet.AssemblyResolver.FindExactMatch"/> is <c>true</c>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyResolver.EnableTypeDefCache">
            <summary>
            If <c>true</c>, all modules in newly resolved assemblies will have their
            <see cref="P:dnlib.DotNet.ModuleDef.EnableTypeDefFindCache"/> property set to <c>true</c>. This is
            enabled by default since these modules shouldn't be modified by the user.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyResolver.UseGAC">
            <summary>
            true to search the Global Assembly Cache. Default value is true.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyResolver.PreSearchPaths">
            <summary>
            Gets paths searched before trying the standard locations
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyResolver.PostSearchPaths">
            <summary>
            Gets paths searched after trying the standard locations
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.#ctor(dnlib.DotNet.ModuleContext)">
            <summary>
            Constructor
            </summary>
            <param name="defaultModuleContext">Module context for all resolved assemblies</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.Resolve(dnlib.DotNet.IAssembly,dnlib.DotNet.ModuleDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.AddToCache(dnlib.DotNet.ModuleDef)">
            <summary>
            Add a module's assembly to the assembly cache
            </summary>
            <param name="module">The module whose assembly should be cached</param>
            <returns><c>true</c> if <paramref name="module"/>'s assembly is cached, <c>false</c>
            if it's not cached because some other assembly with the exact same full name has
            already been cached or if <paramref name="module"/> or its assembly is <c>null</c>.</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.AddToCache(dnlib.DotNet.AssemblyDef)">
            <summary>
            Add an assembly to the assembly cache
            </summary>
            <param name="asm">The assembly</param>
            <returns><c>true</c> if <paramref name="asm"/> is cached, <c>false</c> if it's not
            cached because some other assembly with the exact same full name has already been
            cached or if <paramref name="asm"/> is <c>null</c>.</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.Remove(dnlib.DotNet.ModuleDef)">
            <summary>
            Removes a module's assembly from the cache
            </summary>
            <param name="module">The module</param>
            <returns><c>true</c> if its assembly was removed, <c>false</c> if it wasn't removed
            since it wasn't in the cache, it has no assembly, or <paramref name="module"/> was
            <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.Remove(dnlib.DotNet.AssemblyDef)">
            <summary>
            Removes the assembly from the cache
            </summary>
            <param name="asm">The assembly</param>
            <returns><c>true</c> if it was removed, <c>false</c> if it wasn't removed since it
            wasn't in the cache or if <paramref name="asm"/> was <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.Clear">
            <summary>
            Clears the cache and calls <see cref="M:System.IDisposable.Dispose"/> on each cached module.
            Use <see cref="M:dnlib.DotNet.AssemblyResolver.Remove(dnlib.DotNet.AssemblyDef)"/> to remove any assemblies you added yourself
            using <see cref="M:dnlib.DotNet.AssemblyResolver.AddToCache(dnlib.DotNet.AssemblyDef)"/> before calling this method if you don't want
            them disposed.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.GetCachedAssemblies">
            <summary>
            Gets the cached assemblies in this resolver.
            </summary>
            <returns>The cached assemblies.</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.FindExactAssembly(dnlib.DotNet.IAssembly,System.Collections.Generic.IEnumerable{System.String},dnlib.DotNet.ModuleContext)">
            <summary>
            Finds an assembly that exactly matches the requested assembly
            </summary>
            <param name="assembly">Assembly to find</param>
            <param name="paths">Search paths or <c>null</c> if none</param>
            <param name="moduleContext">Module context</param>
            <returns>An <see cref="T:dnlib.DotNet.AssemblyDef"/> instance or <c>null</c> if an exact match
            couldn't be found.</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.FindClosestAssembly(dnlib.DotNet.IAssembly)">
            <summary>
            Finds the closest assembly from the already cached assemblies
            </summary>
            <param name="assembly">Assembly to find</param>
            <returns>The closest <see cref="T:dnlib.DotNet.AssemblyDef"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.IsCached(dnlib.DotNet.AssemblyDef)">
            <summary>
            Returns <c>true</c> if <paramref name="asm"/> is inserted in <see cref="F:dnlib.DotNet.AssemblyResolver.cachedAssemblies"/>
            </summary>
            <param name="asm">Assembly to check</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.PreFindAssemblies(dnlib.DotNet.IAssembly,dnlib.DotNet.ModuleDef,System.Boolean)">
            <summary>
            Called before <see cref="M:dnlib.DotNet.AssemblyResolver.FindAssemblies(dnlib.DotNet.IAssembly,dnlib.DotNet.ModuleDef,System.Boolean)"/>
            </summary>
            <param name="assembly">Assembly to find</param>
            <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
            <param name="matchExactly">We're trying to find an exact match</param>
            <returns><c>null</c> or an enumerable of full paths to try</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.PostFindAssemblies(dnlib.DotNet.IAssembly,dnlib.DotNet.ModuleDef,System.Boolean)">
            <summary>
            Called after <see cref="M:dnlib.DotNet.AssemblyResolver.FindAssemblies(dnlib.DotNet.IAssembly,dnlib.DotNet.ModuleDef,System.Boolean)"/> (if it fails)
            </summary>
            <param name="assembly">Assembly to find</param>
            <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
            <param name="matchExactly">We're trying to find an exact match</param>
            <returns><c>null</c> or an enumerable of full paths to try</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.FindAssemblies(dnlib.DotNet.IAssembly,dnlib.DotNet.ModuleDef,System.Boolean)">
            <summary>
            Called after <see cref="M:dnlib.DotNet.AssemblyResolver.PreFindAssemblies(dnlib.DotNet.IAssembly,dnlib.DotNet.ModuleDef,System.Boolean)"/> (if it fails)
            </summary>
            <param name="assembly">Assembly to find</param>
            <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
            <param name="matchExactly">We're trying to find an exact match</param>
            <returns><c>null</c> or an enumerable of full paths to try</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.GetSearchPaths(dnlib.DotNet.ModuleDef)">
            <summary>
            Gets all search paths to use for this module
            </summary>
            <param name="module">The module or <c>null</c> if unknown</param>
            <returns>A list of all search paths to use for this module</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.GetModuleSearchPaths(dnlib.DotNet.ModuleDef)">
            <summary>
            Gets all module search paths. This is usually empty unless its assembly has
            a <c>.config</c> file specifying any additional private search paths in a
            &lt;probing/&gt; element.
            </summary>
            <param name="module">The module or <c>null</c> if unknown</param>
            <returns>A list of search paths</returns>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolver.GetModulePrivateSearchPaths(dnlib.DotNet.ModuleDef)">
            <summary>
            Gets all private assembly search paths as found in the module's <c>.config</c> file.
            </summary>
            <param name="module">The module or <c>null</c> if unknown</param>
            <returns>A list of search paths</returns>
        </member>
        <member name="T:dnlib.DotNet.CallingConvention">
            <summary>
            See CorHdr.h/CorCallingConvention
            </summary>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.Default">
            <summary>The managed calling convention</summary>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.C">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.StdCall">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.ThisCall">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.FastCall">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.VarArg">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.Field">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.LocalSig">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.Property">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.Unmanaged">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.GenericInst">
            <summary>generic method instantiation</summary>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.NativeVarArg">
            <summary>used ONLY for 64bit vararg PInvoke calls</summary>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.Mask">
            <summary>Calling convention is bottom 4 bits</summary>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.Generic">
            <summary>Generic method</summary>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.HasThis">
            <summary>Method needs a 'this' parameter</summary>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.ExplicitThis">
            <summary>'this' parameter is the first arg if set (else it's hidden)</summary>
        </member>
        <member name="F:dnlib.DotNet.CallingConvention.ReservedByCLR">
            <summary>Used internally by the CLR</summary>
        </member>
        <member name="T:dnlib.DotNet.CallingConventionSig">
            <summary>
            Base class for sigs with a calling convention
            </summary>
        </member>
        <member name="F:dnlib.DotNet.CallingConventionSig.callingConvention">
            <summary>
            The calling convention
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.ExtraData">
            <summary>
            Gets/sets the extra data found after the signature
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.IsDefault">
            <summary>
            Returns <c>true</c> if <see cref="F:dnlib.DotNet.CallingConvention.Default"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.IsC">
            <summary>
            Returns <c>true</c> if <see cref="F:dnlib.DotNet.CallingConvention.C"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.IsStdCall">
            <summary>
            Returns <c>true</c> if <see cref="F:dnlib.DotNet.CallingConvention.StdCall"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.IsThisCall">
            <summary>
            Returns <c>true</c> if <see cref="F:dnlib.DotNet.CallingConvention.ThisCall"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.IsFastCall">
            <summary>
            Returns <c>true</c> if <see cref="F:dnlib.DotNet.CallingConvention.FastCall"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.IsVarArg">
            <summary>
            Returns <c>true</c> if <see cref="F:dnlib.DotNet.CallingConvention.VarArg"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.IsField">
            <summary>
            Returns <c>true</c> if <see cref="F:dnlib.DotNet.CallingConvention.Field"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.IsLocalSig">
            <summary>
            Returns <c>true</c> if <see cref="F:dnlib.DotNet.CallingConvention.LocalSig"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.IsProperty">
            <summary>
            Returns <c>true</c> if <see cref="F:dnlib.DotNet.CallingConvention.Property"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.IsUnmanaged">
            <summary>
            Returns <c>true</c> if <see cref="F:dnlib.DotNet.CallingConvention.Unmanaged"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.IsGenericInst">
            <summary>
            Returns <c>true</c> if <see cref="F:dnlib.DotNet.CallingConvention.GenericInst"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.IsNativeVarArg">
            <summary>
            Returns <c>true</c> if <see cref="F:dnlib.DotNet.CallingConvention.NativeVarArg"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.Generic">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.CallingConvention.Generic"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.HasThis">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.CallingConvention.HasThis"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.ExplicitThis">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.CallingConvention.ExplicitThis"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.ReservedByCLR">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.CallingConvention.ReservedByCLR"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.ImplicitThis">
            <summary>
            <c>true</c> if there's an implicit <c>this</c> parameter
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CallingConventionSig.ContainsGenericParameter">
            <summary>
            <c>true</c> if this <see cref="T:dnlib.DotNet.CallingConventionSig"/> contains a
            <see cref="T:dnlib.DotNet.GenericVar"/> or a <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CallingConventionSig.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CallingConventionSig.#ctor(dnlib.DotNet.CallingConvention)">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">The calling convention</param>
        </member>
        <member name="M:dnlib.DotNet.CallingConventionSig.GetCallingConvention">
            <summary>
            Gets the calling convention
            </summary>
        </member>
        <member name="T:dnlib.DotNet.FieldSig">
            <summary>
            A field signature
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldSig.Type">
            <summary>
            Gets/sets the field type
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FieldSig.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FieldSig.#ctor(dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="type">Field type</param>
        </member>
        <member name="M:dnlib.DotNet.FieldSig.#ctor(dnlib.DotNet.CallingConvention,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="type">Field type</param>
            <param name="callingConvention">The calling convention (must have Field set)</param>
        </member>
        <member name="M:dnlib.DotNet.FieldSig.Clone">
            <summary>
            Clone this
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FieldSig.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.MethodBaseSig">
            <summary>
            Method sig base class
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodBaseSig.retType">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.MethodBaseSig.parameters">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.MethodBaseSig.genParamCount">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.MethodBaseSig.paramsAfterSentinel">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.MethodBaseSig.CallingConvention">
            <summary>
            Gets/sets the calling convention
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodBaseSig.RetType">
            <summary>
            Gets/sets the return type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodBaseSig.Params">
            <summary>
            Gets the parameters. This is never <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodBaseSig.GenParamCount">
            <summary>
            Gets/sets the generic param count
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodBaseSig.ParamsAfterSentinel">
            <summary>
            Gets the parameters that are present after the sentinel. Note that this is <c>null</c>
            if there's no sentinel. It can still be empty even if it's not <c>null</c>.
            </summary>
        </member>
        <member name="T:dnlib.DotNet.MethodSig">
            <summary>
            A method signature
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodSig.OriginalToken">
            <summary>
            Gets/sets the original token. It's set when reading calli instruction operands
            and it's a hint to the module writer if it tries to re-use the same token.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateStatic(dnlib.DotNet.TypeSig)">
            <summary>
            Creates a static MethodSig
            </summary>
            <param name="retType">Return type</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateStatic(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates a static MethodSig
            </summary>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateStatic(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates a static MethodSig
            </summary>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateStatic(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates a static MethodSig
            </summary>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
            <param name="argType3">Arg type #3</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateStatic(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig[])">
            <summary>
            Creates a static MethodSig
            </summary>
            <param name="retType">Return type</param>
            <param name="argTypes">Argument types</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateInstance(dnlib.DotNet.TypeSig)">
            <summary>
            Creates an instance MethodSig
            </summary>
            <param name="retType">Return type</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateInstance(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates an instance MethodSig
            </summary>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateInstance(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates an instance MethodSig
            </summary>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateInstance(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates an instance MethodSig
            </summary>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
            <param name="argType3">Arg type #3</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateInstance(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig[])">
            <summary>
            Creates an instance MethodSig
            </summary>
            <param name="retType">Return type</param>
            <param name="argTypes">Argument types</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateStaticGeneric(System.UInt32,dnlib.DotNet.TypeSig)">
            <summary>
            Creates a static generic MethodSig
            </summary>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateStaticGeneric(System.UInt32,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates a static generic MethodSig
            </summary>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateStaticGeneric(System.UInt32,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates a static generic MethodSig
            </summary>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateStaticGeneric(System.UInt32,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates a static generic MethodSig
            </summary>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
            <param name="argType3">Arg type #3</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateStaticGeneric(System.UInt32,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig[])">
            <summary>
            Creates a static generic MethodSig
            </summary>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argTypes">Argument types</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateInstanceGeneric(System.UInt32,dnlib.DotNet.TypeSig)">
            <summary>
            Creates an instance generic MethodSig
            </summary>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateInstanceGeneric(System.UInt32,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates an instance generic MethodSig
            </summary>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateInstanceGeneric(System.UInt32,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates an instance generic MethodSig
            </summary>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateInstanceGeneric(System.UInt32,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates an instance generic MethodSig
            </summary>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
            <param name="argType3">Arg type #3</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.CreateInstanceGeneric(System.UInt32,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig[])">
            <summary>
            Creates an instance generic MethodSig
            </summary>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argTypes">Argument types</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.#ctor(dnlib.DotNet.CallingConvention)">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">Calling convention</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.#ctor(dnlib.DotNet.CallingConvention,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">Calling convention</param>
            <param name="genParamCount">Number of generic parameters</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.#ctor(dnlib.DotNet.CallingConvention,System.UInt32,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">Calling convention</param>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.#ctor(dnlib.DotNet.CallingConvention,System.UInt32,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">Calling convention</param>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.#ctor(dnlib.DotNet.CallingConvention,System.UInt32,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">Calling convention</param>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.#ctor(dnlib.DotNet.CallingConvention,System.UInt32,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">Calling convention</param>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
            <param name="argType3">Arg type #3</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.#ctor(dnlib.DotNet.CallingConvention,System.UInt32,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig[])">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">Calling convention</param>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argTypes">Argument types</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.#ctor(dnlib.DotNet.CallingConvention,System.UInt32,dnlib.DotNet.TypeSig,System.Collections.Generic.IList{dnlib.DotNet.TypeSig})">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">Calling convention</param>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argTypes">Argument types</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.#ctor(dnlib.DotNet.CallingConvention,System.UInt32,dnlib.DotNet.TypeSig,System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Collections.Generic.IList{dnlib.DotNet.TypeSig})">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">Calling convention</param>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argTypes">Argument types</param>
            <param name="paramsAfterSentinel">Parameters after sentinel</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.Clone">
            <summary>
            Clone this
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodSig.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.PropertySig">
            <summary>
            A property signature
            </summary>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.CreateStatic(dnlib.DotNet.TypeSig)">
            <summary>
            Creates a static PropertySig
            </summary>
            <param name="retType">Return type</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.CreateStatic(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates a static PropertySig
            </summary>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.CreateStatic(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates a static PropertySig
            </summary>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.CreateStatic(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates a static PropertySig
            </summary>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
            <param name="argType3">Arg type #3</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.CreateStatic(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig[])">
            <summary>
            Creates a static PropertySig
            </summary>
            <param name="retType">Return type</param>
            <param name="argTypes">Argument types</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.CreateInstance(dnlib.DotNet.TypeSig)">
            <summary>
            Creates an instance PropertySig
            </summary>
            <param name="retType">Return type</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.CreateInstance(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates an instance PropertySig
            </summary>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.CreateInstance(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates an instance PropertySig
            </summary>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.CreateInstance(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Creates an instance PropertySig
            </summary>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
            <param name="argType3">Arg type #3</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.CreateInstance(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig[])">
            <summary>
            Creates an instance PropertySig
            </summary>
            <param name="retType">Return type</param>
            <param name="argTypes">Argument types</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.#ctor(dnlib.DotNet.CallingConvention)">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">Calling convention (must have Property set)</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.#ctor(System.Boolean,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
            <param name="retType">Return type</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.#ctor(System.Boolean,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.#ctor(System.Boolean,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.#ctor(System.Boolean,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
            <param name="retType">Return type</param>
            <param name="argType1">Arg type #1</param>
            <param name="argType2">Arg type #2</param>
            <param name="argType3">Arg type #3</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.#ctor(System.Boolean,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig[])">
            <summary>
            Constructor
            </summary>
            <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
            <param name="retType">Return type</param>
            <param name="argTypes">Argument types</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.#ctor(dnlib.DotNet.CallingConvention,System.UInt32,dnlib.DotNet.TypeSig,System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Collections.Generic.IList{dnlib.DotNet.TypeSig})">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">Calling convention</param>
            <param name="genParamCount">Number of generic parameters</param>
            <param name="retType">Return type</param>
            <param name="argTypes">Argument types</param>
            <param name="paramsAfterSentinel">Parameters after sentinel</param>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.Clone">
            <summary>
            Clone this
            </summary>
        </member>
        <member name="M:dnlib.DotNet.PropertySig.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.LocalSig">
            <summary>
            A local variables signature
            </summary>
        </member>
        <member name="P:dnlib.DotNet.LocalSig.Locals">
            <summary>
            All local types. This is never <c>null</c>.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.LocalSig.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.LocalSig.#ctor(dnlib.DotNet.CallingConvention,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">Calling convention (must have LocalSig set)</param>
            <param name="count">Number of locals</param>
        </member>
        <member name="M:dnlib.DotNet.LocalSig.#ctor(dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="local1">Local type #1</param>
        </member>
        <member name="M:dnlib.DotNet.LocalSig.#ctor(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="local1">Local type #1</param>
            <param name="local2">Local type #2</param>
        </member>
        <member name="M:dnlib.DotNet.LocalSig.#ctor(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="local1">Local type #1</param>
            <param name="local2">Local type #2</param>
            <param name="local3">Local type #3</param>
        </member>
        <member name="M:dnlib.DotNet.LocalSig.#ctor(dnlib.DotNet.TypeSig[])">
            <summary>
            Constructor
            </summary>
            <param name="locals">All locals</param>
        </member>
        <member name="M:dnlib.DotNet.LocalSig.#ctor(System.Collections.Generic.IList{dnlib.DotNet.TypeSig})">
            <summary>
            Constructor
            </summary>
            <param name="locals">All locals</param>
        </member>
        <member name="M:dnlib.DotNet.LocalSig.#ctor(System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="locals">All locals (this instance now owns it)</param>
            <param name="dummy">Dummy</param>
        </member>
        <member name="M:dnlib.DotNet.LocalSig.Clone">
            <summary>
            Clone this
            </summary>
        </member>
        <member name="T:dnlib.DotNet.GenericInstMethodSig">
            <summary>
            An instantiated generic method signature
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericInstMethodSig.GenericArguments">
            <summary>
            Gets the generic arguments (must be instantiated types, i.e., closed types)
            </summary>
        </member>
        <member name="M:dnlib.DotNet.GenericInstMethodSig.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.GenericInstMethodSig.#ctor(dnlib.DotNet.CallingConvention,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="callingConvention">Calling convention (must have GenericInst set)</param>
            <param name="size">Number of generic args</param>
        </member>
        <member name="M:dnlib.DotNet.GenericInstMethodSig.#ctor(dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="arg1">Generic arg #1</param>
        </member>
        <member name="M:dnlib.DotNet.GenericInstMethodSig.#ctor(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="arg1">Generic arg #1</param>
            <param name="arg2">Generic arg #2</param>
        </member>
        <member name="M:dnlib.DotNet.GenericInstMethodSig.#ctor(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="arg1">Generic arg #1</param>
            <param name="arg2">Generic arg #2</param>
            <param name="arg3">Generic arg #3</param>
        </member>
        <member name="M:dnlib.DotNet.GenericInstMethodSig.#ctor(dnlib.DotNet.TypeSig[])">
            <summary>
            Constructor
            </summary>
            <param name="args">Generic args</param>
        </member>
        <member name="M:dnlib.DotNet.GenericInstMethodSig.#ctor(System.Collections.Generic.IList{dnlib.DotNet.TypeSig})">
            <summary>
            Constructor
            </summary>
            <param name="args">Generic args</param>
        </member>
        <member name="M:dnlib.DotNet.GenericInstMethodSig.Clone">
            <summary>
            Clone this
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ClassLayout">
            <summary>
            A high-level representation of a row in the ClassLayout table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ClassLayout.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ClassLayout.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ClassLayout.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ClassLayout.PackingSize">
            <summary>
            From column ClassLayout.PackingSize
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ClassLayout.packingSize">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ClassLayout.ClassSize">
            <summary>
            From column ClassLayout.ClassSize
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ClassLayout.classSize">
            <summary/>
        </member>
        <member name="T:dnlib.DotNet.ClassLayoutUser">
            <summary>
            A ClassLayout row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ClassLayoutUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ClassLayoutUser.#ctor(System.UInt16,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="packingSize">PackingSize</param>
            <param name="classSize">ClassSize</param>
        </member>
        <member name="T:dnlib.DotNet.ClassLayoutMD">
            <summary>
            Created from a row in the ClassLayout table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ClassLayoutMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ClassLayoutMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>ClassLayout</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.Constant">
            <summary>
            A high-level representation of a row in the Constant table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Constant.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Constant.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Constant.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Constant.Type">
            <summary>
            From column Constant.Type
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Constant.type">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.Constant.Value">
            <summary>
            From column Constant.Value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Constant.value">
            <summary/>
        </member>
        <member name="T:dnlib.DotNet.ConstantUser">
            <summary>
            A Constant row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ConstantUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ConstantUser.#ctor(System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.ConstantUser.#ctor(System.Object,dnlib.DotNet.ElementType)">
            <summary>
            Constructor
            </summary>
            <param name="value">Value</param>
            <param name="type">Type</param>
        </member>
        <member name="T:dnlib.DotNet.ConstantMD">
            <summary>
            Created from a row in the Constant table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ConstantMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ConstantMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>Constant</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.CorLibTypes">
            <summary>
            Default implementation of <see cref="T:dnlib.DotNet.ICorLibTypes"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.Void">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.Boolean">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.Char">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.SByte">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.Byte">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.Int16">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.UInt16">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.Int32">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.UInt32">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.Int64">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.UInt64">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.Single">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.Double">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.String">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.TypedReference">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.IntPtr">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.UIntPtr">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.Object">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypes.AssemblyRef">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.CorLibTypes.#ctor(dnlib.DotNet.ModuleDef)">
            <summary>
            Constructor
            </summary>
            <param name="module">The owner module</param>
        </member>
        <member name="M:dnlib.DotNet.CorLibTypes.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.AssemblyRef)">
            <summary>
            Constructor
            </summary>
            <param name="module">The owner module</param>
            <param name="corLibAssemblyRef">Corlib assembly reference or <c>null</c> if a default
            assembly reference should be created</param>
        </member>
        <member name="M:dnlib.DotNet.CorLibTypes.GetTypeRef(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.CpuArch.GetStubAlignment(dnlib.DotNet.StubType)">
            <summary>
            Gets the required alignment for the stubs, must be a power of 2
            </summary>
            <param name="stubType">Stub type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.CpuArch.GetStubSize(dnlib.DotNet.StubType)">
            <summary>
            Gets the size of a stub, it doesn't have to be a multiple of <see cref="M:dnlib.DotNet.CpuArch.GetStubAlignment(dnlib.DotNet.StubType)"/>
            </summary>
            <param name="stubType">Stub type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.CpuArch.GetStubCodeOffset(dnlib.DotNet.StubType)">
            <summary>
            Gets the offset of the code (entry point) relative to the start of the stub
            </summary>
            <param name="stubType">Stub type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.CpuArch.TryGetExportedRvaFromStub(dnlib.IO.DataReader@,dnlib.PE.IPEImage,System.UInt32@)">
            <summary>
            Gets the RVA of the func field that the stub jumps to
            </summary>
            <param name="reader">Reader, positioned at the stub func</param>
            <param name="peImage">PE image</param>
            <param name="funcRva">Updated with RVA of func field</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.CpuArch.WriteStubRelocs(dnlib.DotNet.StubType,dnlib.DotNet.Writer.RelocDirectory,dnlib.DotNet.Writer.IChunk,System.UInt32)">
            <summary>
            Writes stub relocs, if needed
            </summary>
            <param name="stubType">Stub type</param>
            <param name="relocDirectory">Reloc directory</param>
            <param name="chunk">The chunk where this stub will be written to</param>
            <param name="stubOffset">Offset of this stub in <paramref name="chunk"/></param>
        </member>
        <member name="M:dnlib.DotNet.CpuArch.WriteStub(dnlib.DotNet.StubType,dnlib.DotNet.Writer.DataWriter,System.UInt64,System.UInt32,System.UInt32)">
            <summary>
            Writes the stub that jumps to the managed function
            </summary>
            <param name="stubType">Stub type</param>
            <param name="writer">Writer</param>
            <param name="imageBase">Image base</param>
            <param name="stubRva">RVA of this stub</param>
            <param name="managedFuncRva">RVA of a pointer-sized field that contains the absolute address of the managed function</param>
        </member>
        <member name="T:dnlib.DotNet.CustomAttribute">
            <summary>
            A custom attribute
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomAttribute.Constructor">
            <summary>
            Gets/sets the custom attribute constructor
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomAttribute.AttributeType">
            <summary>
            Gets the attribute type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomAttribute.TypeFullName">
            <summary>
            Gets the full name of the attribute type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomAttribute.IsRawBlob">
            <summary>
            <c>true</c> if the raw custom attribute blob hasn't been parsed
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomAttribute.RawData">
            <summary>
            Gets the raw custom attribute blob or <c>null</c> if the CA was successfully parsed.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomAttribute.ConstructorArguments">
            <summary>
            Gets all constructor arguments
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomAttribute.HasConstructorArguments">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.CustomAttribute.ConstructorArguments"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomAttribute.NamedArguments">
            <summary>
            Gets all named arguments (field and property values)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomAttribute.HasNamedArguments">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.CustomAttribute.NamedArguments"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomAttribute.Fields">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.CANamedArgument"/>s that are field arguments
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomAttribute.Properties">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.CANamedArgument"/>s that are property arguments
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomAttribute.BlobOffset">
            <summary>
            Gets the #Blob offset or 0 if unknown
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.#ctor(dnlib.DotNet.ICustomAttributeType,System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="ctor">Custom attribute constructor</param>
            <param name="rawData">Raw custom attribute blob</param>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.#ctor(dnlib.DotNet.ICustomAttributeType)">
            <summary>
            Constructor
            </summary>
            <param name="ctor">Custom attribute constructor</param>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.#ctor(dnlib.DotNet.ICustomAttributeType,System.Collections.Generic.IEnumerable{dnlib.DotNet.CAArgument})">
            <summary>
            Constructor
            </summary>
            <param name="ctor">Custom attribute constructor</param>
            <param name="arguments">Constructor arguments or <c>null</c> if none</param>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.#ctor(dnlib.DotNet.ICustomAttributeType,System.Collections.Generic.IEnumerable{dnlib.DotNet.CANamedArgument})">
            <summary>
            Constructor
            </summary>
            <param name="ctor">Custom attribute constructor</param>
            <param name="namedArguments">Named arguments or <c>null</c> if none</param>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.#ctor(dnlib.DotNet.ICustomAttributeType,System.Collections.Generic.IEnumerable{dnlib.DotNet.CAArgument},System.Collections.Generic.IEnumerable{dnlib.DotNet.CANamedArgument})">
            <summary>
            Constructor
            </summary>
            <param name="ctor">Custom attribute constructor</param>
            <param name="arguments">Constructor arguments or <c>null</c> if none</param>
            <param name="namedArguments">Named arguments or <c>null</c> if none</param>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.#ctor(dnlib.DotNet.ICustomAttributeType,System.Collections.Generic.IEnumerable{dnlib.DotNet.CAArgument},System.Collections.Generic.IEnumerable{dnlib.DotNet.CANamedArgument},System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="ctor">Custom attribute constructor</param>
            <param name="arguments">Constructor arguments or <c>null</c> if none</param>
            <param name="namedArguments">Named arguments or <c>null</c> if none</param>
            <param name="caBlobOffset">Original custom attribute #Blob offset or 0</param>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.#ctor(dnlib.DotNet.ICustomAttributeType,System.Collections.Generic.List{dnlib.DotNet.CAArgument},System.Collections.Generic.List{dnlib.DotNet.CANamedArgument},System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="ctor">Custom attribute constructor</param>
            <param name="arguments">Constructor arguments. The list is now owned by this instance.</param>
            <param name="namedArguments">Named arguments. The list is now owned by this instance.</param>
            <param name="caBlobOffset">Original custom attribute #Blob offset or 0</param>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.GetField(System.String)">
            <summary>
            Gets the field named <paramref name="name"/>
            </summary>
            <param name="name">Name of field</param>
            <returns>A <see cref="T:dnlib.DotNet.CANamedArgument"/> instance or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.GetField(dnlib.DotNet.UTF8String)">
            <summary>
            Gets the field named <paramref name="name"/>
            </summary>
            <param name="name">Name of field</param>
            <returns>A <see cref="T:dnlib.DotNet.CANamedArgument"/> instance or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.GetProperty(System.String)">
            <summary>
            Gets the property named <paramref name="name"/>
            </summary>
            <param name="name">Name of property</param>
            <returns>A <see cref="T:dnlib.DotNet.CANamedArgument"/> instance or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.GetProperty(dnlib.DotNet.UTF8String)">
            <summary>
            Gets the property named <paramref name="name"/>
            </summary>
            <param name="name">Name of property</param>
            <returns>A <see cref="T:dnlib.DotNet.CANamedArgument"/> instance or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.GetNamedArgument(System.String,System.Boolean)">
            <summary>
            Gets the property/field named <paramref name="name"/>
            </summary>
            <param name="name">Name of property/field</param>
            <param name="isField"><c>true</c> if it's a field, <c>false</c> if it's a property</param>
            <returns>A <see cref="T:dnlib.DotNet.CANamedArgument"/> instance or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.GetNamedArgument(dnlib.DotNet.UTF8String,System.Boolean)">
            <summary>
            Gets the property/field named <paramref name="name"/>
            </summary>
            <param name="name">Name of property/field</param>
            <param name="isField"><c>true</c> if it's a field, <c>false</c> if it's a property</param>
            <returns>A <see cref="T:dnlib.DotNet.CANamedArgument"/> instance or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttribute.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.CAArgument">
            <summary>
            A custom attribute constructor argument
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CAArgument.Type">
            <summary>
            Gets/sets the argument type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CAArgument.Value">
            <summary>
            Gets/sets the argument value
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CAArgument.#ctor(dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="type">Argument type</param>
        </member>
        <member name="M:dnlib.DotNet.CAArgument.#ctor(dnlib.DotNet.TypeSig,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="type">Argument type</param>
            <param name="value">Argument value</param>
        </member>
        <member name="M:dnlib.DotNet.CAArgument.Clone">
            <summary>
            Clones this instance and any <see cref="T:dnlib.DotNet.CAArgument"/>s and <see cref="T:dnlib.DotNet.CANamedArgument"/>s
            referenced from this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.CAArgument.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.CANamedArgument">
            <summary>
            A custom attribute field/property argument
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CANamedArgument.IsField">
            <summary>
            <c>true</c> if it's a field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CANamedArgument.IsProperty">
            <summary>
            <c>true</c> if it's a property
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CANamedArgument.Type">
            <summary>
            Gets/sets the field/property type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CANamedArgument.Name">
            <summary>
            Gets/sets the property/field name
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CANamedArgument.Argument">
            <summary>
            Gets/sets the argument
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CANamedArgument.ArgumentType">
            <summary>
            Gets/sets the argument type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CANamedArgument.Value">
            <summary>
            Gets/sets the argument value
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CANamedArgument.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CANamedArgument.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="isField"><c>true</c> if field, <c>false</c> if property</param>
        </member>
        <member name="M:dnlib.DotNet.CANamedArgument.#ctor(System.Boolean,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="isField"><c>true</c> if field, <c>false</c> if property</param>
            <param name="type">Field/property type</param>
        </member>
        <member name="M:dnlib.DotNet.CANamedArgument.#ctor(System.Boolean,dnlib.DotNet.TypeSig,dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="isField"><c>true</c> if field, <c>false</c> if property</param>
            <param name="type">Field/property type</param>
            <param name="name">Name of field/property</param>
        </member>
        <member name="M:dnlib.DotNet.CANamedArgument.#ctor(System.Boolean,dnlib.DotNet.TypeSig,dnlib.DotNet.UTF8String,dnlib.DotNet.CAArgument)">
            <summary>
            Constructor
            </summary>
            <param name="isField"><c>true</c> if field, <c>false</c> if property</param>
            <param name="type">Field/property type</param>
            <param name="name">Name of field/property</param>
            <param name="argument">Field/property argument</param>
        </member>
        <member name="M:dnlib.DotNet.CANamedArgument.Clone">
            <summary>
            Clones this instance and any <see cref="T:dnlib.DotNet.CAArgument"/>s referenced from this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.CANamedArgument.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.CustomAttributeCollection">
            <summary>
            Stores <see cref="T:dnlib.DotNet.CustomAttribute"/>s
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeCollection.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeCollection.#ctor(System.Int32,System.Object,System.Func{System.Object,System.Int32,dnlib.DotNet.CustomAttribute})">
            <summary>
            Constructor
            </summary>
            <param name="length">Initial length of the list</param>
            <param name="context">Context passed to <paramref name="readOriginalValue"/></param>
            <param name="readOriginalValue">Delegate instance that returns original values</param>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeCollection.IsDefined(System.String)">
            <summary>
            Checks whether a custom attribute is present
            </summary>
            <param name="fullName">Full name of custom attribute type</param>
            <returns><c>true</c> if the custom attribute type is present, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeCollection.RemoveAll(System.String)">
            <summary>
            Removes all custom attributes of a certain type
            </summary>
            <param name="fullName">Full name of custom attribute type that should be removed</param>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeCollection.Find(System.String)">
            <summary>
            Finds a custom attribute
            </summary>
            <param name="fullName">Full name of custom attribute type</param>
            <returns>A <see cref="T:dnlib.DotNet.CustomAttribute"/> or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeCollection.FindAll(System.String)">
            <summary>
            Finds all custom attributes of a certain type
            </summary>
            <param name="fullName">Full name of custom attribute type</param>
            <returns>All <see cref="T:dnlib.DotNet.CustomAttribute"/>s of the requested type</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeCollection.Find(dnlib.DotNet.IType)">
            <summary>
            Finds a custom attribute
            </summary>
            <param name="attrType">Custom attribute type</param>
            <returns>The first <see cref="T:dnlib.DotNet.CustomAttribute"/> found or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeCollection.Find(dnlib.DotNet.IType,dnlib.DotNet.SigComparerOptions)">
            <summary>
            Finds a custom attribute
            </summary>
            <param name="attrType">Custom attribute type</param>
            <param name="options">Attribute type comparison flags</param>
            <returns>The first <see cref="T:dnlib.DotNet.CustomAttribute"/> found or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeCollection.FindAll(dnlib.DotNet.IType)">
            <summary>
            Finds all custom attributes of a certain type
            </summary>
            <param name="attrType">Custom attribute type</param>
            <returns>All <see cref="T:dnlib.DotNet.CustomAttribute"/>s of the requested type</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeCollection.FindAll(dnlib.DotNet.IType,dnlib.DotNet.SigComparerOptions)">
            <summary>
            Finds all custom attributes of a certain type
            </summary>
            <param name="attrType">Custom attribute type</param>
            <param name="options">Attribute type comparison flags</param>
            <returns>All <see cref="T:dnlib.DotNet.CustomAttribute"/>s of the requested type</returns>
        </member>
        <member name="T:dnlib.DotNet.CAAssemblyRefFinder">
            <summary>
            Searches for a type according to custom attribute search rules: first try the
            current assembly, and if that fails, try mscorlib
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CAAssemblyRefFinder.#ctor(dnlib.DotNet.ModuleDef)">
            <summary>
            Constructor
            </summary>
            <param name="module">The module to search first</param>
        </member>
        <member name="M:dnlib.DotNet.CAAssemblyRefFinder.FindAssemblyRef(dnlib.DotNet.TypeRef)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.CABlobParserException">
            <summary>
            Thrown by CustomAttributeReader when it fails to parse a custom attribute blob
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CABlobParserException.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CABlobParserException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Error message</param>
        </member>
        <member name="M:dnlib.DotNet.CABlobParserException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Error message</param>
            <param name="innerException">Other exception</param>
        </member>
        <member name="M:dnlib.DotNet.CABlobParserException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:dnlib.DotNet.CustomAttributeReader">
            <summary>
            Reads custom attributes from the #Blob stream
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeReader.Read(dnlib.DotNet.ModuleDefMD,dnlib.DotNet.ICustomAttributeType,System.UInt32)">
            <summary>
            Reads a custom attribute
            </summary>
            <param name="readerModule">Reader module</param>
            <param name="ctor">Custom attribute constructor</param>
            <param name="offset">Offset of custom attribute in the #Blob stream</param>
            <returns>A new <see cref="T:dnlib.DotNet.CustomAttribute"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeReader.Read(dnlib.DotNet.ModuleDefMD,dnlib.DotNet.ICustomAttributeType,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a custom attribute
            </summary>
            <param name="readerModule">Reader module</param>
            <param name="ctor">Custom attribute constructor</param>
            <param name="offset">Offset of custom attribute in the #Blob stream</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.CustomAttribute"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeReader.Read(dnlib.DotNet.ModuleDef,System.Byte[],dnlib.DotNet.ICustomAttributeType)">
            <summary>
            Reads a custom attribute
            </summary>
            <param name="module">Owner module</param>
            <param name="caBlob">CA blob</param>
            <param name="ctor">Custom attribute constructor</param>
            <returns>A new <see cref="T:dnlib.DotNet.CustomAttribute"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeReader.Read(dnlib.DotNet.ModuleDef,dnlib.IO.DataReader,dnlib.DotNet.ICustomAttributeType)">
            <summary>
            Reads a custom attribute
            </summary>
            <param name="module">Owner module</param>
            <param name="reader">A reader positioned at the the first byte of the CA blob</param>
            <param name="ctor">Custom attribute constructor</param>
            <returns>A new <see cref="T:dnlib.DotNet.CustomAttribute"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeReader.Read(dnlib.DotNet.ModuleDef,System.Byte[],dnlib.DotNet.ICustomAttributeType,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a custom attribute
            </summary>
            <param name="module">Owner module</param>
            <param name="caBlob">CA blob</param>
            <param name="ctor">Custom attribute constructor</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.CustomAttribute"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeReader.Read(dnlib.DotNet.ModuleDef,dnlib.IO.DataReader,dnlib.DotNet.ICustomAttributeType,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a custom attribute
            </summary>
            <param name="module">Owner module</param>
            <param name="reader">A stream positioned at the the first byte of the CA blob</param>
            <param name="ctor">Custom attribute constructor</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.CustomAttribute"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeReader.Read(dnlib.DotNet.ModuleDef,dnlib.IO.DataReader@,dnlib.DotNet.ICustomAttributeType,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a custom attribute
            </summary>
            <param name="module">Owner module</param>
            <param name="reader">A stream positioned at the the first byte of the CA blob</param>
            <param name="ctor">Custom attribute constructor</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.CustomAttribute"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeReader.ReadNamedArguments(dnlib.DotNet.ModuleDef,dnlib.IO.DataReader@,System.Int32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads custom attribute named arguments
            </summary>
            <param name="module">Owner module</param>
            <param name="reader">A reader positioned at the the first byte of the CA blob</param>
            <param name="numNamedArgs">Number of named arguments to read from <paramref name="reader"/></param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A list of <see cref="T:dnlib.DotNet.CANamedArgument"/>s or <c>null</c> if some error
            occurred.</returns>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeReader.GetEnumUnderlyingType(dnlib.DotNet.TypeSig)">
            <summary>
            Gets the enum's underlying type
            </summary>
            <param name="type">An enum type</param>
            <returns>The underlying type or <c>null</c> if we couldn't resolve the type ref</returns>
            <exception cref="T:dnlib.DotNet.CABlobParserException">If <paramref name="type"/> is not an enum or <c>null</c></exception>
        </member>
        <member name="M:dnlib.DotNet.CustomAttributeReader.GetTypeDef(dnlib.DotNet.TypeSig)">
            <summary>
            Converts <paramref name="type"/> to a <see cref="T:dnlib.DotNet.TypeDef"/>, possibly resolving
            a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if we couldn't resolve the
            <see cref="T:dnlib.DotNet.TypeRef"/> or if <paramref name="type"/> is a type spec</returns>
        </member>
        <member name="T:dnlib.DotNet.DeclSecurity">
            <summary>
            A high-level representation of a row in the DeclSecurity table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.DeclSecurity.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.DeclSecurity.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.DeclSecurity.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.DeclSecurity.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.DeclSecurity.Action">
            <summary>
            From column DeclSecurity.Action
            </summary>
        </member>
        <member name="F:dnlib.DotNet.DeclSecurity.action">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.DeclSecurity.SecurityAttributes">
            <summary>
            From column DeclSecurity.PermissionSet
            </summary>
        </member>
        <member name="F:dnlib.DotNet.DeclSecurity.securityAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurity.InitializeSecurityAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.DeclSecurity.securityAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.DeclSecurity.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.DeclSecurity.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurity.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.DeclSecurity.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.DeclSecurity.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.DeclSecurity.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.DeclSecurity.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.DeclSecurity.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.DeclSecurity.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurity.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.DeclSecurity.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.DeclSecurity.HasSecurityAttributes">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.DeclSecurity.SecurityAttributes"/> is not empty
            </summary>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurity.GetBlob">
            <summary>
            Gets the blob data or <c>null</c> if there's none
            </summary>
            <returns>Blob data or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurity.GetNet1xXmlString">
            <summary>
            Returns the .NET 1.x XML string or null if it's not a .NET 1.x format
            </summary>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.DeclSecurityUser">
            <summary>
            A DeclSecurity row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityUser.#ctor(dnlib.DotNet.SecurityAction,System.Collections.Generic.IList{dnlib.DotNet.SecurityAttribute})">
            <summary>
            Constructor
            </summary>
            <param name="action">The security action</param>
            <param name="securityAttrs">The security attributes (now owned by this)</param>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityUser.GetBlob">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.DeclSecurityMD">
            <summary>
            Created from a row in the DeclSecurity table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.DeclSecurityMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.DeclSecurityMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityMD.InitializeSecurityAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>DeclSecurity</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityMD.GetBlob">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.DeclSecurityReader">
            <summary>
            Reads <c>DeclSecurity</c> blobs
            </summary>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityReader.Read(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Reads a <c>DeclSecurity</c> blob
            </summary>
            <param name="module">Module that will own the returned list</param>
            <param name="sig"><c>#Blob</c> offset of <c>DeclSecurity</c> signature</param>
            <returns>A list of <see cref="T:dnlib.DotNet.SecurityAttribute"/>s</returns>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityReader.Read(dnlib.DotNet.ModuleDefMD,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <c>DeclSecurity</c> blob
            </summary>
            <param name="module">Module that will own the returned list</param>
            <param name="sig"><c>#Blob</c> offset of <c>DeclSecurity</c> signature</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A list of <see cref="T:dnlib.DotNet.SecurityAttribute"/>s</returns>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityReader.Read(dnlib.DotNet.ModuleDef,System.Byte[])">
            <summary>
            Reads a <c>DeclSecurity</c> blob
            </summary>
            <param name="module">Module that will own the returned list</param>
            <param name="blob"><c>DeclSecurity</c> blob</param>
            <returns>A list of <see cref="T:dnlib.DotNet.SecurityAttribute"/>s</returns>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityReader.Read(dnlib.DotNet.ModuleDef,System.Byte[],dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <c>DeclSecurity</c> blob
            </summary>
            <param name="module">Module that will own the returned list</param>
            <param name="blob"><c>DeclSecurity</c> blob</param>
            <param name="gpContext">Generic parameter context</param>/// 
            <returns>A list of <see cref="T:dnlib.DotNet.SecurityAttribute"/>s</returns>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityReader.Read(dnlib.DotNet.ModuleDef,dnlib.IO.DataReader)">
            <summary>
            Reads a <c>DeclSecurity</c> blob
            </summary>
            <param name="module">Module that will own the returned list</param>
            <param name="signature"><c>DeclSecurity</c> stream that will be owned by us</param>
            <returns>A list of <see cref="T:dnlib.DotNet.SecurityAttribute"/>s</returns>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityReader.Read(dnlib.DotNet.ModuleDef,dnlib.IO.DataReader,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <c>DeclSecurity</c> blob
            </summary>
            <param name="module">Module that will own the returned list</param>
            <param name="signature"><c>DeclSecurity</c> stream that will be owned by us</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A list of <see cref="T:dnlib.DotNet.SecurityAttribute"/>s</returns>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityReader.ReadBinaryFormat">
            <summary>
            Reads the new (.NET 2.0+) DeclSecurity blob format
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.DeclSecurityReader.ReadXmlFormat">
            <summary>
            Reads the old (.NET 1.x) DeclSecurity blob format
            </summary>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.ElementType">
            <summary>
            See CorHdr.h/CorElementType
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.End">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.ElementType.Void">
            <summary>System.Void</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.Boolean">
            <summary>System.Boolean</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.Char">
            <summary>System.Char</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.I1">
            <summary>System.SByte</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.U1">
            <summary>System.Byte</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.I2">
            <summary>System.Int16</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.U2">
            <summary>System.UInt16</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.I4">
            <summary>System.Int32</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.U4">
            <summary>System.UInt32</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.I8">
            <summary>System.Int64</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.U8">
            <summary>System.UInt64</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.R4">
            <summary>System.Single</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.R8">
            <summary>System.Double</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.String">
            <summary>System.String</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.Ptr">
            <summary>Pointer type (*)</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.ByRef">
            <summary>ByRef type (&amp;)</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.ValueType">
            <summary>Value type</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.Class">
            <summary>Reference type</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.Var">
            <summary>Type generic parameter</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.Array">
            <summary>Multidimensional array ([*], [,], [,,], ...)</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.GenericInst">
            <summary>Generic instance type</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.TypedByRef">
            <summary>Typed byref</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.ValueArray">
            <summary>Value array (don't use)</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.I">
            <summary>System.IntPtr</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.U">
            <summary>System.UIntPtr</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.R">
            <summary>native real (don't use)</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.FnPtr">
            <summary>Function pointer</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.Object">
            <summary>System.Object</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.SZArray">
            <summary>Single-dimension, zero lower bound array ([])</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.MVar">
            <summary>Method generic parameter</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.CModReqd">
            <summary>Required C modifier</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.CModOpt">
            <summary>Optional C modifier</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.Internal">
            <summary>Used internally by the CLR (don't use)</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.Module">
            <summary>Module (don't use)</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.Sentinel">
            <summary>Sentinel (method sigs only)</summary>
        </member>
        <member name="F:dnlib.DotNet.ElementType.Pinned">
            <summary>Pinned type (locals only)</summary>
        </member>
        <member name="T:dnlib.DotNet.Emit.Code">
            <summary>
            A CIL opcode. If the high byte is 0 or if it's <see cref="F:dnlib.DotNet.Emit.Code.UNKNOWN1"/>, it's a 1-byte opcode,
            else it's a two-byte opcode and the highest byte is the first byte of the opcode.
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Emit.Extensions">
            <summary>
            Extension methods
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Extensions.ToOpCode(dnlib.DotNet.Emit.Code)">
            <summary>
            Converts a <see cref="T:dnlib.DotNet.Emit.Code"/> to an <see cref="T:dnlib.DotNet.Emit.OpCode"/>
            </summary>
            <param name="code">The code</param>
            <returns>A <see cref="T:dnlib.DotNet.Emit.OpCode"/> or <c>null</c> if it's invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Extensions.GetOpCode(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Gets the opcode or <see cref="F:dnlib.DotNet.Emit.OpCodes.UNKNOWN1"/> if <paramref name="self"/> is <c>null</c>
            </summary>
            <param name="self">this</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Extensions.GetOperand(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Gets the operand or <c>null</c> if <paramref name="self"/> is <c>null</c>
            </summary>
            <param name="self">this</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Extensions.GetOffset(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Gets the offset or 0 if <paramref name="self"/> is <c>null</c>
            </summary>
            <param name="self">this</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Extensions.GetSequencePoint(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Gets the sequence point or <c>null</c> if <paramref name="self"/> is <c>null</c>
            </summary>
            <param name="self">this</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Extensions.ResolveToken(dnlib.DotNet.Emit.IInstructionOperandResolver,System.UInt32)">
            <summary>
            Resolves a token
            </summary>
            <param name="self">An <see cref="T:dnlib.DotNet.Emit.IInstructionOperandResolver"/> object</param>
            <param name="token">The metadata token</param>
            <returns>A <see cref="T:dnlib.DotNet.IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
        </member>
        <member name="T:dnlib.DotNet.Emit.DynamicMethodBodyReader">
            <summary>
            Reads code from a DynamicMethod
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.DynamicMethodBodyReader.#ctor(dnlib.DotNet.ModuleDef,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="module">Module that will own the method body</param>
            <param name="obj">This can be one of several supported types: the delegate instance
            created by DynamicMethod.CreateDelegate(), a DynamicMethod instance, a RTDynamicMethod
            instance or a DynamicResolver instance.</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.DynamicMethodBodyReader.#ctor(dnlib.DotNet.ModuleDef,System.Object,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="module">Module that will own the method body</param>
            <param name="obj">This can be one of several supported types: the delegate instance
            created by DynamicMethod.CreateDelegate(), a DynamicMethod instance, a RTDynamicMethod
            instance or a DynamicResolver instance.</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.DynamicMethodBodyReader.#ctor(dnlib.DotNet.ModuleDef,System.Object,dnlib.DotNet.Importer)">
            <summary>
            Constructor
            </summary>
            <param name="module">Module that will own the method body</param>
            <param name="obj">This can be one of several supported types: the delegate instance
            created by DynamicMethod.CreateDelegate(), a DynamicMethod instance, a RTDynamicMethod
            instance or a DynamicResolver instance.</param>
            <param name="importer">Importer</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.DynamicMethodBodyReader.Read">
            <summary>
            Reads the code
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.DynamicMethodBodyReader.GetMethod">
            <summary>
            Returns the created method. Must be called after <see cref="M:dnlib.DotNet.Emit.DynamicMethodBodyReader.Read"/>.
            </summary>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.CilBody"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.DynamicMethodBodyReader.ReadInlineField(dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.DynamicMethodBodyReader.ReadInlineMethod(dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.DynamicMethodBodyReader.ReadInlineSig(dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.DynamicMethodBodyReader.ReadInlineString(dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.DynamicMethodBodyReader.ReadInlineTok(dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.DynamicMethodBodyReader.ReadInlineType(dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Emit.ExceptionHandler">
            <summary>
            A CIL method exception handler
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.ExceptionHandler.TryStart">
            <summary>
            First instruction of try block
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.ExceptionHandler.TryEnd">
            <summary>
            One instruction past the end of try block or <c>null</c> if it ends at the end
            of the method.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.ExceptionHandler.FilterStart">
            <summary>
            Start of filter handler or <c>null</c> if none. The end of filter handler is
            always <see cref="F:dnlib.DotNet.Emit.ExceptionHandler.HandlerStart"/>.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.ExceptionHandler.HandlerStart">
            <summary>
            First instruction of try handler block
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.ExceptionHandler.HandlerEnd">
            <summary>
            One instruction past the end of try handler block or <c>null</c> if it ends at the end
            of the method.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.ExceptionHandler.CatchType">
            <summary>
            The catch type if <see cref="F:dnlib.DotNet.Emit.ExceptionHandler.HandlerType"/> is <see cref="F:dnlib.DotNet.Emit.ExceptionHandlerType.Catch"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.ExceptionHandler.HandlerType">
            <summary>
            Type of exception handler clause
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.ExceptionHandler.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.ExceptionHandler.#ctor(dnlib.DotNet.Emit.ExceptionHandlerType)">
            <summary>
            Constructor
            </summary>
            <param name="handlerType">Exception clause type</param>
        </member>
        <member name="T:dnlib.DotNet.Emit.ExceptionHandlerType">
            <summary>
            Type of exception handler. See CorHdr.h/CorExceptionFlag
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.ExceptionHandlerType.Catch">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.ExceptionHandlerType.Filter">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.ExceptionHandlerType.Finally">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.ExceptionHandlerType.Fault">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.ExceptionHandlerType.Duplicated">
            <summary/>
        </member>
        <member name="T:dnlib.DotNet.Emit.FlowControl">
            <summary>
            CIL opcode flow control
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.FlowControl.Branch">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.FlowControl.Break">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.FlowControl.Call">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.FlowControl.Cond_Branch">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.FlowControl.Meta">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.FlowControl.Next">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.FlowControl.Phi">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.FlowControl.Return">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.FlowControl.Throw">
            <summary/>
        </member>
        <member name="T:dnlib.DotNet.Emit.Instruction">
            <summary>
            A CIL instruction (opcode + operand)
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.Instruction.OpCode">
            <summary>
            The opcode
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.Instruction.Operand">
            <summary>
            The opcode operand
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.Instruction.Offset">
            <summary>
            Offset of the instruction in the method body
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.Instruction.SequencePoint">
            <summary>
            PDB sequence point or <c>null</c> if none
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.#ctor(dnlib.DotNet.Emit.OpCode)">
            <summary>
            Constructor
            </summary>
            <param name="opCode">Opcode</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.#ctor(dnlib.DotNet.Emit.OpCode,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="opCode">Opcode</param>
            <param name="operand">The operand</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode)">
            <summary>
            Creates a new instruction with no operand
            </summary>
            <param name="opCode">The opcode</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,System.Byte)">
            <summary>
            Creates a new instruction with a <see cref="T:System.Byte"/> operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="value">The value</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,System.SByte)">
            <summary>
            Creates a new instruction with a <see cref="T:System.SByte"/> operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="value">The value</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,System.Int32)">
            <summary>
            Creates a new instruction with an <see cref="T:System.Int32"/> operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="value">The value</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,System.Int64)">
            <summary>
            Creates a new instruction with a <see cref="T:System.Int64"/> operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="value">The value</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,System.Single)">
            <summary>
            Creates a new instruction with a <see cref="T:System.Single"/> operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="value">The value</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,System.Double)">
            <summary>
            Creates a new instruction with a <see cref="T:System.Double"/> operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="value">The value</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,System.String)">
            <summary>
            Creates a new instruction with a string operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="s">The string</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Creates a new instruction with an instruction target operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="target">Target instruction</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,System.Collections.Generic.IList{dnlib.DotNet.Emit.Instruction})">
            <summary>
            Creates a new instruction with an instruction target list operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="targets">The targets</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Creates a new instruction with a type operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="type">The type</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,dnlib.DotNet.CorLibTypeSig)">
            <summary>
            Creates a new instruction with a type operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="type">The type</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,dnlib.DotNet.MemberRef)">
            <summary>
            Creates a new instruction with a method/field operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="mr">The method/field</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,dnlib.DotNet.IField)">
            <summary>
            Creates a new instruction with a field operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="field">The field</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,dnlib.DotNet.IMethod)">
            <summary>
            Creates a new instruction with a method operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="method">The method</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,dnlib.DotNet.ITokenOperand)">
            <summary>
            Creates a new instruction with a token operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="token">The token</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,dnlib.DotNet.MethodSig)">
            <summary>
            Creates a new instruction with a method signature operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="methodSig">The method signature</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,dnlib.DotNet.Parameter)">
            <summary>
            Creates a new instruction with a method parameter operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="parameter">The method parameter</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Create(dnlib.DotNet.Emit.OpCode,dnlib.DotNet.Emit.Local)">
            <summary>
            Creates a new instruction with a method local operand
            </summary>
            <param name="opCode">The opcode</param>
            <param name="local">The method local</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.CreateLdcI4(System.Int32)">
            <summary>
            Creates a <c>ldci4</c> instruction
            </summary>
            <param name="value">Operand value</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.GetSize">
            <summary>
            Gets the size in bytes of the instruction
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.UpdateStack(System.Int32@)">
            <summary>
            Updates <paramref name="stack"/> with the new stack size
            </summary>
            <param name="stack">Current stack size</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.UpdateStack(System.Int32@,System.Boolean)">
            <summary>
            Updates <paramref name="stack"/> with the new stack size
            </summary>
            <param name="stack">Current stack size</param>
            <param name="methodHasReturnValue"><c>true</c> if the method has a return value,
            <c>false</c> otherwise</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.CalculateStackUsage(System.Int32@,System.Int32@)">
            <summary>
            Calculates stack usage
            </summary>
            <param name="pushes">Updated with number of stack pushes</param>
            <param name="pops">Updated with number of stack pops or <c>-1</c> if the stack should
            be cleared.</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.CalculateStackUsage(System.Boolean,System.Int32@,System.Int32@)">
            <summary>
            Calculates stack usage
            </summary>
            <param name="methodHasReturnValue"><c>true</c> if method has a return value</param>
            <param name="pushes">Updated with number of stack pushes</param>
            <param name="pops">Updated with number of stack pops or <c>-1</c> if the stack should
            be cleared.</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.IsLeave">
            <summary>
            Checks whether it's one of the <c>leave</c> instructions
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.IsBr">
            <summary>
            Checks whether it's one of the <c>br</c> instructions
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.IsBrfalse">
            <summary>
            Checks whether it's one of the <c>brfalse</c> instructions
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.IsBrtrue">
            <summary>
            Checks whether it's one of the <c>brtrue</c> instructions
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.IsConditionalBranch">
            <summary>
            Checks whether it's one of the conditional branch instructions (bcc, brtrue, brfalse)
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.IsLdcI4">
            <summary>
            Checks whether this is one of the <c>ldc.i4</c> instructions
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.GetLdcI4Value">
            <summary>
            Returns a <c>ldc.i4</c> instruction's operand
            </summary>
            <returns>The integer value</returns>
            <exception cref="T:System.InvalidOperationException"><see cref="F:dnlib.DotNet.Emit.Instruction.OpCode"/> isn't one of the
            <c>ldc.i4</c> opcodes</exception>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.IsLdarg">
            <summary>
            Checks whether it's one of the <c>ldarg</c> instructions, but does <c>not</c> check
            whether it's one of the <c>ldarga</c> instructions.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.IsLdloc">
            <summary>
            Checks whether it's one of the <c>ldloc</c> instructions, but does <c>not</c> check
            whether it's one of the <c>ldloca</c> instructions.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.IsStarg">
            <summary>
            Checks whether it's one of the <c>starg</c> instructions
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.IsStloc">
            <summary>
            Checks whether it's one of the <c>stloc</c> instructions
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.GetLocal(System.Collections.Generic.IList{dnlib.DotNet.Emit.Local})">
            <summary>
            Returns the local if it's a <c>ldloc</c>, <c>stloc</c> or <c>ldloca</c> instruction
            </summary>
            <param name="locals">The locals</param>
            <returns>The local or <c>null</c> if it's not a <c>ldloc</c>, <c>stloc</c> or <c>ldloca</c>
            instruction or if the local doesn't exist.</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.GetParameterIndex">
            <summary>
            Gets the index of the instruction's parameter operand or <c>-1</c> if the parameter
            is missing or if it's not an instruction with a parameter operand.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.GetParameter(System.Collections.Generic.IList{dnlib.DotNet.Parameter})">
            <summary>
            Returns a method parameter
            </summary>
            <param name="parameters">All parameters</param>
            <returns>A parameter or <c>null</c> if it doesn't exist</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.GetArgumentType(dnlib.DotNet.MethodSig,dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns an argument type
            </summary>
            <param name="methodSig">Method signature</param>
            <param name="declaringType">Declaring type (only needed if it's an instance method)</param>
            <returns>The type or <c>null</c> if it doesn't exist</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.Clone">
            <summary>
            Clone this instance. The <see cref="F:dnlib.DotNet.Emit.Instruction.Operand"/> and <see cref="F:dnlib.DotNet.Emit.Instruction.SequencePoint"/> fields
            are shared by this instance and the created instance.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Instruction.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Emit.InstructionPrinter">
            <summary>
            Converts instructions to strings
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.InstructionPrinter.ToString(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Converts an instruction to a string
            </summary>
            <param name="instr">The instruction</param>
            <returns>The result</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.InstructionPrinter.GetOperandString(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Gets the instruction's operand as a string
            </summary>
            <param name="instr">The instruction</param>
            <returns>The operand as a string</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.InstructionPrinter.AddOperandString(System.Text.StringBuilder,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Add an instruction's operand to <paramref name="sb"/>
            </summary>
            <param name="sb">Place result here</param>
            <param name="instr">The instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.InstructionPrinter.AddOperandString(System.Text.StringBuilder,dnlib.DotNet.Emit.Instruction,System.String)">
            <summary>
            Add an instruction's operand to <paramref name="sb"/>
            </summary>
            <param name="sb">Place result here</param>
            <param name="instr">The instruction</param>
            <param name="extra">A string that will be added before the operand, if there's
            an operand.</param>
        </member>
        <member name="T:dnlib.DotNet.Emit.InvalidMethodException">
            <summary>
            Thrown when invalid data is detected while parsing a .NET method
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.InvalidMethodException.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.InvalidMethodException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="msg">Error message</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.InvalidMethodException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="msg">Error message</param>
            <param name="innerException">The inner exception or <c>null</c> if none</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.InvalidMethodException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:dnlib.DotNet.Emit.LocalList">
            <summary>
            A collection of <see cref="T:dnlib.DotNet.Emit.Local"/>s
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.LocalList.Count">
            <summary>
            Gets the number of locals
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.LocalList.Locals">
            <summary>
            Gets the list of locals
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.LocalList.Item(System.Int32)">
            <summary>
            Gets the N'th local
            </summary>
            <param name="index">The local index</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.#ctor(System.Collections.Generic.IList{dnlib.DotNet.Emit.Local})">
            <summary>
            Constructor
            </summary>
            <param name="locals">All locals that will be owned by this instance</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.Add(dnlib.DotNet.Emit.Local)">
            <summary>
            Adds a new local and then returns it
            </summary>
            <param name="local">The local that should be added to the list</param>
            <returns>The input is always returned</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.dnlib#Utils#IListListener{dnlib#DotNet#Emit#Local}#OnLazyAdd(System.Int32,dnlib.DotNet.Emit.Local@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.dnlib#Utils#IListListener{dnlib#DotNet#Emit#Local}#OnAdd(System.Int32,dnlib.DotNet.Emit.Local)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.dnlib#Utils#IListListener{dnlib#DotNet#Emit#Local}#OnRemove(System.Int32,dnlib.DotNet.Emit.Local)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.dnlib#Utils#IListListener{dnlib#DotNet#Emit#Local}#OnResize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.dnlib#Utils#IListListener{dnlib#DotNet#Emit#Local}#OnClear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.IndexOf(dnlib.DotNet.Emit.Local)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.Insert(System.Int32,dnlib.DotNet.Emit.Local)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.Clear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.Contains(dnlib.DotNet.Emit.Local)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.CopyTo(dnlib.DotNet.Emit.Local[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Emit.LocalList.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.Remove(dnlib.DotNet.Emit.Local)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.LocalList.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Emit.Local">
            <summary>
            A method local
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.Local.Type">
            <summary>
            Gets/sets the type of the local
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.Local.Index">
            <summary>
            Local index
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.Local.Name">
            <summary>
            Gets the name. This property is obsolete, use <see cref="T:dnlib.DotNet.Pdb.PdbLocal"/> to get/set the name stored in the PDB file.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.Local.Attributes">
            <summary>
            Gets the attributes. This property is obsolete, use <see cref="T:dnlib.DotNet.Pdb.PdbLocal"/> to get/set the attributes stored in the PDB file.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.Local.#ctor(dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="typeSig">The type</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.Local.#ctor(dnlib.DotNet.TypeSig,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="typeSig">The type</param>
            <param name="name">Name of local</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.Local.#ctor(dnlib.DotNet.TypeSig,System.String,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="typeSig">The type</param>
            <param name="name">Name of local</param>
            <param name="index">Index, should only be used if you don't add it to the locals list</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.Local.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Emit.MethodBody">
            <summary>
            Method body base class
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Emit.NativeMethodBody">
            <summary>
            A native method body
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.NativeMethodBody.RVA">
            <summary>
            Gets/sets the RVA of the native method body
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.NativeMethodBody.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.NativeMethodBody.#ctor(dnlib.PE.RVA)">
            <summary>
            Constructor
            </summary>
            <param name="rva">RVA of method body</param>
        </member>
        <member name="T:dnlib.DotNet.Emit.CilBody">
            <summary>
            CIL (managed code) body
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.CilBody.SMALL_HEADER_SIZE">
            <summary>
            Size of a small header
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.KeepOldMaxStack">
            <summary>
            Gets/sets a flag indicating whether the original max stack value should be used.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.InitLocals">
            <summary>
            Gets/sets the init locals flag. This is only valid if the method has any locals.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.HeaderSize">
            <summary>
            Gets/sets the size in bytes of the method body header. The instructions immediately follow
            the header.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.IsSmallHeader">
            <summary>
            <c>true</c> if it was a small body header (<see cref="P:dnlib.DotNet.Emit.CilBody.HeaderSize"/> is <c>1</c>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.IsBigHeader">
            <summary>
            <c>true</c> if it was a big body header
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.MaxStack">
            <summary>
            Gets/sets max stack value from the fat method header.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.LocalVarSigTok">
            <summary>
            Gets/sets the locals metadata token
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.HasInstructions">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.Emit.CilBody.Instructions"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.Instructions">
            <summary>
            Gets the instructions
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.HasExceptionHandlers">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.Emit.CilBody.ExceptionHandlers"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.ExceptionHandlers">
            <summary>
            Gets the exception handlers
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.HasVariables">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.Emit.CilBody.Variables"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.Variables">
            <summary>
            Gets the locals
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.PdbMethod">
            <summary>
            Gets/sets the PDB method. This is <c>null</c> if no PDB has been loaded or if there's
            no PDB info for this method.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.HasPdbMethod">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.Emit.CilBody.PdbMethod"/> is not <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.CilBody.MetadataBodySize">
            <summary>
            Gets the total size of the body in the PE file, including header, IL bytes, and exception handlers.
            This property returns 0 if the size is unknown.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.CilBody.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.CilBody.#ctor(System.Boolean,System.Collections.Generic.IList{dnlib.DotNet.Emit.Instruction},System.Collections.Generic.IList{dnlib.DotNet.Emit.ExceptionHandler},System.Collections.Generic.IList{dnlib.DotNet.Emit.Local})">
            <summary>
            Constructor
            </summary>
            <param name="initLocals">Init locals flag</param>
            <param name="instructions">All instructions. This instance will own the list.</param>
            <param name="exceptionHandlers">All exception handlers. This instance will own the list.</param>
            <param name="locals">All locals. This instance will own the locals in the list.</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.CilBody.SimplifyMacros(System.Collections.Generic.IList{dnlib.DotNet.Parameter})">
            <summary>
            Shorter instructions are converted to the longer form, eg. <c>Ldc_I4_1</c> is
            converted to <c>Ldc_I4</c> with a <c>1</c> as the operand.
            </summary>
            <param name="parameters">All method parameters, including the hidden 'this' parameter
            if it's an instance method. Use <see cref="P:dnlib.DotNet.MethodDef.Parameters"/>.</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.CilBody.OptimizeMacros">
            <summary>
            Optimizes instructions by using the shorter form if possible. Eg. <c>Ldc_I4</c> <c>1</c>
            will be replaced with <c>Ldc_I4_1</c>.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.CilBody.SimplifyBranches">
            <summary>
            Short branch instructions are converted to the long form, eg. <c>Beq_S</c> is
            converted to <c>Beq</c>.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.CilBody.OptimizeBranches">
            <summary>
            Optimizes branches by using the smallest possible branch
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.CilBody.UpdateInstructionOffsets">
            <summary>
            Updates each instruction's offset
            </summary>
            <returns>Total size in bytes of all instructions</returns>
        </member>
        <member name="T:dnlib.DotNet.Emit.IStringResolver">
            <summary>
            Reads strings from #US heap
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.IStringResolver.ReadUserString(System.UInt32)">
            <summary>
            Reads a string from the #US heap
            </summary>
            <param name="token">String token</param>
            <returns>A string</returns>
        </member>
        <member name="T:dnlib.DotNet.Emit.IInstructionOperandResolver">
            <summary>
            Resolves instruction operands
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Emit.MethodBodyReader">
            <summary>
            Reads a .NET method body (header, locals, instructions, exception handlers)
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.CreateCilBody(dnlib.DotNet.Emit.IInstructionOperandResolver,dnlib.IO.DataReader,dnlib.DotNet.MethodDef)">
            <summary>
            Creates a CIL method body or returns an empty one if <paramref name="reader"/> doesn't
            point to the start of a valid CIL method body.
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="reader">A reader positioned at the start of a .NET method body</param>
            <param name="method">Use parameters from this method</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.CreateCilBody(dnlib.DotNet.Emit.IInstructionOperandResolver,dnlib.IO.DataReader,dnlib.DotNet.MethodDef,dnlib.DotNet.GenericParamContext)">
            <summary>
            Creates a CIL method body or returns an empty one if <paramref name="reader"/> doesn't
            point to the start of a valid CIL method body.
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="reader">A reader positioned at the start of a .NET method body</param>
            <param name="method">Use parameters from this method</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.CreateCilBody(dnlib.DotNet.Emit.IInstructionOperandResolver,dnlib.IO.DataReader,System.Collections.Generic.IList{dnlib.DotNet.Parameter})">
            <summary>
            Creates a CIL method body or returns an empty one if <paramref name="reader"/> doesn't
            point to the start of a valid CIL method body.
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="reader">A reader positioned at the start of a .NET method body</param>
            <param name="parameters">Method parameters</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.CreateCilBody(dnlib.DotNet.Emit.IInstructionOperandResolver,dnlib.IO.DataReader,System.Collections.Generic.IList{dnlib.DotNet.Parameter},dnlib.DotNet.GenericParamContext)">
            <summary>
            Creates a CIL method body or returns an empty one if <paramref name="reader"/> doesn't
            point to the start of a valid CIL method body.
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="reader">A reader positioned at the start of a .NET method body</param>
            <param name="parameters">Method parameters</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.CreateCilBody(dnlib.DotNet.Emit.IInstructionOperandResolver,System.Byte[],System.Byte[],System.Collections.Generic.IList{dnlib.DotNet.Parameter})">
            <summary>
            Creates a CIL method body or returns an empty one if <paramref name="code"/> is not
            a valid CIL method body.
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="code">All code</param>
            <param name="exceptions">Exceptions or <c>null</c> if all exception handlers are in
            <paramref name="code"/></param>
            <param name="parameters">Method parameters</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.CreateCilBody(dnlib.DotNet.Emit.IInstructionOperandResolver,System.Byte[],System.Byte[],System.Collections.Generic.IList{dnlib.DotNet.Parameter},dnlib.DotNet.GenericParamContext)">
            <summary>
            Creates a CIL method body or returns an empty one if <paramref name="code"/> is not
            a valid CIL method body.
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="code">All code</param>
            <param name="exceptions">Exceptions or <c>null</c> if all exception handlers are in
            <paramref name="code"/></param>
            <param name="parameters">Method parameters</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.CreateCilBody(dnlib.DotNet.Emit.IInstructionOperandResolver,dnlib.IO.DataReader,System.Nullable{dnlib.IO.DataReader},System.Collections.Generic.IList{dnlib.DotNet.Parameter})">
            <summary>
            Creates a CIL method body or returns an empty one if <paramref name="codeReader"/> doesn't
            point to the start of a valid CIL method body.
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="codeReader">A reader positioned at the start of a .NET method body</param>
            <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
            present or if <paramref name="codeReader"/> contains the exception handlers</param>
            <param name="parameters">Method parameters</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.CreateCilBody(dnlib.DotNet.Emit.IInstructionOperandResolver,dnlib.IO.DataReader,System.Nullable{dnlib.IO.DataReader},System.Collections.Generic.IList{dnlib.DotNet.Parameter},dnlib.DotNet.GenericParamContext)">
            <summary>
            Creates a CIL method body or returns an empty one if <paramref name="codeReader"/> doesn't
            point to the start of a valid CIL method body.
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="codeReader">A reader positioned at the start of a .NET method body</param>
            <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
            present or if <paramref name="codeReader"/> contains the exception handlers</param>
            <param name="parameters">Method parameters</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.CreateCilBody(dnlib.DotNet.Emit.IInstructionOperandResolver,System.Byte[],System.Byte[],System.Collections.Generic.IList{dnlib.DotNet.Parameter},System.UInt16,System.UInt16,System.UInt32,System.UInt32)">
            <summary>
            Creates a CIL method body or returns an empty one if <paramref name="code"/> is not
            a valid CIL method body.
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="code">All code</param>
            <param name="exceptions">Exceptions or <c>null</c> if all exception handlers are in
            <paramref name="code"/></param>
            <param name="parameters">Method parameters</param>
            <param name="flags">Method header flags, eg. 2 if tiny method</param>
            <param name="maxStack">Max stack</param>
            <param name="codeSize">Code size</param>
            <param name="localVarSigTok">Local variable signature token or 0 if none</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.CreateCilBody(dnlib.DotNet.Emit.IInstructionOperandResolver,System.Byte[],System.Byte[],System.Collections.Generic.IList{dnlib.DotNet.Parameter},System.UInt16,System.UInt16,System.UInt32,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Creates a CIL method body or returns an empty one if <paramref name="code"/> is not
            a valid CIL method body.
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="code">All code</param>
            <param name="exceptions">Exceptions or <c>null</c> if all exception handlers are in
            <paramref name="code"/></param>
            <param name="parameters">Method parameters</param>
            <param name="flags">Method header flags, eg. 2 if tiny method</param>
            <param name="maxStack">Max stack</param>
            <param name="codeSize">Code size</param>
            <param name="localVarSigTok">Local variable signature token or 0 if none</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.#ctor(dnlib.DotNet.Emit.IInstructionOperandResolver,dnlib.IO.DataReader,dnlib.DotNet.MethodDef)">
            <summary>
            Constructor
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="reader">A reader positioned at the start of a .NET method body</param>
            <param name="method">Use parameters from this method</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.#ctor(dnlib.DotNet.Emit.IInstructionOperandResolver,dnlib.IO.DataReader,dnlib.DotNet.MethodDef,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="reader">A reader positioned at the start of a .NET method body</param>
            <param name="method">Use parameters from this method</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.#ctor(dnlib.DotNet.Emit.IInstructionOperandResolver,dnlib.IO.DataReader,System.Collections.Generic.IList{dnlib.DotNet.Parameter})">
            <summary>
            Constructor
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="reader">A reader positioned at the start of a .NET method body</param>
            <param name="parameters">Method parameters</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.#ctor(dnlib.DotNet.Emit.IInstructionOperandResolver,dnlib.IO.DataReader,System.Collections.Generic.IList{dnlib.DotNet.Parameter},dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="reader">A reader positioned at the start of a .NET method body</param>
            <param name="parameters">Method parameters</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.#ctor(dnlib.DotNet.Emit.IInstructionOperandResolver,dnlib.IO.DataReader,System.Nullable{dnlib.IO.DataReader},System.Collections.Generic.IList{dnlib.DotNet.Parameter})">
            <summary>
            Constructor
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="codeReader">A reader positioned at the start of a .NET method body</param>
            <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
            present or if <paramref name="codeReader"/> contains the exception handlers</param>
            <param name="parameters">Method parameters</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.#ctor(dnlib.DotNet.Emit.IInstructionOperandResolver,dnlib.IO.DataReader,System.Nullable{dnlib.IO.DataReader},System.Collections.Generic.IList{dnlib.DotNet.Parameter},dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="opResolver">The operand resolver</param>
            <param name="codeReader">A reader positioned at the start of a .NET method body</param>
            <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
            present or if <paramref name="codeReader"/> contains the exception handlers</param>
            <param name="parameters">Method parameters</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.SetHeader(System.UInt16,System.UInt16,System.UInt32,System.UInt32)">
            <summary>
            Initializes the method header
            </summary>
            <param name="flags">Header flags, eg. 2 if it's a tiny method</param>
            <param name="maxStack">Max stack</param>
            <param name="codeSize">Code size</param>
            <param name="localVarSigTok">Local variable signature token</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.Read">
            <summary>
            Reads the method body header, locals, all instructions, and the exception handlers (if any)
            </summary>
            <returns><c>true</c> if it worked, and <c>false</c> if something failed</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.ReadHeader">
            <summary>
            Reads the method header
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.ReadLocals">
            <summary>
            Reads the locals
            </summary>
            <returns>All locals or <c>null</c> if there are none</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.ReadInstructions">
            <summary>
            Reads all instructions
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.ReadInlineField(dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.ReadInlineMethod(dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.ReadInlineSig(dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.ReadInlineString(dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.ReadInlineTok(dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.ReadInlineType(dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.ReadExceptionHandlers(System.UInt32@)">
            <summary>
            Reads all exception handlers
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReader.CreateCilBody">
            <summary>
            Creates a CIL body. Must be called after <see cref="M:dnlib.DotNet.Emit.MethodBodyReader.Read"/>, and can only be
            called once.
            </summary>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.CilBody"/> instance</returns>
        </member>
        <member name="T:dnlib.DotNet.Emit.MethodBodyReaderBase">
            <summary>
            Method body reader base class
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.MethodBodyReaderBase.reader">
            <summary>The method reader</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.MethodBodyReaderBase.parameters">
            <summary>All parameters</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.MethodBodyReaderBase.locals">
            <summary>All locals</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.MethodBodyReaderBase.instructions">
            <summary>All instructions</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.MethodBodyReaderBase.exceptionHandlers">
            <summary>All exception handlers</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.MethodBodyReaderBase.codeEndOffs">
            <summary>First byte after the end of the code</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.MethodBodyReaderBase.codeStartOffs">
            <summary>Start offset of method</summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.MethodBodyReaderBase.Parameters">
            <summary>
            Gets all parameters
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.MethodBodyReaderBase.Locals">
            <summary>
            Gets all locals
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.MethodBodyReaderBase.Instructions">
            <summary>
            Gets all instructions
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.MethodBodyReaderBase.ExceptionHandlers">
            <summary>
            Gets all exception handlers
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.#ctor(dnlib.IO.DataReader)">
            <summary>
            Constructor
            </summary>
            <param name="reader">The reader</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.#ctor(dnlib.IO.DataReader,System.Collections.Generic.IList{dnlib.DotNet.Parameter})">
            <summary>
            Constructor
            </summary>
            <param name="reader">The reader</param>
            <param name="parameters">Method parameters or <c>null</c> if they're not known yet</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.SetLocals(System.Collections.Generic.IList{dnlib.DotNet.TypeSig})">
            <summary>
            Sets new locals
            </summary>
            <param name="newLocals">A list of types of all locals or <c>null</c> if none</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.SetLocals(System.Collections.Generic.IList{dnlib.DotNet.Emit.Local})">
            <summary>
            Sets new locals
            </summary>
            <param name="newLocals">A list of types of all locals or <c>null</c> if none</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInstructions(System.Int32)">
            <summary>
            Reads all instructions
            </summary>
            <param name="numInstrs">Number of instructions to read</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInstructionsNumBytes(System.UInt32)">
            <summary>
            Reads all instructions
            </summary>
            <param name="codeSize">Size of code</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.FixBranches">
            <summary>
            Fixes all branch instructions so their operands are set to an <see cref="T:dnlib.DotNet.Emit.Instruction"/>
            instead of an offset.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.GetInstruction(System.UInt32)">
            <summary>
            Finds an instruction
            </summary>
            <param name="offset">Offset of instruction</param>
            <returns>The instruction or <c>null</c> if there's no instruction at <paramref name="offset"/>.</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.GetInstructionThrow(System.UInt32)">
            <summary>
            Finds an instruction and throws if it's not present
            </summary>
            <param name="offset">Offset of instruction</param>
            <returns>The instruction</returns>
            <exception cref="T:System.InvalidOperationException">There's no instruction at
            <paramref name="offset"/></exception>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadOneInstruction">
            <summary>
            Reads the next instruction
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadOpCode">
            <summary>
            Reads the next OpCode from the current position
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadOperand(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads the instruction operand (if any)
            </summary>
            <param name="instr">The instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineBrTarget(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineBrTarget"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineField(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineField"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineI(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineI"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineI8(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineI8"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineMethod(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineMethod"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineNone(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineNone"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlinePhi(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlinePhi"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineR(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineR"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineSig(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineSig"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineString(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineString"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineSwitch(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineSwitch"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineTok(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineTok"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineType(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineType"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineVar(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineVar"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineVarArg(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineVar"/> (a parameter) operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadInlineVarLocal(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.InlineVar"/> (a local) operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadShortInlineBrTarget(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.ShortInlineBrTarget"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadShortInlineI(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.ShortInlineI"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadShortInlineR(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.ShortInlineR"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadShortInlineVar(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.ShortInlineVar"/> operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadShortInlineVarArg(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.ShortInlineVar"/> (a parameter) operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.ReadShortInlineVarLocal(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Reads a <see cref="F:dnlib.DotNet.Emit.OperandType.ShortInlineVar"/> (a local) operand
            </summary>
            <param name="instr">The current instruction</param>
            <returns>The operand</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.IsArgOperandInstruction(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Returns <c>true</c> if it's one of the ldarg/starg instructions that have an operand
            </summary>
            <param name="instr">The instruction to check</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.GetParameter(System.Int32)">
            <summary>
            Returns a parameter
            </summary>
            <param name="index">A parameter index</param>
            <returns>A <see cref="T:dnlib.DotNet.Parameter"/> or <c>null</c> if <paramref name="index"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.GetLocal(System.Int32)">
            <summary>
            Returns a local
            </summary>
            <param name="index">A local index</param>
            <returns>A <see cref="T:dnlib.DotNet.Emit.Local"/> or <c>null</c> if <paramref name="index"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.Add(dnlib.DotNet.Emit.ExceptionHandler)">
            <summary>
            Add an exception handler if it appears valid
            </summary>
            <param name="eh">The exception handler</param>
            <returns><c>true</c> if it was added, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.GetOffset(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Gets the offset of an instruction
            </summary>
            <param name="instr">The instruction or <c>null</c> if the offset is the first offset
            at the end of the method.</param>
            <returns>The instruction offset</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodBodyReaderBase.RestoreMethod(dnlib.DotNet.MethodDef)">
            <summary>
            Restores a <see cref="T:dnlib.DotNet.MethodDef"/>'s body with the parsed method instructions
            and exception handlers
            </summary>
            <param name="method">The method that gets updated with the instructions, locals, and
            exception handlers.</param>
        </member>
        <member name="T:dnlib.DotNet.Emit.MethodTableToTypeConverter">
            <summary>
            Converts a type address to a <see cref="T:System.Type"/>. The address can be found in
            <c>RuntimeTypeHandle.Value</c> and it's the same address you use with the WinDbg SOS command
            !dumpmt.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodTableToTypeConverter.Convert(System.IntPtr)">
            <summary>
            Converts <paramref name="address"/> to a <see cref="T:System.Type"/>.
            </summary>
            <param name="address">Address of type</param>
            <returns>The <see cref="T:System.Type"/> or <c>null</c></returns>
        </member>
        <member name="T:dnlib.DotNet.Emit.MethodUtils">
            <summary>
            Instruction utility methods
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodUtils.SimplifyMacros(System.Collections.Generic.IList{dnlib.DotNet.Emit.Instruction},System.Collections.Generic.IList{dnlib.DotNet.Emit.Local},System.Collections.Generic.IList{dnlib.DotNet.Parameter})">
            <summary>
            Shorter instructions are converted to the longer form, eg. <c>Ldc_I4_1</c> is
            converted to <c>Ldc_I4</c> with a <c>1</c> as the operand.
            </summary>
            <param name="instructions">All instructions</param>
            <param name="locals">All locals</param>
            <param name="parameters">All method parameters, including the hidden 'this' parameter
            if it's an instance method. Use <see cref="P:dnlib.DotNet.MethodDef.Parameters"/>.</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodUtils.OptimizeMacros(System.Collections.Generic.IList{dnlib.DotNet.Emit.Instruction})">
            <summary>
            Optimizes instructions by using the shorter form if possible. Eg. <c>Ldc_I4</c> <c>1</c>
            will be replaced with <c>Ldc_I4_1</c>.
            </summary>
            <param name="instructions">All instructions</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodUtils.SimplifyBranches(System.Collections.Generic.IList{dnlib.DotNet.Emit.Instruction})">
            <summary>
            Short branch instructions are converted to the long form, eg. <c>Beq_S</c> is
            converted to <c>Beq</c>.
            </summary>
            <param name="instructions">All instructions</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodUtils.OptimizeBranches(System.Collections.Generic.IList{dnlib.DotNet.Emit.Instruction})">
            <summary>
            Optimizes branches by using the smallest possible branch
            </summary>
            <param name="instructions">All instructions</param>
        </member>
        <member name="M:dnlib.DotNet.Emit.MethodUtils.UpdateInstructionOffsets(System.Collections.Generic.IList{dnlib.DotNet.Emit.Instruction})">
            <summary>
            Updates each instruction's offset
            </summary>
            <param name="instructions">All instructions</param>
            <returns>Total size in bytes of all instructions</returns>
        </member>
        <member name="T:dnlib.DotNet.Emit.OpCode">
            <summary>
            A CIL opcode
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCode.Name">
            <summary>
            The opcode name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCode.Code">
            <summary>
            The opcode as a <see cref="F:dnlib.DotNet.Emit.OpCode.Code"/> enum
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCode.OperandType">
            <summary>
            Operand type
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCode.FlowControl">
            <summary>
            Flow control info
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCode.OpCodeType">
            <summary>
            Opcode type
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCode.StackBehaviourPush">
            <summary>
            Push stack behavior
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCode.StackBehaviourPop">
            <summary>
            Pop stack behavior
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.OpCode.Value">
            <summary>
            Gets the value which is compatible with <see cref="P:System.Reflection.Emit.OpCode.Value"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Emit.OpCode.Size">
            <summary>
            Gets the size of the opcode. It's either 1 or 2 bytes.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction">
            <summary>
            Creates a new instruction with no operand
            </summary>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(System.Byte)">
            <summary>
            Creates a new instruction with a <see cref="T:System.Byte"/> operand
            </summary>
            <param name="value">The value</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(System.SByte)">
            <summary>
            Creates a new instruction with a <see cref="T:System.SByte"/> operand
            </summary>
            <param name="value">The value</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(System.Int32)">
            <summary>
            Creates a new instruction with an <see cref="T:System.Int32"/> operand
            </summary>
            <param name="value">The value</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(System.Int64)">
            <summary>
            Creates a new instruction with a <see cref="T:System.Int64"/> operand
            </summary>
            <param name="value">The value</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(System.Single)">
            <summary>
            Creates a new instruction with a <see cref="T:System.Single"/> operand
            </summary>
            <param name="value">The value</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(System.Double)">
            <summary>
            Creates a new instruction with a <see cref="T:System.Double"/> operand
            </summary>
            <param name="value">The value</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(System.String)">
            <summary>
            Creates a new instruction with a string operand
            </summary>
            <param name="s">The string</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Creates a new instruction with an instruction target operand
            </summary>
            <param name="target">Target instruction</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(System.Collections.Generic.IList{dnlib.DotNet.Emit.Instruction})">
            <summary>
            Creates a new instruction with an instruction target list operand
            </summary>
            <param name="targets">The targets</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Creates a new instruction with a type operand
            </summary>
            <param name="type">The type</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(dnlib.DotNet.CorLibTypeSig)">
            <summary>
            Creates a new instruction with a type operand
            </summary>
            <param name="type">The type</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(dnlib.DotNet.MemberRef)">
            <summary>
            Creates a new instruction with a method/field operand
            </summary>
            <param name="mr">The method/field</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(dnlib.DotNet.IField)">
            <summary>
            Creates a new instruction with a field operand
            </summary>
            <param name="field">The field</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(dnlib.DotNet.IMethod)">
            <summary>
            Creates a new instruction with a method operand
            </summary>
            <param name="method">The method</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(dnlib.DotNet.ITokenOperand)">
            <summary>
            Creates a new instruction with a token operand
            </summary>
            <param name="token">The token</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(dnlib.DotNet.MethodSig)">
            <summary>
            Creates a new instruction with a method signature operand
            </summary>
            <param name="methodSig">The method signature</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(dnlib.DotNet.Parameter)">
            <summary>
            Creates a new instruction with a method parameter operand
            </summary>
            <param name="parameter">The method parameter</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToInstruction(dnlib.DotNet.Emit.Local)">
            <summary>
            Creates a new instruction with a method local operand
            </summary>
            <param name="local">The method local</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.Instruction"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Emit.OpCode.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Emit.OpCodes">
            <summary>
            Contains all valid CIL opcodes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCodes.OneByteOpCodes">
            <summary>
            All one-byte opcodes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCodes.TwoByteOpCodes">
            <summary>
            All two-byte opcodes (first byte is <c>0xFE</c>)
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Emit.OpCodeType">
            <summary>
            CIL opcode type
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCodeType.Annotation">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCodeType.Macro">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCodeType.Nternal">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCodeType.Objmodel">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCodeType.Prefix">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.OpCodeType.Primitive">
            <summary/>
        </member>
        <member name="T:dnlib.DotNet.Emit.OperandType">
            <summary>
            CIL opcode operand type
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlineBrTarget">
            <summary>4-byte relative instruction offset</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlineField">
            <summary>4-byte field token (<see cref="F:dnlib.DotNet.MD.Table.Field"/> or <see cref="F:dnlib.DotNet.MD.Table.MemberRef"/>)</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlineI">
            <summary>int32</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlineI8">
            <summary>int64</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlineMethod">
            <summary>4-byte method token (<see cref="F:dnlib.DotNet.MD.Table.Method"/>, <see cref="F:dnlib.DotNet.MD.Table.MemberRef"/>
            or <see cref="F:dnlib.DotNet.MD.Table.MethodSpec"/>)</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlineNone">
            <summary>No operand</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlinePhi">
            <summary>Never used</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlineR">
            <summary>64-bit real</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.NOT_USED_8">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlineSig">
            <summary>4-byte method sig token (<see cref="F:dnlib.DotNet.MD.Table.StandAloneSig"/>)</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlineString">
            <summary>4-byte string token (<c>0x70xxxxxx</c>)</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlineSwitch">
            <summary>4-byte count N followed by N 4-byte relative instruction offsets</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlineTok">
            <summary>4-byte token (<see cref="F:dnlib.DotNet.MD.Table.Field"/>, <see cref="F:dnlib.DotNet.MD.Table.MemberRef"/>,
            <see cref="F:dnlib.DotNet.MD.Table.Method"/>, <see cref="F:dnlib.DotNet.MD.Table.MethodSpec"/>, <see cref="F:dnlib.DotNet.MD.Table.TypeDef"/>,
            <see cref="F:dnlib.DotNet.MD.Table.TypeRef"/> or <see cref="F:dnlib.DotNet.MD.Table.TypeSpec"/>)</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlineType">
            <summary>4-byte type token (<see cref="F:dnlib.DotNet.MD.Table.TypeDef"/>, <see cref="F:dnlib.DotNet.MD.Table.TypeRef"/> or
            <see cref="F:dnlib.DotNet.MD.Table.TypeSpec"/>)</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.InlineVar">
            <summary>2-byte param/local index</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.ShortInlineBrTarget">
            <summary>1-byte relative instruction offset</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.ShortInlineI">
            <summary>1-byte sbyte (<see cref="F:dnlib.DotNet.Emit.Code.Ldc_I4_S"/>) or byte (the rest)</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.ShortInlineR">
            <summary>32-bit real</summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.OperandType.ShortInlineVar">
            <summary>1-byte param/local index</summary>
        </member>
        <member name="T:dnlib.DotNet.Emit.StackBehaviour">
            <summary>
            CIL opcode stack behavior
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Pop0">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Pop1">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Pop1_pop1">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popi">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popi_pop1">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popi_popi">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popi_popi8">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popi_popi_popi">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popi_popr4">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popi_popr8">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popref">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popref_pop1">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popref_popi">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popref_popi_popi">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popref_popi_popi8">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popref_popi_popr4">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popref_popi_popr8">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popref_popi_popref">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Push0">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Push1">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Push1_push1">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Pushi">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Pushi8">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Pushr4">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Pushr8">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Pushref">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Varpop">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Varpush">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.Popref_popi_pop1">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Emit.StackBehaviour.PopAll">
            <summary/>
        </member>
        <member name="T:dnlib.DotNet.EventAttributes">
            <summary>
            Event attributes, see CorHdr.h/CorEventAttr
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventAttributes.SpecialName">
            <summary>event is special.  Name describes how.</summary>
        </member>
        <member name="F:dnlib.DotNet.EventAttributes.RTSpecialName">
            <summary>Runtime(metadata internal APIs) should check name encoding.</summary>
        </member>
        <member name="T:dnlib.DotNet.EventDef">
            <summary>
            A high-level representation of a row in the Event table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventDef.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.EventDef.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.EventDef.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.EventDef.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.EventDef.HasSemanticTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.EventDef.Attributes">
            <summary>
            From column Event.EventFlags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventDef.attributes">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.EventDef.Name">
            <summary>
            From column Event.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventDef.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.EventDef.EventType">
            <summary>
            From column Event.EventType
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventDef.eventType">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.EventDef.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventDef.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.EventDef.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.EventDef.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.EventDef.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.EventDef.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.EventDef.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventDef.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.EventDef.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.EventDef.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.EventDef.AddMethod">
            <summary>
            Gets/sets the adder method
            </summary>
        </member>
        <member name="P:dnlib.DotNet.EventDef.InvokeMethod">
            <summary>
            Gets/sets the invoker method
            </summary>
        </member>
        <member name="P:dnlib.DotNet.EventDef.RemoveMethod">
            <summary>
            Gets/sets the remover method
            </summary>
        </member>
        <member name="P:dnlib.DotNet.EventDef.OtherMethods">
            <summary>
            Gets the other methods
            </summary>
        </member>
        <member name="M:dnlib.DotNet.EventDef.InitializeEventMethods_NoLock">
            <summary>
            Initializes <see cref="F:dnlib.DotNet.EventDef.otherMethods"/>, <see cref="F:dnlib.DotNet.EventDef.addMethod"/>,
            <see cref="F:dnlib.DotNet.EventDef.invokeMethod"/> and <see cref="F:dnlib.DotNet.EventDef.removeMethod"/>.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventDef.addMethod">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.EventDef.invokeMethod">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.EventDef.removeMethod">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.EventDef.otherMethods">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.EventDef.ResetMethods">
            <summary>Reset <see cref="P:dnlib.DotNet.EventDef.AddMethod"/>, <see cref="P:dnlib.DotNet.EventDef.InvokeMethod"/>, <see cref="P:dnlib.DotNet.EventDef.RemoveMethod"/>, <see cref="P:dnlib.DotNet.EventDef.OtherMethods"/></summary>
        </member>
        <member name="P:dnlib.DotNet.EventDef.IsEmpty">
            <summary>
            <c>true</c> if there are no methods attached to this event
            </summary>
        </member>
        <member name="P:dnlib.DotNet.EventDef.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.EventDef.HasOtherMethods">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.EventDef.OtherMethods"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.EventDef.DeclaringType">
            <summary>
            Gets/sets the declaring type (owner type)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.EventDef.dnlib#DotNet#IMemberRef#DeclaringType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.EventDef.DeclaringType2">
            <summary>
            Called by <see cref="P:dnlib.DotNet.EventDef.DeclaringType"/> and should normally not be called by any user
            code. Use <see cref="P:dnlib.DotNet.EventDef.DeclaringType"/> instead. Only call this if you must set the
            declaring type without inserting it in the declaring type's method list.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventDef.declaringType2">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.EventDef.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.EventDef.FullName">
            <summary>
            Gets the full name of the event
            </summary>
        </member>
        <member name="M:dnlib.DotNet.EventDef.ModifyAttributes(System.Boolean,dnlib.DotNet.EventAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.EventDef.attributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.EventDef.IsSpecialName">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.EventAttributes.SpecialName"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.EventDef.IsRuntimeSpecialName">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.EventAttributes.RTSpecialName"/> bit
            </summary>
        </member>
        <member name="M:dnlib.DotNet.EventDef.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.EventDefUser">
            <summary>
            An Event row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.EventDefUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.EventDefUser.#ctor(dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:dnlib.DotNet.EventDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
            <param name="type">Type</param>
        </member>
        <member name="M:dnlib.DotNet.EventDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.ITypeDefOrRef,dnlib.DotNet.EventAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
            <param name="type">Type</param>
            <param name="flags">Flags</param>
        </member>
        <member name="T:dnlib.DotNet.EventDefMD">
            <summary>
            Created from a row in the Event table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventDefMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.EventDefMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.EventDefMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.EventDefMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.EventDefMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>Event</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.EventDefMD.InitializeEventMethods_NoLock">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.ExportedType">
            <summary>
            A high-level representation of a row in the ExportedType table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ExportedType.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ExportedType.module">
            <summary>
            The owner module
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.ImplementationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ExportedType.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ExportedType.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.ExportedType.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ExportedType.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ExportedType.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.ExportedType.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsValueType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsPrimitive">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.dnlib#DotNet#IType#TypeName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.Name">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.ReflectionName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.Namespace">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.ReflectionNamespace">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.FullName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.ReflectionFullName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.AssemblyQualifiedName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.DefinitionAssembly">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.Scope">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.ScopeType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.ContainsGenericParameter">
            <summary>
            Always returns <c>false</c> since a <see cref="T:dnlib.DotNet.ExportedType"/> does not contain any
            <see cref="T:dnlib.DotNet.GenericVar"/> or <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.dnlib#DotNet#IIsTypeOrMethod#IsMethod">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.dnlib#DotNet#IIsTypeOrMethod#IsType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.dnlib#DotNet#IGenericParameterProvider#NumberOfGenericParameters">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.Attributes">
            <summary>
            From column ExportedType.Flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ExportedType.attributes">
            <summary>Attributes</summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.TypeDefId">
            <summary>
            From column ExportedType.TypeDefId
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ExportedType.typeDefId">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.TypeName">
            <summary>
            From column ExportedType.TypeName
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ExportedType.typeName">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.TypeNamespace">
            <summary>
            From column ExportedType.TypeNamespace
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ExportedType.typeNamespace">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.Implementation">
            <summary>
            From column ExportedType.Implementation
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ExportedType.implementation">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.ExportedType.implementation_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ExportedType.GetImplementation_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.ExportedType.implementation"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsNested">
            <summary>
            <c>true</c> if it's nested within another <see cref="T:dnlib.DotNet.ExportedType"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.DeclaringType">
            <summary>
            Gets the declaring type, if any
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ExportedType.ModifyAttributes(dnlib.DotNet.TypeAttributes,dnlib.DotNet.TypeAttributes)">
            <summary>
            Modify <see cref="F:dnlib.DotNet.ExportedType.attributes"/> property: <see cref="F:dnlib.DotNet.ExportedType.attributes"/> =
            (<see cref="F:dnlib.DotNet.ExportedType.attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
            </summary>
            <param name="andMask">Value to <c>AND</c></param>
            <param name="orMask">Value to OR</param>
        </member>
        <member name="M:dnlib.DotNet.ExportedType.ModifyAttributes(System.Boolean,dnlib.DotNet.TypeAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.ExportedType.attributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.Visibility">
            <summary>
            Gets/sets the visibility
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsNotPublic">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NotPublic"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsPublic">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.Public"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsNestedPublic">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NestedPublic"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsNestedPrivate">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NestedPrivate"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsNestedFamily">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NestedFamily"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsNestedAssembly">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NestedAssembly"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsNestedFamilyAndAssembly">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NestedFamANDAssem"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsNestedFamilyOrAssembly">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NestedFamORAssem"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.Layout">
            <summary>
            Gets/sets the layout
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsAutoLayout">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.AutoLayout"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsSequentialLayout">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.SequentialLayout"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsExplicitLayout">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.ExplicitLayout"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsInterface">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Interface"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsClass">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Class"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsAbstract">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Abstract"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsSealed">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Sealed"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsSpecialName">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.SpecialName"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsImport">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Import"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsSerializable">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Serializable"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsWindowsRuntime">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.WindowsRuntime"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.StringFormat">
            <summary>
            Gets/sets the string format
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsAnsiClass">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.AnsiClass"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsUnicodeClass">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.UnicodeClass"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsAutoClass">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.AutoClass"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsCustomFormatClass">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.CustomFormatClass"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsBeforeFieldInit">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.BeforeFieldInit"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsForwarder">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Forwarder"/> bit. See also <see cref="P:dnlib.DotNet.ExportedType.MovedToAnotherAssembly"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.IsRuntimeSpecialName">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.RTSpecialName"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.HasSecurity">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.HasSecurity"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedType.MovedToAnotherAssembly">
            <summary>
            <c>true</c> if this type has been moved to another assembly
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ExportedType.Resolve">
            <summary>
            Resolves the type
            </summary>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
        </member>
        <member name="M:dnlib.DotNet.ExportedType.Resolve(dnlib.DotNet.ModuleDef)">
            <summary>
            Resolves the type
            </summary>
            <param name="sourceModule">Source module or <c>null</c></param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
        </member>
        <member name="M:dnlib.DotNet.ExportedType.ResolveThrow">
            <summary>
            Resolves the type
            </summary>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> instance</returns>
            <exception cref="T:dnlib.DotNet.TypeResolveException">If the type couldn't be resolved</exception>
        </member>
        <member name="M:dnlib.DotNet.ExportedType.ToTypeRef">
            <summary>
            Converts this instance to a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <returns>A new <see cref="T:dnlib.DotNet.TypeRef"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ExportedType.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.ExportedTypeUser">
            <summary>
            An ExportedType row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ExportedTypeUser.#ctor(dnlib.DotNet.ModuleDef)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
        </member>
        <member name="M:dnlib.DotNet.ExportedTypeUser.#ctor(dnlib.DotNet.ModuleDef,System.UInt32,dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String,dnlib.DotNet.TypeAttributes,dnlib.DotNet.IImplementation)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
            <param name="typeDefId">TypeDef ID</param>
            <param name="typeName">Type name</param>
            <param name="typeNamespace">Type namespace</param>
            <param name="flags">Flags</param>
            <param name="implementation">Implementation</param>
        </member>
        <member name="T:dnlib.DotNet.ExportedTypeMD">
            <summary>
            Created from a row in the ExportedType table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ExportedTypeMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.ExportedTypeMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ExportedTypeMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ExportedTypeMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ExportedTypeMD.GetImplementation_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ExportedTypeMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>ExportedType</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.FieldAttributes">
            <summary>
            Field flags, see CorHdr.h/CorFieldAttr
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.FieldAccessMask">
            <summary>member access mask - Use this mask to retrieve accessibility information.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.PrivateScope">
            <summary>Member not referenceable.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.CompilerControlled">
            <summary>Member not referenceable.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.Private">
            <summary>Accessible only by the parent type.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.FamANDAssem">
            <summary>Accessible by sub-types only in this Assembly.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.Assembly">
            <summary>Accessibly by anyone in the Assembly.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.Family">
            <summary>Accessible only by type and sub-types.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.FamORAssem">
            <summary>Accessibly by sub-types anywhere, plus anyone in assembly.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.Public">
            <summary>Accessibly by anyone who has visibility to this scope.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.Static">
            <summary>Defined on type, else per instance.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.InitOnly">
            <summary>Field may only be initialized, not written to after init.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.Literal">
            <summary>Value is compile time constant.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.NotSerialized">
            <summary>Field does not have to be serialized when type is remoted.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.SpecialName">
            <summary>field is special.  Name describes how.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.PinvokeImpl">
            <summary>Implementation is forwarded through pinvoke.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.RTSpecialName">
            <summary>Runtime(metadata internal APIs) should check name encoding.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.HasFieldMarshal">
            <summary>Field has marshalling information.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.HasDefault">
            <summary>Field has default.</summary>
        </member>
        <member name="F:dnlib.DotNet.FieldAttributes.HasFieldRVA">
            <summary>Field has RVA.</summary>
        </member>
        <member name="T:dnlib.DotNet.FieldDef">
            <summary>
            A high-level representation of a row in the Field table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.HasConstantTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.HasFieldMarshalTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.MemberForwardedTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.FieldDef.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.FieldDef.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.Attributes">
            <summary>
            From column Field.Flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.attributes">
            <summary>Attributes</summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.Name">
            <summary>
            From column Field.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.Signature">
            <summary>
            From column Field.Signature
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.signature">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.FieldOffset">
            <summary>
            Gets/sets the field layout offset
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.fieldOffset">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.fieldOffset_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.GetFieldOffset_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.FieldDef.fieldOffset"/></summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.MarshalType">
            <inheritdoc/>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.marshalType">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.marshalType_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.GetMarshalType_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.FieldDef.marshalType"/></summary>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.ResetMarshalType">
            <summary>Reset <see cref="P:dnlib.DotNet.FieldDef.MarshalType"/></summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.RVA">
            <summary>
            Gets/sets the field RVA
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.rva">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.rva_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.GetRVA_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.FieldDef.rva"/></summary>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.ResetRVA">
            <summary>Reset <see cref="P:dnlib.DotNet.FieldDef.RVA"/></summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.InitialValue">
            <summary>
            Gets/sets the initial value. Be sure to set <see cref="P:dnlib.DotNet.FieldDef.HasFieldRVA"/> to <c>true</c> if
            you write to this field.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.initialValue">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.initialValue_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.GetInitialValue_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.FieldDef.initialValue"/></summary>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.ResetInitialValue">
            <summary>Reset <see cref="P:dnlib.DotNet.FieldDef.InitialValue"/></summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.ImplMap">
            <inheritdoc/>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.implMap">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.implMap_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.GetImplMap_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.FieldDef.implMap"/></summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.Constant">
            <inheritdoc/>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.constant">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.constant_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.GetConstant_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.FieldDef.constant"/></summary>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.ResetConstant">
            <summary>Reset <see cref="P:dnlib.DotNet.FieldDef.Constant"/></summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.HasImplMap">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.DeclaringType">
            <summary>
            Gets/sets the declaring type (owner type)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.dnlib#DotNet#IMemberRef#DeclaringType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.DeclaringType2">
            <summary>
            Called by <see cref="P:dnlib.DotNet.FieldDef.DeclaringType"/> and should normally not be called by any user
            code. Use <see cref="P:dnlib.DotNet.FieldDef.DeclaringType"/> instead. Only call this if you must set the
            declaring type without inserting it in the declaring type's method list.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldDef.declaringType2">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.FieldSig">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.FieldDef.FieldSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.HasLayoutInfo">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.FieldDef.FieldOffset"/> is not <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.HasConstant">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.FieldDef.Constant"/> is not <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.ElementType">
            <summary>
            Gets the constant element type or <see cref="F:dnlib.DotNet.ElementType.End"/> if there's no constant
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.HasMarshalType">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.FieldDef.MarshalType"/> is not <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.FieldType">
            <summary>
            Gets/sets the field type
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.ModifyAttributes(dnlib.DotNet.FieldAttributes,dnlib.DotNet.FieldAttributes)">
            <summary>
            Modify <see cref="F:dnlib.DotNet.FieldDef.attributes"/> field: <see cref="F:dnlib.DotNet.FieldDef.attributes"/> =
            (<see cref="F:dnlib.DotNet.FieldDef.attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
            </summary>
            <param name="andMask">Value to <c>AND</c></param>
            <param name="orMask">Value to OR</param>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.ModifyAttributes(System.Boolean,dnlib.DotNet.FieldAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.FieldDef.attributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.Access">
            <summary>
            Gets/sets the field access
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsCompilerControlled">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.FieldAttributes.PrivateScope"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsPrivateScope">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.FieldAttributes.PrivateScope"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsPrivate">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.FieldAttributes.Private"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsFamilyAndAssembly">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.FieldAttributes.FamANDAssem"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsAssembly">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.FieldAttributes.Assembly"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsFamily">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.FieldAttributes.Family"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsFamilyOrAssembly">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.FieldAttributes.FamORAssem"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsPublic">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.FieldAttributes.Public"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsStatic">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.FieldAttributes.Static"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsInitOnly">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.FieldAttributes.InitOnly"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsLiteral">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.FieldAttributes.Literal"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsNotSerialized">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.FieldAttributes.NotSerialized"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsSpecialName">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.FieldAttributes.SpecialName"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsPinvokeImpl">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.FieldAttributes.PinvokeImpl"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.IsRuntimeSpecialName">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.FieldAttributes.RTSpecialName"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.HasFieldMarshal">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.FieldAttributes.HasFieldMarshal"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.HasDefault">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.FieldAttributes.HasDefault"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.HasFieldRVA">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.FieldAttributes.HasFieldRVA"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDef.FullName">
            <summary>
            Returns the full name of this field
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.GetFieldSize">
            <summary>
            Gets the size of this field in bytes or <c>0</c> if unknown.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.GetFieldSize(System.UInt32@)">
            <summary>
            Gets the size of this field in bytes or <c>0</c> if unknown.
            </summary>
            <param name="size">Updated with size</param>
            <returns><c>true</c> if <paramref name="size"/> is valid, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.GetFieldSize(dnlib.DotNet.TypeDef,dnlib.DotNet.FieldSig,System.UInt32@)">
            <summary>
            Gets the size of this field in bytes or <c>0</c> if unknown.
            </summary>
            <param name="declaringType">The declaring type of <c>this</c></param>
            <param name="fieldSig">The field signature of <c>this</c></param>
            <param name="size">Updated with size</param>
            <returns><c>true</c> if <paramref name="size"/> is valid, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.GetFieldSize(dnlib.DotNet.TypeDef,dnlib.DotNet.FieldSig,System.Int32,System.UInt32@)">
            <summary>
            Gets the size of this field in bytes or <c>0</c> if unknown.
            </summary>
            <param name="declaringType">The declaring type of <c>this</c></param>
            <param name="fieldSig">The field signature of <c>this</c></param>
            <param name="ptrSize">Size of a pointer</param>
            <param name="size">Updated with size</param>
            <returns><c>true</c> if <paramref name="size"/> is valid, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.FieldDef.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.FieldDefUser">
            <summary>
            A Field row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FieldDefUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FieldDefUser.#ctor(dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:dnlib.DotNet.FieldDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.FieldSig)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
            <param name="signature">Signature</param>
        </member>
        <member name="M:dnlib.DotNet.FieldDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.FieldSig,dnlib.DotNet.FieldAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
            <param name="signature">Signature</param>
            <param name="attributes">Flags</param>
        </member>
        <member name="T:dnlib.DotNet.FieldDefMD">
            <summary>
            Created from a row in the Field table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldDefMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.FieldDefMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldDefMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldDefMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldDefMD.GetFieldOffset_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldDefMD.GetMarshalType_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldDefMD.GetRVA_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldDefMD.GetInitialValue_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldDefMD.GetImplMap_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldDefMD.GetConstant_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldDefMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>Field</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.FileAttributes">
            <summary>
            File row flags. See CorHdr.h/CorFileFlags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FileAttributes.ContainsMetadata">
            <summary>This is not a resource file</summary>
        </member>
        <member name="F:dnlib.DotNet.FileAttributes.ContainsNoMetadata">
            <summary>This is a resource file or other non-metadata-containing file</summary>
        </member>
        <member name="T:dnlib.DotNet.FileDef">
            <summary>
            A high-level representation of a row in the File table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FileDef.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FileDef.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FileDef.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FileDef.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FileDef.ImplementationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FileDef.Flags">
            <summary>
            From column File.Flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FileDef.attributes">
            <summary>Attributes</summary>
        </member>
        <member name="P:dnlib.DotNet.FileDef.Name">
            <summary>
            From column File.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FileDef.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.FileDef.HashValue">
            <summary>
            From column File.HashValue
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FileDef.hashValue">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.FileDef.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FileDef.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.FileDef.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.FileDef.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.FileDef.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FileDef.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FileDef.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FileDef.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FileDef.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.FileDef.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.FileDef.customDebugInfos"/></summary>
        </member>
        <member name="M:dnlib.DotNet.FileDef.ModifyAttributes(System.Boolean,dnlib.DotNet.FileAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.FileDef.attributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.FileDef.ContainsMetadata">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.FileAttributes.ContainsMetadata"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FileDef.ContainsNoMetadata">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.FileAttributes.ContainsNoMetadata"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FileDef.FullName">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FileDef.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.FileDefUser">
            <summary>
            A File row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FileDefUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FileDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.FileAttributes,System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="name">Name of file</param>
            <param name="flags">Flags</param>
            <param name="hashValue">File hash</param>
        </member>
        <member name="T:dnlib.DotNet.FileDefMD">
            <summary>
            Created from a row in the File table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FileDefMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.FileDefMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FileDefMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FileDefMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FileDefMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>File</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.FrameworkRedirect">
            <summary>
            Redirects .NET framework assembly references from older to newer versions
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FrameworkRedirect.ApplyFrameworkRedirect(dnlib.DotNet.IAssembly@,dnlib.DotNet.ModuleDef)">
            <summary>
            Redirects a .NET Framework assembly from an older version to the correct version
            loaded at runtime.
            </summary>
            <param name="assembly">Current assembly reference that might get updated</param>
            <param name="sourceModule">Module using the assembly reference</param>
        </member>
        <member name="M:dnlib.DotNet.FrameworkRedirect.TryApplyFrameworkRedirect(dnlib.DotNet.IAssembly,dnlib.DotNet.ModuleDef,dnlib.DotNet.IAssembly@)">
            <summary>
            Tries to redirect a .NET Framework assembly from an older version to the correct version
            loaded at runtime.
            </summary>
            <param name="assembly">Assembly reference</param>
            <param name="sourceModule">Module using the assembly reference</param>
            <param name="redirectedAssembly">Updated with the redirected assembly if successful</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.FrameworkRedirect.ApplyFrameworkRedirectV2(dnlib.DotNet.IAssembly@)">
            <summary>
            Redirects a .NET Framework 2.0-3.5 assembly from an older version to the correct version
            loaded at runtime.
            </summary>
            <param name="assembly">Current assembly reference that might get updated</param>
        </member>
        <member name="M:dnlib.DotNet.FrameworkRedirect.ApplyFrameworkRedirectV4(dnlib.DotNet.IAssembly@)">
            <summary>
            Redirects a .NET Framework 4.0+ assembly from an older version to the correct version
            loaded at runtime.
            </summary>
            <param name="assembly">Current assembly reference that might get updated</param>
        </member>
        <member name="M:dnlib.DotNet.FrameworkRedirect.TryApplyFrameworkRedirectV2(dnlib.DotNet.IAssembly,dnlib.DotNet.IAssembly@)">
            <summary>
            Tries to redirect a .NET Framework 2.0-3.5 assembly from an older version to the correct version
            loaded at runtime.
            </summary>
            <param name="assembly">Assembly reference</param>
            <param name="redirectedAssembly">Updated with the redirected assembly if successful</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.FrameworkRedirect.TryApplyFrameworkRedirectV4(dnlib.DotNet.IAssembly,dnlib.DotNet.IAssembly@)">
            <summary>
            Tries to redirect a .NET Framework 4.0+ assembly from an older version to the correct version
            loaded at runtime.
            </summary>
            <param name="assembly">Assembly reference</param>
            <param name="redirectedAssembly">Updated with the redirected assembly if successful</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.IFullNameFactoryHelper">
            <summary>
            Helps <see cref="T:dnlib.DotNet.FullNameFactory"/> create a name
            </summary>
        </member>
        <member name="M:dnlib.DotNet.IFullNameFactoryHelper.MustUseAssemblyName(dnlib.DotNet.IType)">
            <summary>
            Checks whether the assembly name should be included when printing
            the full type name. The assembly name isn't required in custom attributes
            when the type already exists in the same module as the CA, or if the type
            exists in mscorlib.
            </summary>
            <param name="type">The type (<c>TypeDef</c>, <c>TypeRef</c> or <c>ExportedType</c>)
            or <c>null</c></param>
            <returns><c>true</c> if the assembly name must be included, <c>false</c> otherwise</returns>
        </member>
        <member name="T:dnlib.DotNet.FullNameFactory">
            <summary>
            Creates type names, method names, etc.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.MustUseAssemblyName(dnlib.DotNet.ModuleDef,dnlib.DotNet.IType)">
            <summary>
            Checks whether the assembly name should be included when printing the full name.
            See <see cref="M:dnlib.DotNet.IFullNameFactoryHelper.MustUseAssemblyName(dnlib.DotNet.IType)"/> for more info.
            </summary>
            <param name="module">Owner module</param>
            <param name="type">The type (<c>TypeDef</c>, <c>TypeRef</c> or <c>ExportedType</c>)
            or <c>null</c></param>
            <returns><c>true</c> if the assembly name must be included, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FullName(dnlib.DotNet.IType,System.Boolean,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a <see cref="T:dnlib.DotNet.IType"/>
            </summary>
            <param name="type">The <c>TypeRef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FullNameSB(dnlib.DotNet.IType,System.Boolean,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a <see cref="T:dnlib.DotNet.IType"/>
            </summary>
            <param name="type">The <c>TypeRef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Name(dnlib.DotNet.IType,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the name of a <see cref="T:dnlib.DotNet.IType"/>
            </summary>
            <param name="type">The <c>TypeRef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.NameSB(dnlib.DotNet.IType,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the name of a <see cref="T:dnlib.DotNet.IType"/>
            </summary>
            <param name="type">The <c>TypeRef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Namespace(dnlib.DotNet.IType,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the namespace of a <see cref="T:dnlib.DotNet.IType"/>
            </summary>
            <param name="type">The <c>TypeRef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.NamespaceSB(dnlib.DotNet.IType,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the namespace of a <see cref="T:dnlib.DotNet.IType"/>
            </summary>
            <param name="type">The <c>TypeRef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.AssemblyQualifiedName(dnlib.DotNet.IType,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the assembly qualified full name of a <see cref="T:dnlib.DotNet.IType"/>
            </summary>
            <param name="type">The <c>IType</c></param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The assembly qualified full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.AssemblyQualifiedNameSB(dnlib.DotNet.IType,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the assembly qualified full name of a <see cref="T:dnlib.DotNet.IType"/>
            </summary>
            <param name="type">The <c>IType</c></param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The assembly qualified full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.PropertyFullName(System.String,dnlib.DotNet.UTF8String,dnlib.DotNet.CallingConventionSig,System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Text.StringBuilder)">
            <summary>
            Returns the full name of a property
            </summary>
            <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
            <param name="name">Name of property</param>
            <param name="propertySig">Property signature</param>
            <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
            <param name="sb">String builder to use or null</param>
            <returns>Property full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.PropertyFullNameSB(System.String,dnlib.DotNet.UTF8String,dnlib.DotNet.CallingConventionSig,System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Text.StringBuilder)">
            <summary>
            Returns the full name of a property
            </summary>
            <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
            <param name="name">Name of property</param>
            <param name="propertySig">Property signature</param>
            <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
            <param name="sb">String builder to use or null</param>
            <returns>Property full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.EventFullName(System.String,dnlib.DotNet.UTF8String,dnlib.DotNet.ITypeDefOrRef,System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Text.StringBuilder)">
            <summary>
            Returns the full name of a property
            </summary>
            <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
            <param name="name">Name of property</param>
            <param name="typeDefOrRef">Event type</param>
            <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
            <param name="sb">String builder to use or null</param>
            <returns>Property full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.EventFullNameSB(System.String,dnlib.DotNet.UTF8String,dnlib.DotNet.ITypeDefOrRef,System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Text.StringBuilder)">
            <summary>
            Returns the full name of a property
            </summary>
            <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
            <param name="name">Name of property</param>
            <param name="typeDefOrRef">Event type</param>
            <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
            <param name="sb">String builder to use or null</param>
            <returns>Property full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FieldFullName(System.String,System.String,dnlib.DotNet.FieldSig,System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Text.StringBuilder)">
            <summary>
            Returns the full name of a field
            </summary>
            <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
            <param name="name">Name of field</param>
            <param name="fieldSig">Field signature</param>
            <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
            <param name="sb">String builder to use or null</param>
            <returns>Field full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FieldFullNameSB(System.String,System.String,dnlib.DotNet.FieldSig,System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Text.StringBuilder)">
            <summary>
            Returns the full name of a field
            </summary>
            <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
            <param name="name">Name of field</param>
            <param name="fieldSig">Field signature</param>
            <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
            <param name="sb">String builder to use or null</param>
            <returns>Field full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.MethodFullName(System.String,System.String,dnlib.DotNet.MethodSig,System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Collections.Generic.IList{dnlib.DotNet.TypeSig},dnlib.DotNet.MethodDef,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a method
            </summary>
            <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
            <param name="name">Name of method or <c>null</c> if none</param>
            <param name="methodSig">Method signature</param>
            <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
            <param name="methodGenArgs">Method generic arguments or <c>null</c> if none</param>
            <param name="gppMethod">Generic parameter owner method or <c>null</c></param>
            <param name="sb">String builder to use or null</param>
            <returns>Method full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.MethodFullNameSB(System.String,System.String,dnlib.DotNet.MethodSig,System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Collections.Generic.IList{dnlib.DotNet.TypeSig},dnlib.DotNet.MethodDef,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a method
            </summary>
            <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
            <param name="name">Name of method or <c>null</c> if none</param>
            <param name="methodSig">Method signature</param>
            <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
            <param name="methodGenArgs">Method generic arguments or <c>null</c> if none</param>
            <param name="gppMethod">Generic parameter owner method or <c>null</c></param>
            <param name="sb">String builder to use or null</param>
            <returns>Method full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.MethodBaseSigFullName(dnlib.DotNet.MethodBaseSig,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a property sig
            </summary>
            <param name="sig">Property sig</param>
            <param name="sb">String builder to use or null</param>
            <returns>Property sig full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.MethodBaseSigFullNameSB(dnlib.DotNet.MethodBaseSig,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a property sig
            </summary>
            <param name="sig">Property sig</param>
            <param name="sb">String builder to use or null</param>
            <returns>Property sig full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.MethodBaseSigFullName(System.String,System.String,dnlib.DotNet.MethodBaseSig,dnlib.DotNet.MethodDef,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a sig
            </summary>
            <param name="declType">Declaring type or null</param>
            <param name="name">Name or null</param>
            <param name="sig">Method sig</param>
            <param name="gppMethod">Owner method or null</param>
            <param name="sb">String builder to use or null</param>
            <returns>Sig full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.MethodBaseSigFullNameSB(System.String,System.String,dnlib.DotNet.MethodBaseSig,dnlib.DotNet.MethodDef,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a sig
            </summary>
            <param name="declType">Declaring type or null</param>
            <param name="name">Name or null</param>
            <param name="sig">Method sig</param>
            <param name="gppMethod">Owner method or null</param>
            <param name="sb">String builder to use or null</param>
            <returns>Sig full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Namespace(dnlib.DotNet.TypeRef,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the namespace of a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="typeRef">The <c>TypeRef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The namespace</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.NamespaceSB(dnlib.DotNet.TypeRef,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the namespace of a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="typeRef">The <c>TypeRef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The namespace</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Name(dnlib.DotNet.TypeRef,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the name of a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="typeRef">The <c>TypeRef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.NameSB(dnlib.DotNet.TypeRef,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the name of a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="typeRef">The <c>TypeRef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FullName(dnlib.DotNet.TypeRef,System.Boolean,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="typeRef">The <c>TypeRef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FullNameSB(dnlib.DotNet.TypeRef,System.Boolean,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="typeRef">The <c>TypeRef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.AssemblyQualifiedName(dnlib.DotNet.TypeRef,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the assembly qualified full name of a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="typeRef">The <c>TypeRef</c></param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The assembly qualified full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.AssemblyQualifiedNameSB(dnlib.DotNet.TypeRef,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the assembly qualified full name of a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="typeRef">The <c>TypeRef</c></param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The assembly qualified full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.DefinitionAssembly(dnlib.DotNet.TypeRef)">
            <summary>
            Returns the assembly where this type is defined
            </summary>
            <param name="typeRef">The <c>TypeRef</c></param>
            <returns>A <see cref="T:dnlib.DotNet.IAssembly"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Scope(dnlib.DotNet.TypeRef)">
            <summary>
            Gets the scope
            </summary>
            <param name="typeRef">The <c>TypeRef</c></param>
            <returns>The <see cref="T:dnlib.DotNet.IScope"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.OwnerModule(dnlib.DotNet.TypeRef)">
            <summary>
            Returns the owner module. The type was created from metadata in this module.
            </summary>
            <param name="typeRef">The <c>TypeRef</c></param>
            <returns>A <see cref="T:dnlib.DotNet.ModuleDef"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Namespace(dnlib.DotNet.TypeDef,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the namespace of a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="typeDef">The <c>TypeDef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The namespace</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.NamespaceSB(dnlib.DotNet.TypeDef,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the namespace of a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="typeDef">The <c>TypeDef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The namespace</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Name(dnlib.DotNet.TypeDef,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the name of a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="typeDef">The <c>TypeDef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.NameSB(dnlib.DotNet.TypeDef,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the name of a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="typeDef">The <c>TypeDef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FullName(dnlib.DotNet.TypeDef,System.Boolean,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="typeDef">The <c>TypeDef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FullNameSB(dnlib.DotNet.TypeDef,System.Boolean,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="typeDef">The <c>TypeDef</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.AssemblyQualifiedName(dnlib.DotNet.TypeDef,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the assembly qualified full name of a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="typeDef">The <c>TypeDef</c></param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The assembly qualified full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.AssemblyQualifiedNameSB(dnlib.DotNet.TypeDef,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the assembly qualified full name of a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="typeDef">The <c>TypeDef</c></param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The assembly qualified full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.DefinitionAssembly(dnlib.DotNet.TypeDef)">
            <summary>
            Returns the assembly where this type is defined
            </summary>
            <param name="typeDef">The <c>TypeDef</c></param>
            <returns>A <see cref="T:dnlib.DotNet.IAssembly"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.OwnerModule(dnlib.DotNet.TypeDef)">
            <summary>
            Returns the owner module. The type was created from metadata in this module.
            </summary>
            <param name="typeDef">The <c>TypeDef</c></param>
            <returns>A <see cref="T:dnlib.DotNet.ModuleDef"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Namespace(dnlib.DotNet.TypeSpec,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the namespace of a <see cref="T:dnlib.DotNet.TypeSpec"/>
            </summary>
            <param name="typeSpec">The <c>TypeSpec</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The namespace</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.NamespaceSB(dnlib.DotNet.TypeSpec,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the namespace of a <see cref="T:dnlib.DotNet.TypeSpec"/>
            </summary>
            <param name="typeSpec">The <c>TypeSpec</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The namespace</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Name(dnlib.DotNet.TypeSpec,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the name of a <see cref="T:dnlib.DotNet.TypeSpec"/>
            </summary>
            <param name="typeSpec">The <c>TypeSpec</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.NameSB(dnlib.DotNet.TypeSpec,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the name of a <see cref="T:dnlib.DotNet.TypeSpec"/>
            </summary>
            <param name="typeSpec">The <c>TypeSpec</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FullName(dnlib.DotNet.TypeSpec,System.Boolean,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a <see cref="T:dnlib.DotNet.TypeSpec"/>
            </summary>
            <param name="typeSpec">The <c>TypeSpec</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FullNameSB(dnlib.DotNet.TypeSpec,System.Boolean,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a <see cref="T:dnlib.DotNet.TypeSpec"/>
            </summary>
            <param name="typeSpec">The <c>TypeSpec</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.AssemblyQualifiedName(dnlib.DotNet.TypeSpec,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the assembly qualified full name of a <see cref="T:dnlib.DotNet.TypeSpec"/>
            </summary>
            <param name="typeSpec">The <c>TypeSpec</c></param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The assembly qualified full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.AssemblyQualifiedNameSB(dnlib.DotNet.TypeSpec,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the assembly qualified full name of a <see cref="T:dnlib.DotNet.TypeSpec"/>
            </summary>
            <param name="typeSpec">The <c>TypeSpec</c></param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The assembly qualified full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.DefinitionAssembly(dnlib.DotNet.TypeSpec)">
            <summary>
            Returns the assembly where this type is defined
            </summary>
            <param name="typeSpec">The <c>TypeSpec</c></param>
            <returns>A <see cref="T:dnlib.DotNet.IAssembly"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.ScopeType(dnlib.DotNet.TypeSpec)">
            <summary>
            Gets the scope type
            </summary>
            <param name="typeSpec">The <c>TypeSpec</c></param>
            <returns>The scope type or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Scope(dnlib.DotNet.TypeSpec)">
            <summary>
            Gets the scope
            </summary>
            <param name="typeSpec">The <c>TypeSpec</c></param>
            <returns>The <see cref="T:dnlib.DotNet.IScope"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.OwnerModule(dnlib.DotNet.TypeSpec)">
            <summary>
            Returns the owner module. The type was created from metadata in this module.
            </summary>
            <param name="typeSpec">The <c>TypeSpec</c></param>
            <returns>A <see cref="T:dnlib.DotNet.ModuleDef"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Namespace(dnlib.DotNet.TypeSig,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the namespace of a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="typeSig">The type sig</param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The namespace</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.NamespaceSB(dnlib.DotNet.TypeSig,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the namespace of a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="typeSig">The type sig</param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The namespace</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Name(dnlib.DotNet.TypeSig,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the name of a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="typeSig">The type sig</param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.NameSB(dnlib.DotNet.TypeSig,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the name of a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="typeSig">The type sig</param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FullName(dnlib.DotNet.TypeSig,System.Boolean,dnlib.DotNet.IFullNameFactoryHelper,System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Text.StringBuilder)">
            <summary>
            Returns the full name of a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="typeSig">The type sig</param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="helper">Helps print the name</param>
            <param name="typeGenArgs">Type generic args or <c>null</c> if none</param>
            <param name="methodGenArgs">Method generic args or <c>null</c> if none</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FullNameSB(dnlib.DotNet.TypeSig,System.Boolean,dnlib.DotNet.IFullNameFactoryHelper,System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Text.StringBuilder)">
            <summary>
            Returns the full name of a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="typeSig">The type sig</param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="helper">Helps print the name</param>
            <param name="typeGenArgs">Type generic args or <c>null</c> if none</param>
            <param name="methodGenArgs">Method generic args or <c>null</c> if none</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.AssemblyQualifiedName(dnlib.DotNet.TypeSig,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the assembly qualified full name of a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="typeSig">The <c>TypeSig</c></param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The assembly qualified full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.AssemblyQualifiedNameSB(dnlib.DotNet.TypeSig,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the assembly qualified full name of a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="typeSig">The <c>TypeSig</c></param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The assembly qualified full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.DefinitionAssembly(dnlib.DotNet.TypeSig)">
            <summary>
            Returns the assembly where this type is defined
            </summary>
            <param name="typeSig">The <c>TypeSig</c></param>
            <returns>A <see cref="T:dnlib.DotNet.IAssembly"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Scope(dnlib.DotNet.TypeSig)">
            <summary>
            Gets the scope
            </summary>
            <param name="typeSig">The <c>TypeSig</c></param>
            <returns>The <see cref="T:dnlib.DotNet.IScope"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.ScopeType(dnlib.DotNet.TypeSig)">
            <summary>
            Gets the scope type
            </summary>
            <param name="typeSig">The <c>TypeSig</c></param>
            <returns>The scope type or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.OwnerModule(dnlib.DotNet.TypeSig)">
            <summary>
            Returns the owner module. The type was created from metadata in this module.
            </summary>
            <param name="typeSig">The <c>TypeSig</c></param>
            <returns>A <see cref="T:dnlib.DotNet.ModuleDef"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Namespace(dnlib.DotNet.ExportedType,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the namespace of a <see cref="T:dnlib.DotNet.ExportedType"/>
            </summary>
            <param name="exportedType">The <c>ExportedType</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The namespace</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.NamespaceSB(dnlib.DotNet.ExportedType,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the namespace of a <see cref="T:dnlib.DotNet.ExportedType"/>
            </summary>
            <param name="exportedType">The <c>ExportedType</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The namespace</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Name(dnlib.DotNet.ExportedType,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the name of a <see cref="T:dnlib.DotNet.ExportedType"/>
            </summary>
            <param name="exportedType">The <c>ExportedType</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.NameSB(dnlib.DotNet.ExportedType,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Returns the name of a <see cref="T:dnlib.DotNet.ExportedType"/>
            </summary>
            <param name="exportedType">The <c>ExportedType</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="sb">String builder to use or null</param>
            <returns>The name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FullName(dnlib.DotNet.ExportedType,System.Boolean,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a <see cref="T:dnlib.DotNet.ExportedType"/>
            </summary>
            <param name="exportedType">The <c>ExportedType</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.FullNameSB(dnlib.DotNet.ExportedType,System.Boolean,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the full name of a <see cref="T:dnlib.DotNet.ExportedType"/>
            </summary>
            <param name="exportedType">The <c>ExportedType</c></param>
            <param name="isReflection">Set if output should be compatible with reflection</param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.AssemblyQualifiedName(dnlib.DotNet.ExportedType,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the assembly qualified full name of a <see cref="T:dnlib.DotNet.ExportedType"/>
            </summary>
            <param name="exportedType">The <c>ExportedType</c></param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The assembly qualified full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.AssemblyQualifiedNameSB(dnlib.DotNet.ExportedType,dnlib.DotNet.IFullNameFactoryHelper,System.Text.StringBuilder)">
            <summary>
            Returns the assembly qualified full name of a <see cref="T:dnlib.DotNet.ExportedType"/>
            </summary>
            <param name="exportedType">The <c>ExportedType</c></param>
            <param name="helper">Helps print the name</param>
            <param name="sb">String builder to use or null</param>
            <returns>The assembly qualified full name</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.DefinitionAssembly(dnlib.DotNet.ExportedType)">
            <summary>
            Returns the assembly where this type is defined
            </summary>
            <param name="exportedType">The <c>ExportedType</c></param>
            <returns>A <see cref="T:dnlib.DotNet.IAssembly"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.ScopeType(dnlib.DotNet.ExportedType)">
            <summary>
            Gets the scope type
            </summary>
            <param name="exportedType">The <c>ExportedType</c></param>
            <returns>The scope type or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.Scope(dnlib.DotNet.ExportedType)">
            <summary>
            Gets the scope
            </summary>
            <param name="exportedType">The <c>ExportedType</c></param>
            <returns>The <see cref="T:dnlib.DotNet.IScope"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.OwnerModule(dnlib.DotNet.ExportedType)">
            <summary>
            Returns the owner module. The type was created from metadata in this module.
            </summary>
            <param name="exportedType">The <c>ExportedType</c></param>
            <returns>A <see cref="T:dnlib.DotNet.ModuleDef"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.FullNameFactory.ToString">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericArgumentsStack.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="isTypeVar"><c>true</c> if it's for generic types, <c>false</c> if generic methods</param>
        </member>
        <member name="M:dnlib.DotNet.GenericArgumentsStack.Push(System.Collections.Generic.IList{dnlib.DotNet.TypeSig})">
            <summary>
            Pushes generic arguments
            </summary>
            <param name="args">The generic arguments</param>
        </member>
        <member name="M:dnlib.DotNet.GenericArgumentsStack.Pop">
            <summary>
            Pops generic arguments
            </summary>
            <returns>The popped generic arguments</returns>
        </member>
        <member name="M:dnlib.DotNet.GenericArgumentsStack.Resolve(System.UInt32)">
            <summary>
            Resolves a generic argument
            </summary>
            <param name="number">Generic variable number</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeSig"/> or <c>null</c> if none was found</returns>
        </member>
        <member name="T:dnlib.DotNet.GenericArguments">
            <summary>
            Replaces generic type/method var with its generic argument
            </summary>
        </member>
        <member name="M:dnlib.DotNet.GenericArguments.PushTypeArgs(System.Collections.Generic.IList{dnlib.DotNet.TypeSig})">
            <summary>
            Pushes generic arguments
            </summary>
            <param name="typeArgs">The generic arguments</param>
        </member>
        <member name="M:dnlib.DotNet.GenericArguments.PopTypeArgs">
            <summary>
            Pops generic arguments
            </summary>
            <returns>The popped generic arguments</returns>
        </member>
        <member name="M:dnlib.DotNet.GenericArguments.PushMethodArgs(System.Collections.Generic.IList{dnlib.DotNet.TypeSig})">
            <summary>
            Pushes generic arguments
            </summary>
            <param name="methodArgs">The generic arguments</param>
        </member>
        <member name="M:dnlib.DotNet.GenericArguments.PopMethodArgs">
            <summary>
            Pops generic arguments
            </summary>
            <returns>The popped generic arguments</returns>
        </member>
        <member name="M:dnlib.DotNet.GenericArguments.Resolve(dnlib.DotNet.TypeSig)">
            <summary>
            Replaces a generic type/method var with its generic argument (if any). If
            <paramref name="typeSig"/> isn't a generic type/method var or if it can't
            be resolved, it itself is returned. Else the resolved type is returned.
            </summary>
            <param name="typeSig">Type signature</param>
            <returns>New <see cref="T:dnlib.DotNet.TypeSig"/> which is never <c>null</c> unless
            <paramref name="typeSig"/> is <c>null</c></returns>
        </member>
        <member name="T:dnlib.DotNet.GenericParam">
            <summary>
            A high-level representation of a row in the GenericParam table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParam.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.Owner">
            <summary>
            Gets the owner type/method
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParam.owner">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.DeclaringType">
            <summary>
            Gets the declaring type or <c>null</c> if none or if <see cref="P:dnlib.DotNet.GenericParam.Owner"/> is
            not a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.dnlib#DotNet#IMemberRef#DeclaringType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.DeclaringMethod">
            <summary>
            Gets the declaring method or <c>null</c> if none or if <see cref="P:dnlib.DotNet.GenericParam.Owner"/> is
            not a <see cref="T:dnlib.DotNet.MethodDef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.Number">
            <summary>
            From column GenericParam.Number
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParam.number">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.Flags">
            <summary>
            From column GenericParam.Flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParam.attributes">
            <summary>Attributes</summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.Name">
            <summary>
            From column GenericParam.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParam.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.Kind">
            <summary>
            From column GenericParam.Kind (v1.1 only)
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParam.kind">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.GenericParamConstraints">
            <summary>
            Gets the generic param constraints
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParam.genericParamConstraints">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.GenericParam.InitializeGenericParamConstraints">
            <summary>Initializes <see cref="F:dnlib.DotNet.GenericParam.genericParamConstraints"/></summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParam.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.GenericParam.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.GenericParam.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParam.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.GenericParam.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.GenericParam.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.HasGenericParamConstraints">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.GenericParam.GenericParamConstraints"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.FullName">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericParam.ModifyAttributes(dnlib.DotNet.GenericParamAttributes,dnlib.DotNet.GenericParamAttributes)">
            <summary>
            Modify <see cref="F:dnlib.DotNet.GenericParam.attributes"/> property: <see cref="F:dnlib.DotNet.GenericParam.attributes"/> =
            (<see cref="F:dnlib.DotNet.GenericParam.attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
            </summary>
            <param name="andMask">Value to <c>AND</c></param>
            <param name="orMask">Value to OR</param>
        </member>
        <member name="M:dnlib.DotNet.GenericParam.ModifyAttributes(System.Boolean,dnlib.DotNet.GenericParamAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.GenericParam.attributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.Variance">
            <summary>
            Gets/sets variance (non, contra, co)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.IsNonVariant">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.GenericParamAttributes.NonVariant"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.IsCovariant">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.GenericParamAttributes.Covariant"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.IsContravariant">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.GenericParamAttributes.Contravariant"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.SpecialConstraint">
            <summary>
            Gets/sets the special constraint
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.HasNoSpecialConstraint">
            <summary>
            <c>true</c> if there are no special constraints
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.HasReferenceTypeConstraint">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.GenericParamAttributes.ReferenceTypeConstraint"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.HasNotNullableValueTypeConstraint">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.GenericParamAttributes.NotNullableValueTypeConstraint"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParam.HasDefaultConstructorConstraint">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.GenericParamAttributes.DefaultConstructorConstraint"/> bit
            </summary>
        </member>
        <member name="M:dnlib.DotNet.GenericParam.dnlib#Utils#IListListener{dnlib#DotNet#GenericParamConstraint}#OnLazyAdd(System.Int32,dnlib.DotNet.GenericParamConstraint@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericParam.dnlib#Utils#IListListener{dnlib#DotNet#GenericParamConstraint}#OnAdd(System.Int32,dnlib.DotNet.GenericParamConstraint)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericParam.dnlib#Utils#IListListener{dnlib#DotNet#GenericParamConstraint}#OnRemove(System.Int32,dnlib.DotNet.GenericParamConstraint)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericParam.dnlib#Utils#IListListener{dnlib#DotNet#GenericParamConstraint}#OnResize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericParam.dnlib#Utils#IListListener{dnlib#DotNet#GenericParamConstraint}#OnClear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericParam.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.GenericParamUser">
            <summary>
            A GenericParam row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.GenericParamUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.GenericParamUser.#ctor(System.UInt16)">
            <summary>
            Constructor
            </summary>
            <param name="number">The generic param number</param>
        </member>
        <member name="M:dnlib.DotNet.GenericParamUser.#ctor(System.UInt16,dnlib.DotNet.GenericParamAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="number">The generic param number</param>
            <param name="flags">Flags</param>
        </member>
        <member name="M:dnlib.DotNet.GenericParamUser.#ctor(System.UInt16,dnlib.DotNet.GenericParamAttributes,dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="number">The generic param number</param>
            <param name="flags">Flags</param>
            <param name="name">Name</param>
        </member>
        <member name="T:dnlib.DotNet.GenericParamMD">
            <summary>
            Created from a row in the GenericParam table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParamMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParamMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericParamMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericParamMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericParamMD.InitializeGenericParamConstraints">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericParamMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>GenericParam</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.GenericParamMD.OnLazyAdd2(System.Int32,dnlib.DotNet.GenericParamConstraint@)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.GenericParamAttributes">
            <summary>
            Generic parameter flags. See CorHdr.h/CorGenericParamAttr
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParamAttributes.VarianceMask">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.GenericParamAttributes.NonVariant">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.GenericParamAttributes.Covariant">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.GenericParamAttributes.Contravariant">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.GenericParamAttributes.SpecialConstraintMask">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.GenericParamAttributes.NoSpecialConstraint">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.GenericParamAttributes.ReferenceTypeConstraint">
            <summary>type argument must be a reference type</summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParamAttributes.NotNullableValueTypeConstraint">
            <summary>type argument must be a value type but not Nullable</summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParamAttributes.DefaultConstructorConstraint">
            <summary>type argument must have a public default constructor</summary>
        </member>
        <member name="T:dnlib.DotNet.GenericParamConstraint">
            <summary>
            A high-level representation of a row in the GenericParamConstraint table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParamConstraint.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParamConstraint.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParamConstraint.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParamConstraint.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParamConstraint.Owner">
            <summary>
            Gets the owner generic param
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParamConstraint.owner">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.GenericParamConstraint.Constraint">
            <summary>
            From column GenericParamConstraint.Constraint
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParamConstraint.constraint">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.GenericParamConstraint.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParamConstraint.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.GenericParamConstraint.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.GenericParamConstraint.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParamConstraint.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParamConstraint.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParamConstraint.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericParamConstraint.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParamConstraint.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.GenericParamConstraint.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.GenericParamConstraint.customDebugInfos"/></summary>
        </member>
        <member name="T:dnlib.DotNet.GenericParamConstraintUser">
            <summary>
            A GenericParamConstraintAssembly row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.GenericParamConstraintUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.GenericParamConstraintUser.#ctor(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="constraint">The constraint</param>
        </member>
        <member name="T:dnlib.DotNet.GenericParamConstraintMD">
            <summary>
            Created from a row in the GenericParamConstraint table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParamConstraintMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParamConstraintMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericParamConstraintMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericParamConstraintMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericParamConstraintMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>GenericParamConstraint</c> row</param>
            <param name="rid">Row ID</param>
            <param name="gpContext">Generic parameter context</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.GenericParamContext">
            <summary>
            Generic parameter context
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParamContext.Type">
            <summary>
            Type context
            </summary>
        </member>
        <member name="F:dnlib.DotNet.GenericParamContext.Method">
            <summary>
            Method context
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericParamContext.IsEmpty">
            <summary>
            true if <see cref="F:dnlib.DotNet.GenericParamContext.Type"/> and <see cref="F:dnlib.DotNet.GenericParamContext.Method"/> are both <c>null</c>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.GenericParamContext.Create(dnlib.DotNet.MethodDef)">
            <summary>
            Creates a new <see cref="T:dnlib.DotNet.GenericParamContext"/> instance and initializes the
            <see cref="F:dnlib.DotNet.GenericParamContext.Type"/> field to <paramref name="method"/>'s <see cref="P:dnlib.DotNet.MethodDef.DeclaringType"/>
            and the <see cref="F:dnlib.DotNet.GenericParamContext.Method"/> field to <paramref name="method"/>.
            </summary>
            <param name="method">Method</param>
            <returns>A new <see cref="T:dnlib.DotNet.GenericParamContext"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.GenericParamContext.Create(dnlib.DotNet.TypeDef)">
            <summary>
            Creates a new <see cref="T:dnlib.DotNet.GenericParamContext"/> instance and initializes the
            <see cref="F:dnlib.DotNet.GenericParamContext.Type"/> field to <paramref name="type"/> and the <see cref="F:dnlib.DotNet.GenericParamContext.Method"/> field
            to <c>null</c>
            </summary>
            <param name="type">Type</param>
            <returns>A new <see cref="T:dnlib.DotNet.GenericParamContext"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.GenericParamContext.#ctor(dnlib.DotNet.TypeDef)">
            <summary>
            Constructor
            </summary>
            <param name="type">Type context</param>
        </member>
        <member name="M:dnlib.DotNet.GenericParamContext.#ctor(dnlib.DotNet.MethodDef)">
            <summary>
            Constructor. The <see cref="F:dnlib.DotNet.GenericParamContext.Type"/> field is set to <c>null</c> and <c>NOT</c> to
            <paramref name="method"/>'s <see cref="P:dnlib.DotNet.MethodDef.DeclaringType"/>. Use
            <see cref="M:dnlib.DotNet.GenericParamContext.Create(dnlib.DotNet.MethodDef)"/> if you want that behavior.
            </summary>
            <param name="method">Method context</param>
        </member>
        <member name="M:dnlib.DotNet.GenericParamContext.#ctor(dnlib.DotNet.TypeDef,dnlib.DotNet.MethodDef)">
            <summary>
            Constructor
            </summary>
            <param name="type">Type context</param>
            <param name="method">Method context</param>
        </member>
        <member name="T:dnlib.DotNet.IAssemblyResolver">
            <summary>
            Resolves assemblies
            </summary>
        </member>
        <member name="M:dnlib.DotNet.IAssemblyResolver.Resolve(dnlib.DotNet.IAssembly,dnlib.DotNet.ModuleDef)">
            <summary>
            Finds and returns an <see cref="T:dnlib.DotNet.AssemblyDef"/>
            </summary>
            <param name="assembly">The assembly to find</param>
            <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
            <returns>An <see cref="T:dnlib.DotNet.AssemblyDef"/> instance owned by the assembly resolver or
            <c>null</c> if the assembly couldn't be found.</returns>
        </member>
        <member name="T:dnlib.DotNet.IMDTokenProvider">
            <summary>
            The table row can be referenced by a MD token
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMDTokenProvider.MDToken">
            <summary>
            Returns the metadata token
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMDTokenProvider.Rid">
            <summary>
            Gets/sets the row ID
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IMDTokenProviderMD">
            <summary>
            All <c>*MD</c> classes implement this interface.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMDTokenProviderMD.OrigRid">
            <summary>
            Gets the original row ID
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IAssembly">
            <summary>
            An assembly. Implemented by <see cref="T:dnlib.DotNet.AssemblyRef"/>, <see cref="T:dnlib.DotNet.AssemblyDef"/> and
            <see cref="T:dnlib.DotNet.AssemblyNameInfo"/>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.Version">
            <summary>
            The assembly version
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.Attributes">
            <summary>
            Assembly flags
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.PublicKeyOrToken">
            <summary>
            Public key or public key token
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.Culture">
            <summary>
            Locale, aka culture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.FullNameToken">
            <summary>
            Gets the full name of the assembly but use a public key token
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.HasPublicKey">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.PublicKey"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.ProcessorArchitecture">
            <summary>
            Gets/sets the processor architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.ProcessorArchitectureFull">
            <summary>
            Gets/sets the processor architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.IsProcessorArchitectureNone">
            <summary>
            <c>true</c> if unspecified processor architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.IsProcessorArchitectureMSIL">
            <summary>
            <c>true</c> if neutral (PE32) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.IsProcessorArchitectureX86">
            <summary>
            <c>true</c> if x86 (PE32) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.IsProcessorArchitectureIA64">
            <summary>
            <c>true</c> if IA-64 (PE32+) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.IsProcessorArchitectureX64">
            <summary>
            <c>true</c> if x64 (PE32+) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.IsProcessorArchitectureARM">
            <summary>
            <c>true</c> if ARM (PE32) architecture
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.IsProcessorArchitectureNoPlatform">
            <summary>
            <c>true</c> if eg. reference assembly (not runnable)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.IsProcessorArchitectureSpecified">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.PA_Specified"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.EnableJITcompileTracking">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.EnableJITcompileTracking"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.DisableJITcompileOptimizer">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.DisableJITcompileOptimizer"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.IsRetargetable">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.AssemblyAttributes.Retargetable"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.ContentType">
            <summary>
            Gets/sets the content type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.IsContentTypeDefault">
            <summary>
            <c>true</c> if content type is <c>Default</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IAssembly.IsContentTypeWindowsRuntime">
            <summary>
            <c>true</c> if content type is <c>WindowsRuntime</c>
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IManagedEntryPoint">
            <summary>
            Implemented by <see cref="T:dnlib.DotNet.MethodDef"/> and <see cref="T:dnlib.DotNet.FileDef"/>, which are the only
            valid managed entry point tokens.
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IModule">
            <summary>
            Interface to access a module def/ref
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ScopeType">
            <summary>
            Type of scope
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ScopeType.AssemblyRef">
            <summary>
            It's an <see cref="T:dnlib.DotNet.AssemblyRef"/> instance
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ScopeType.ModuleRef">
            <summary>
            It's a <see cref="T:dnlib.DotNet.ModuleRef"/> instance
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ScopeType.ModuleDef">
            <summary>
            It's a <see cref="T:dnlib.DotNet.ModuleDef"/> instance
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IScope">
            <summary>
            Implemented by modules and assemblies
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IScope.ScopeType">
            <summary>
            Gets the scope type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IScope.ScopeName">
            <summary>
            Gets the scope name
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IFullName">
            <summary>
            Interface to get the full name of a type, field, or method
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IFullName.FullName">
            <summary>
            Gets the full name
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IFullName.Name">
            <summary>
            Simple name of implementer
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IOwnerModule">
            <summary>
            Implemented by all member refs and types
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IOwnerModule.Module">
            <summary>
            Gets the owner module
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IIsTypeOrMethod">
            <summary>
            Methods to check whether the implementer is a type or a method.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IIsTypeOrMethod.IsType">
            <summary>
            <c>true</c> if it's a type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IIsTypeOrMethod.IsMethod">
            <summary>
            <c>true</c> if it's a method
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IMemberRef">
            <summary>
            Implemented by types, fields, methods, properties, events
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberRef.DeclaringType">
            <summary>
            Gets the declaring type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberRef.IsField">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.FieldDef"/> or a <see cref="T:dnlib.DotNet.MemberRef"/> that's
            referencing a field.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberRef.IsTypeSpec">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.TypeSpec"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberRef.IsTypeRef">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberRef.IsTypeDef">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberRef.IsMethodSpec">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.MethodSpec"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberRef.IsMethodDef">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.MethodDef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberRef.IsMemberRef">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberRef.IsFieldDef">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.FieldDef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberRef.IsPropertyDef">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.PropertyDef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberRef.IsEventDef">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.EventDef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberRef.IsGenericParam">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.GenericParam"/>
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IMemberDef">
            <summary>
            All member definitions implement this interface: <see cref="T:dnlib.DotNet.TypeDef"/>,
            <see cref="T:dnlib.DotNet.FieldDef"/>, <see cref="T:dnlib.DotNet.MethodDef"/>, <see cref="T:dnlib.DotNet.EventDef"/>,
            <see cref="T:dnlib.DotNet.PropertyDef"/>, and <see cref="T:dnlib.DotNet.GenericParam"/>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberDef.DeclaringType">
            <summary>
            Gets the declaring type
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IDnlibDef">
            <summary>
            Implemented by the following classes: <see cref="T:dnlib.DotNet.TypeDef"/>,
            <see cref="T:dnlib.DotNet.FieldDef"/>, <see cref="T:dnlib.DotNet.MethodDef"/>, <see cref="T:dnlib.DotNet.EventDef"/>,
            <see cref="T:dnlib.DotNet.PropertyDef"/>, <see cref="T:dnlib.DotNet.GenericParam"/>, <see cref="T:dnlib.DotNet.AssemblyDef"/>,
            and <see cref="T:dnlib.DotNet.ModuleDef"/>
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IGenericParameterProvider">
            <summary>
            Implemented by types and methods
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IGenericParameterProvider.NumberOfGenericParameters">
            <summary>
            Gets the number of generic parameters / arguments
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IField">
            <summary>
            Implemented by fields (<see cref="T:dnlib.DotNet.FieldDef"/> and <see cref="T:dnlib.DotNet.MemberRef"/>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IField.FieldSig">
            <summary>
            Gets/sets the field signature
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IMethod">
            <summary>
            Implemented by methods (<see cref="T:dnlib.DotNet.MethodDef"/>, <see cref="T:dnlib.DotNet.MemberRef"/> and <see cref="T:dnlib.DotNet.MethodSpec"/>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMethod.MethodSig">
            <summary>
            Method signature
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ITokenOperand">
            <summary>
            Implemented by tables that can be a token in the <c>ldtoken</c> instruction
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ICodedToken">
            <summary>
            The table row can be referenced by a coded token
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ITypeDefOrRef">
            <summary>
            TypeDefOrRef coded token interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ITypeDefOrRef.TypeDefOrRefTag">
            <summary>
            The coded token tag
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IHasConstant">
            <summary>
            HasConstant coded token interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasConstant.HasConstantTag">
            <summary>
            The coded token tag
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasConstant.Constant">
            <summary>
            Gets/sets the constant value
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IHasCustomAttribute">
            <summary>
            HasCustomAttribute coded token interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasCustomAttribute.HasCustomAttributeTag">
            <summary>
            The coded token tag
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasCustomAttribute.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasCustomAttribute.HasCustomAttributes">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.IHasCustomAttribute.CustomAttributes"/> is not empty
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IHasFieldMarshal">
            <summary>
            HasFieldMarshal coded token interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasFieldMarshal.HasFieldMarshalTag">
            <summary>
            The coded token tag
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasFieldMarshal.MarshalType">
            <summary>
            Gets/sets the marshal type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasFieldMarshal.HasMarshalType">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.IHasFieldMarshal.MarshalType"/> is not <c>null</c>
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IHasDeclSecurity">
            <summary>
            HasDeclSecurity coded token interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasDeclSecurity.HasDeclSecurityTag">
            <summary>
            The coded token tag
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasDeclSecurity.DeclSecurities">
            <summary>
            Gets the permission sets
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasDeclSecurity.HasDeclSecurities">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.IHasDeclSecurity.DeclSecurities"/> is not empty
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IMemberRefParent">
            <summary>
            MemberRefParent coded token interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberRefParent.MemberRefParentTag">
            <summary>
            The coded token tag
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IHasSemantic">
            <summary>
            HasSemantic coded token interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasSemantic.HasSemanticTag">
            <summary>
            The coded token tag
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IMethodDefOrRef">
            <summary>
            MethodDefOrRef coded token interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMethodDefOrRef.MethodDefOrRefTag">
            <summary>
            The coded token tag
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IMemberForwarded">
            <summary>
            MemberForwarded coded token interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberForwarded.MemberForwardedTag">
            <summary>
            The coded token tag
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberForwarded.ImplMap">
            <summary>
            Gets/sets the impl map
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IMemberForwarded.HasImplMap">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.IMemberForwarded.ImplMap"/> is not <c>null</c>
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IImplementation">
            <summary>
            Implementation coded token interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IImplementation.ImplementationTag">
            <summary>
            The coded token tag
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ICustomAttributeType">
            <summary>
            CustomAttributeType coded token interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICustomAttributeType.CustomAttributeTypeTag">
            <summary>
            The coded token tag
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IResolutionScope">
            <summary>
            ResolutionScope coded token interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IResolutionScope.ResolutionScopeTag">
            <summary>
            The coded token tag
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ITypeOrMethodDef">
            <summary>
            TypeOrMethodDef coded token interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ITypeOrMethodDef.TypeOrMethodDefTag">
            <summary>
            The coded token tag
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ITypeOrMethodDef.GenericParameters">
            <summary>
            Gets the generic parameters
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ITypeOrMethodDef.HasGenericParameters">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ITypeOrMethodDef.GenericParameters"/> is not empty
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IHasCustomDebugInformation">
            <summary>
            HasCustomDebugInformation interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasCustomDebugInformation.HasCustomDebugInformationTag">
            <summary>
            The custom debug information tag
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasCustomDebugInformation.CustomDebugInfos">
            <summary>
            Gets the custom debug infos
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IHasCustomDebugInformation.HasCustomDebugInfos">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.IHasCustomDebugInformation.CustomDebugInfos"/> is not empty
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ICorLibTypes">
            <summary>
            Access to .NET core library's simple types
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.Void">
            <summary>
            Gets a <c>System.Void</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.Boolean">
            <summary>
            Gets a <c>System.Boolean</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.Char">
            <summary>
            Gets a <c>System.Char</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.SByte">
            <summary>
            Gets a <c>System.SByte</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.Byte">
            <summary>
            Gets a <c>System.Byte</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.Int16">
            <summary>
            Gets a <c>System.Int16</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.UInt16">
            <summary>
            Gets a <c>System.UInt16</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.Int32">
            <summary>
            Gets a <c>System.Int32</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.UInt32">
            <summary>
            Gets a <c>System.UInt32</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.Int64">
            <summary>
            Gets a <c>System.Int64</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.UInt64">
            <summary>
            Gets a <c>System.UInt64</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.Single">
            <summary>
            Gets a <c>System.Single</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.Double">
            <summary>
            Gets a <c>System.Double</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.String">
            <summary>
            Gets a <c>System.String</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.TypedReference">
            <summary>
            Gets a <c>System.TypedReference</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.IntPtr">
            <summary>
            Gets a <c>System.IntPtr</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.UIntPtr">
            <summary>
            Gets a <c>System.UIntPtr</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.Object">
            <summary>
            Gets a <c>System.Object</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICorLibTypes.AssemblyRef">
            <summary>
            Gets the assembly reference to the core library
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ICorLibTypes.GetTypeRef(System.String,System.String)">
            <summary>
            Gets a <see cref="T:dnlib.DotNet.TypeRef"/> that references a type in the core library assembly
            </summary>
            <param name="namespace">Namespace of type (eg. "System")</param>
            <param name="name">Name of type</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeRef"/> instance. This instance may be a cached instance.</returns>
        </member>
        <member name="T:dnlib.DotNet.ICustomAttribute">
            <summary>
            Custom attribute interface. Implemented by <see cref="T:dnlib.DotNet.SecurityAttribute"/> and
            <see cref="T:dnlib.DotNet.CustomAttribute"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICustomAttribute.AttributeType">
            <summary>
            Gets the attribute type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICustomAttribute.TypeFullName">
            <summary>
            Gets the full name of the attribute type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICustomAttribute.NamedArguments">
            <summary>
            Gets all named arguments (field and property values)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICustomAttribute.HasNamedArguments">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ICustomAttribute.NamedArguments"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICustomAttribute.Fields">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.CANamedArgument"/>s that are field arguments
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ICustomAttribute.Properties">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.CANamedArgument"/>s that are property arguments
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IMethodDecrypter">
            <summary>
            Interface to decrypt methods
            </summary>
        </member>
        <member name="M:dnlib.DotNet.IMethodDecrypter.GetMethodBody(System.UInt32,dnlib.PE.RVA,System.Collections.Generic.IList{dnlib.DotNet.Parameter},dnlib.DotNet.GenericParamContext,dnlib.DotNet.Emit.MethodBody@)">
            <summary>
            Gets the method's body
            </summary>
            <param name="rid"><c>Method</c> rid</param>
            <param name="rva">The <see cref="T:dnlib.PE.RVA"/> found in the method's <c>Method</c> row</param>
            <param name="parameters">The method's parameters</param>
            <param name="gpContext">Generic parameter context</param>
            <param name="methodBody">Updated with the method's <see cref="T:dnlib.DotNet.Emit.MethodBody"/> if this
            method returns <c>true</c></param>
            <returns><c>true</c> if the method body was decrypted, <c>false</c> if the method isn't
            encrypted and the default <see cref="T:dnlib.DotNet.MethodDef"/> body reader code should be used.</returns>
        </member>
        <member name="T:dnlib.DotNet.IStringDecrypter">
            <summary>
            Interface to decrypt strings
            </summary>
        </member>
        <member name="M:dnlib.DotNet.IStringDecrypter.ReadUserString(System.UInt32)">
            <summary>
            Reads a string
            </summary>
            <param name="token">String token</param>
            <returns>A string or <c>null</c> if we should read it from the #US heap</returns>
        </member>
        <member name="T:dnlib.DotNet.LoggerEvent">
            <summary>
            <see cref="T:dnlib.DotNet.ILogger"/> events
            </summary>
        </member>
        <member name="F:dnlib.DotNet.LoggerEvent.Error">
            <summary>
            An error was detected. An exception should normally be thrown but the error
            can be ignored.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.LoggerEvent.Warning">
            <summary>
            Just a warning and can be ignored.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.LoggerEvent.Info">
            <summary>
            A normal message
            </summary>
        </member>
        <member name="F:dnlib.DotNet.LoggerEvent.Verbose">
            <summary>
            A verbose message
            </summary>
        </member>
        <member name="F:dnlib.DotNet.LoggerEvent.VeryVerbose">
            <summary>
            A very verbose message
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ILogger">
            <summary>
            Simple logger
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ILogger.Log(System.Object,dnlib.DotNet.LoggerEvent,System.String,System.Object[])">
            <summary>
            Log something
            </summary>
            <param name="sender">Caller or <c>null</c></param>
            <param name="loggerEvent">Logger event</param>
            <param name="format">Format</param>
            <param name="args">Arguments</param>
        </member>
        <member name="M:dnlib.DotNet.ILogger.IgnoresEvent(dnlib.DotNet.LoggerEvent)">
            <summary>
            <c>true</c> if this event is ignored. If the event is ignored, the caller can
            choose not to call <see cref="M:dnlib.DotNet.ILogger.Log(System.Object,dnlib.DotNet.LoggerEvent,System.String,System.Object[])"/>. This is useful if it can take time to
            prepare the message.
            </summary>
            <param name="loggerEvent">The logger event</param>
        </member>
        <member name="T:dnlib.DotNet.DummyLogger">
            <summary>
            Dummy logger which ignores all messages, but can optionally throw on errors.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.DummyLogger.NoThrowInstance">
            <summary>
            It ignores everything and doesn't throw anything.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.DummyLogger.ThrowModuleWriterExceptionOnErrorInstance">
            <summary>
            Throws a <see cref="T:dnlib.DotNet.Writer.ModuleWriterException"/> on errors, but ignores anything else.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.DummyLogger.#ctor(System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="exceptionToThrow">If non-<c>null</c>, this exception type is thrown on
            errors. It must have a public constructor that takes a <see cref="T:System.String"/> as the only
            argument.</param>
        </member>
        <member name="M:dnlib.DotNet.DummyLogger.Log(System.Object,dnlib.DotNet.LoggerEvent,System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.DummyLogger.IgnoresEvent(dnlib.DotNet.LoggerEvent)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.ImplMap">
            <summary>
            A high-level representation of a row in the ImplMap table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ImplMap.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.Attributes">
            <summary>
            From column ImplMap.MappingFlags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ImplMap.attributes">
            <summary>Attributes</summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.Name">
            <summary>
            From column ImplMap.ImportName
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ImplMap.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.Module">
            <summary>
            From column ImplMap.ImportScope
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ImplMap.module">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ImplMap.ModifyAttributes(dnlib.DotNet.PInvokeAttributes,dnlib.DotNet.PInvokeAttributes)">
            <summary>
            Modify <see cref="F:dnlib.DotNet.ImplMap.attributes"/> property: <see cref="F:dnlib.DotNet.ImplMap.attributes"/> =
            (<see cref="F:dnlib.DotNet.ImplMap.attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
            </summary>
            <param name="andMask">Value to <c>AND</c></param>
            <param name="orMask">Value to OR</param>
        </member>
        <member name="M:dnlib.DotNet.ImplMap.ModifyAttributes(System.Boolean,dnlib.DotNet.PInvokeAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.ImplMap.attributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsNoMangle">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.PInvokeAttributes.NoMangle"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.CharSet">
            <summary>
            Gets/sets the char set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsCharSetNotSpec">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.CharSetNotSpec"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsCharSetAnsi">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.CharSetAnsi"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsCharSetUnicode">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.CharSetUnicode"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsCharSetAuto">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.CharSetAuto"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.BestFit">
            <summary>
            Gets/sets best fit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsBestFitUseAssem">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.BestFitUseAssem"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsBestFitEnabled">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.BestFitEnabled"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsBestFitDisabled">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.BestFitDisabled"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.ThrowOnUnmappableChar">
            <summary>
            Gets/sets throw on unmappable char
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsThrowOnUnmappableCharUseAssem">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.ThrowOnUnmappableCharUseAssem"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsThrowOnUnmappableCharEnabled">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.ThrowOnUnmappableCharEnabled"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsThrowOnUnmappableCharDisabled">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.ThrowOnUnmappableCharDisabled"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.SupportsLastError">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.PInvokeAttributes.SupportsLastError"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.CallConv">
            <summary>
            Gets/sets calling convention
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsCallConvWinapi">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.CallConvWinapi"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsCallConvCdecl">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.CallConvCdecl"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsCallConvStdcall">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.CallConvStdcall"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsCallConvThiscall">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.CallConvThiscall"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMap.IsCallConvFastcall">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.PInvokeAttributes.CallConvFastcall"/> is set
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ImplMap.IsPinvokeMethod(System.String,System.String)">
            <summary>
            Checks whether this <see cref="T:dnlib.DotNet.ImplMap"/> is a certain P/Invoke method
            </summary>
            <param name="dllName">Name of the DLL</param>
            <param name="funcName">Name of the function within the DLL</param>
            <returns><c>true</c> if it's the specified P/Invoke method, else <c>false</c></returns>
        </member>
        <member name="T:dnlib.DotNet.ImplMapUser">
            <summary>
            An ImplMap row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ImplMapUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ImplMapUser.#ctor(dnlib.DotNet.ModuleRef,dnlib.DotNet.UTF8String,dnlib.DotNet.PInvokeAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="scope">Scope</param>
            <param name="name">Name</param>
            <param name="flags">Flags</param>
        </member>
        <member name="T:dnlib.DotNet.ImplMapMD">
            <summary>
            Created from a row in the ImplMap table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ImplMapMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ImplMapMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>ImplMap</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.ImporterOptions">
            <summary>
            <see cref="T:dnlib.DotNet.Importer"/> options
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ImporterOptions.TryToUseTypeDefs">
            <summary>
            Use <see cref="T:dnlib.DotNet.TypeDef"/>s whenever possible if the <see cref="T:dnlib.DotNet.TypeDef"/> is located
            in this module.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ImporterOptions.TryToUseMethodDefs">
            <summary>
            Use <see cref="T:dnlib.DotNet.MethodDef"/>s whenever possible if the <see cref="T:dnlib.DotNet.MethodDef"/> is located
            in this module.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ImporterOptions.TryToUseFieldDefs">
            <summary>
            Use <see cref="T:dnlib.DotNet.FieldDef"/>s whenever possible if the <see cref="T:dnlib.DotNet.FieldDef"/> is located
            in this module.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ImporterOptions.TryToUseDefs">
            <summary>
            Use <see cref="T:dnlib.DotNet.TypeDef"/>s, <see cref="T:dnlib.DotNet.MethodDef"/>s and <see cref="T:dnlib.DotNet.FieldDef"/>s
            whenever possible if the definition is located in this module.
            </summary>
            <seealso cref="F:dnlib.DotNet.ImporterOptions.TryToUseTypeDefs"/>
            <seealso cref="F:dnlib.DotNet.ImporterOptions.TryToUseMethodDefs"/>
            <seealso cref="F:dnlib.DotNet.ImporterOptions.TryToUseFieldDefs"/>
        </member>
        <member name="F:dnlib.DotNet.ImporterOptions.FixSignature">
            <summary>
            Don't set this flag. For internal use only.
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ImportMapper">
            <summary>
            Re-maps entities that were renamed in the target module
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ImportMapper.Map(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Matches source <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> to the one that is already present in the target module under a different name.
            </summary>
            <param name="source"><see cref="T:dnlib.DotNet.ITypeDefOrRef"/> referenced by the entity that is being imported.</param>
            <returns>matching <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> or <c>null</c> if there's no match.</returns>
        </member>
        <member name="M:dnlib.DotNet.ImportMapper.Map(dnlib.DotNet.FieldDef)">
            <summary>
            Matches source <see cref="T:dnlib.DotNet.FieldDef"/> to the one that is already present in the target module under a different name.
            </summary>
            <param name="source"><see cref="T:dnlib.DotNet.FieldDef"/> referenced by the entity that is being imported.</param>
            <returns>matching <see cref="T:dnlib.DotNet.IField"/> or <c>null</c> if there's no match.</returns>
        </member>
        <member name="M:dnlib.DotNet.ImportMapper.Map(dnlib.DotNet.MethodDef)">
            <summary>
            Matches source <see cref="T:dnlib.DotNet.MethodDef"/> to the one that is already present in the target module under a different name.
            </summary>
            <param name="source"><see cref="T:dnlib.DotNet.MethodDef"/> referenced by the entity that is being imported.</param>
            <returns>matching <see cref="T:dnlib.DotNet.IMethod"/> or <c>null</c> if there's no match.</returns>
        </member>
        <member name="M:dnlib.DotNet.ImportMapper.Map(dnlib.DotNet.MemberRef)">
            <summary>
            Matches source <see cref="T:dnlib.DotNet.MemberRef"/> to the one that is already present in the target module under a different name.
            </summary>
            <param name="source"><see cref="T:dnlib.DotNet.MemberRef"/> referenced by the entity that is being imported.</param>
            <returns>matching <see cref="T:dnlib.DotNet.MemberRef"/> or <c>null</c> if there's no match.</returns>
        </member>
        <member name="M:dnlib.DotNet.ImportMapper.Map(System.Type)">
            <summary>
            Overrides default behavior of <see cref="M:dnlib.DotNet.Importer.Import(System.Type)"/>
            May be used to use reference assemblies for <see cref="T:System.Type"/> resolution, for example.
            </summary>
            <param name="source"><see cref="T:System.Type"/> to create <see cref="T:dnlib.DotNet.TypeRef"/> for.</param>
            <returns><see cref="T:dnlib.DotNet.TypeRef"/> or null to use default <see cref="T:dnlib.DotNet.Importer"/>'s type resolution</returns>
        </member>
        <member name="T:dnlib.DotNet.Importer">
            <summary>
            Imports <see cref="T:System.Type"/>s, <see cref="T:System.Reflection.ConstructorInfo"/>s, <see cref="T:System.Reflection.MethodInfo"/>s
            and <see cref="T:System.Reflection.FieldInfo"/>s as references
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Importer.#ctor(dnlib.DotNet.ModuleDef)">
            <summary>
            Constructor
            </summary>
            <param name="module">The module that will own all references</param>
        </member>
        <member name="M:dnlib.DotNet.Importer.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="module">The module that will own all references</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.Importer.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.ImporterOptions)">
            <summary>
            Constructor
            </summary>
            <param name="module">The module that will own all references</param>
            <param name="options">Importer options</param>
        </member>
        <member name="M:dnlib.DotNet.Importer.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.ImporterOptions,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="module">The module that will own all references</param>
            <param name="options">Importer options</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.Importer.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.ImporterOptions,dnlib.DotNet.GenericParamContext,dnlib.DotNet.ImportMapper)">
            <summary>
            Constructor
            </summary>
            <param name="module">The module that will own all references</param>
            <param name="options">Importer options</param>
            <param name="gpContext">Generic parameter context</param>
            <param name="mapper">Mapper for renamed entities</param>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(System.Type)">
            <summary>
            Imports a <see cref="T:System.Type"/> as a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(System.Type,System.Collections.Generic.IList{System.Type},System.Collections.Generic.IList{System.Type})">
            <summary>
            Imports a <see cref="T:System.Type"/> as a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="type">The type</param>
            <param name="requiredModifiers">A list of all required modifiers or <c>null</c></param>
            <param name="optionalModifiers">A list of all optional modifiers or <c>null</c></param>
            <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.ImportAsTypeSig(System.Type)">
            <summary>
            Imports a <see cref="T:System.Type"/> as a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.ImportAsTypeSig(System.Type,System.Collections.Generic.IList{System.Type},System.Collections.Generic.IList{System.Type})">
            <summary>
            Imports a <see cref="T:System.Type"/> as a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="type">The type</param>
            <param name="requiredModifiers">A list of all required modifiers or <c>null</c></param>
            <param name="optionalModifiers">A list of all optional modifiers or <c>null</c></param>
            <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(System.Reflection.MethodBase)">
            <summary>
            Imports a <see cref="T:System.Reflection.MethodBase"/> as a <see cref="T:dnlib.DotNet.IMethod"/>. This will be either
            a <see cref="T:dnlib.DotNet.MemberRef"/> or a <see cref="T:dnlib.DotNet.MethodSpec"/>.
            </summary>
            <param name="methodBase">The method</param>
            <returns>The imported method or <c>null</c> if <paramref name="methodBase"/> is invalid
            or if we failed to import the method</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(System.Reflection.MethodBase,System.Boolean)">
            <summary>
            Imports a <see cref="T:System.Reflection.MethodBase"/> as a <see cref="T:dnlib.DotNet.IMethod"/>. This will be either
            a <see cref="T:dnlib.DotNet.MemberRef"/> or a <see cref="T:dnlib.DotNet.MethodSpec"/>.
            </summary>
            <param name="methodBase">The method</param>
            <param name="forceFixSignature">Always verify method signature to make sure the
            returned reference matches the metadata in the source assembly</param>
            <returns>The imported method or <c>null</c> if <paramref name="methodBase"/> is invalid
            or if we failed to import the method</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(System.Reflection.FieldInfo)">
            <summary>
            Imports a <see cref="T:System.Reflection.FieldInfo"/> as a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
            <param name="fieldInfo">The field</param>
            <returns>The imported field or <c>null</c> if <paramref name="fieldInfo"/> is invalid
            or if we failed to import the field</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Imports a <see cref="T:System.Reflection.FieldInfo"/> as a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
            <param name="fieldInfo">The field</param>
            <param name="forceFixSignature">Always verify field signature to make sure the
            returned reference matches the metadata in the source assembly</param>
            <returns>The imported field or <c>null</c> if <paramref name="fieldInfo"/> is invalid
            or if we failed to import the field</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.IType)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.IType"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.TypeDef)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.TypeDef"/> as a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.TypeRef)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.TypeSpec)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.TypeSpec"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.TypeSig)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.CallingConventionSig)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.CallingConventionSig"/>
            </summary>
            <param name="sig">The sig</param>
            <returns>The imported sig or <c>null</c> if input is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.FieldSig)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.FieldSig"/>
            </summary>
            <param name="sig">The sig</param>
            <returns>The imported sig or <c>null</c> if input is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.MethodSig)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.MethodSig"/>
            </summary>
            <param name="sig">The sig</param>
            <returns>The imported sig or <c>null</c> if input is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.PropertySig)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.PropertySig"/>
            </summary>
            <param name="sig">The sig</param>
            <returns>The imported sig or <c>null</c> if input is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.LocalSig)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.LocalSig"/>
            </summary>
            <param name="sig">The sig</param>
            <returns>The imported sig or <c>null</c> if input is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.GenericInstMethodSig)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.GenericInstMethodSig"/>
            </summary>
            <param name="sig">The sig</param>
            <returns>The imported sig or <c>null</c> if input is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.IField)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.IField"/>
            </summary>
            <param name="field">The field</param>
            <returns>The imported type or <c>null</c> if <paramref name="field"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.IMethod)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.IMethod"/>
            </summary>
            <param name="method">The method</param>
            <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.FieldDef)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.FieldDef"/> as an <see cref="T:dnlib.DotNet.IField"/>
            </summary>
            <param name="field">The field</param>
            <returns>The imported type or <c>null</c> if <paramref name="field"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.MethodDef)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.MethodDef"/> as an <see cref="T:dnlib.DotNet.IMethod"/>
            </summary>
            <param name="method">The method</param>
            <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.MethodSpec)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.MethodSpec"/>
            </summary>
            <param name="method">The method</param>
            <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Importer.Import(dnlib.DotNet.MemberRef)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
            <param name="memberRef">The member ref</param>
            <returns>The imported member ref or <c>null</c> if <paramref name="memberRef"/> is invalid</returns>
        </member>
        <member name="T:dnlib.DotNet.InterfaceImpl">
            <summary>
            A high-level representation of a row in the InterfaceImpl table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.InterfaceImpl.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.InterfaceImpl.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.InterfaceImpl.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.InterfaceImpl.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.InterfaceImpl.Interface">
            <summary>
            From column InterfaceImpl.Interface
            </summary>
        </member>
        <member name="F:dnlib.DotNet.InterfaceImpl.interface">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.InterfaceImpl.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.InterfaceImpl.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.InterfaceImpl.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.InterfaceImpl.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.InterfaceImpl.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.InterfaceImpl.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.InterfaceImpl.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.InterfaceImpl.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.InterfaceImpl.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.InterfaceImpl.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.InterfaceImpl.customDebugInfos"/></summary>
        </member>
        <member name="T:dnlib.DotNet.InterfaceImplUser">
            <summary>
            An InterfaceImpl row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.InterfaceImplUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.InterfaceImplUser.#ctor(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="interface">The interface the type implements</param>
        </member>
        <member name="T:dnlib.DotNet.InterfaceImplMD">
            <summary>
            Created from a row in the InterfaceImpl table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.InterfaceImplMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.InterfaceImplMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.InterfaceImplMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.InterfaceImplMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.InterfaceImplMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>InterfaceImpl</c> row</param>
            <param name="rid">Row ID</param>
            <param name="gpContext">Generic parameter context</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.IResolver">
            <summary>
            Resolves types, methods, fields
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ITypeResolver">
            <summary>
            Resolves types
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ITypeResolver.Resolve(dnlib.DotNet.TypeRef,dnlib.DotNet.ModuleDef)">
            <summary>
            Resolves a type
            </summary>
            <param name="typeRef">The type</param>
            <param name="sourceModule">The module that needs to resolve the type or <c>null</c></param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
        </member>
        <member name="T:dnlib.DotNet.IMemberRefResolver">
            <summary>
            Resolves fields and methods
            </summary>
        </member>
        <member name="M:dnlib.DotNet.IMemberRefResolver.Resolve(dnlib.DotNet.MemberRef)">
            <summary>
            Resolves a method or a field
            </summary>
            <param name="memberRef">A method/field reference</param>
            <returns>A <see cref="T:dnlib.DotNet.MethodDef"/> or a <see cref="T:dnlib.DotNet.FieldDef"/> instance or <c>null</c>
            if it couldn't be resolved.</returns>
        </member>
        <member name="T:dnlib.DotNet.ITokenResolver">
            <summary>
            Resolves tokens
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ITokenResolver.ResolveToken(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a token
            </summary>
            <param name="token">The metadata token</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
        </member>
        <member name="T:dnlib.DotNet.IType">
            <summary>
            Interface to get the full name of a type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IType.IsValueType">
            <summary>
            <c>true</c> if it's a value type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IType.TypeName">
            <summary>
            Returns the name of this type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IType.ReflectionName">
            <summary>
            Returns the reflection name of this type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IType.Namespace">
            <summary>
            Returns the namespace of this type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IType.ReflectionNamespace">
            <summary>
            Returns the reflection namespace of this type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IType.ReflectionFullName">
            <summary>
            Returns the reflection name of this type. See also <see cref="P:dnlib.DotNet.IType.AssemblyQualifiedName"/>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IType.AssemblyQualifiedName">
            <summary>
            Returns the reflection name of this type, and includes the assembly name where the
            type is located. It can be passed to <see cref="M:System.Type.GetType(System.String)"/> to
            load the type.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IType.DefinitionAssembly">
            <summary>
            Gets the assembly where this type is defined
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IType.Scope">
            <summary>
            Gets the scope, which is different from <see cref="P:dnlib.DotNet.IType.DefinitionAssembly"/> since it
            can differentiate between modules within the same assembly.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IType.ScopeType">
            <summary>
            Gets the type whose scope is returned by <see cref="P:dnlib.DotNet.IType.Scope"/> and whose assembly
            is returned by <see cref="P:dnlib.DotNet.IType.DefinitionAssembly"/>. This is always a
            <see cref="T:dnlib.DotNet.TypeDef"/>, <see cref="T:dnlib.DotNet.TypeRef"/> or <c>null</c>. It can also be a
            nested <see cref="T:dnlib.DotNet.TypeRef"/>.
            For example, if this type is a System.String&amp;, then this value is a System.String.
            If it's a generic instance type (eg. List&lt;int&gt;), then the generic type is
            returned (eg. List&lt;T&gt;). In other words, the first <see cref="T:dnlib.DotNet.TypeDef"/> or
            <see cref="T:dnlib.DotNet.TypeRef"/> that is found (without searching generic arguments) is returned.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IType.IsPrimitive">
            <summary>
            <c>true</c> if it's an integer or a floating point type
            </summary>
        </member>
        <member name="T:dnlib.DotNet.IContainsGenericParameter">
            <summary>
            Implemented by types and calling convention signatures.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IContainsGenericParameter.ContainsGenericParameter">
            <summary>
            <c>true</c> if this contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ITypeDefFinder">
            <summary>
            Finds <see cref="T:dnlib.DotNet.TypeDef"/>s
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ITypeDefFinder.Find(System.String,System.Boolean)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="fullName">Full name of the type (no assembly information)</param>
            <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
            type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
            are separated by a <c>/</c> character.</param>
            <returns>An existing <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if it wasn't found.</returns>
        </member>
        <member name="M:dnlib.DotNet.ITypeDefFinder.Find(dnlib.DotNet.TypeRef)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeDef"/>. <paramref name="typeRef"/>'s scope (i.e., module or
            assembly) is ignored when looking up the type.
            </summary>
            <param name="typeRef">The type ref</param>
            <returns>An existing <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if it wasn't found.</returns>
        </member>
        <member name="T:dnlib.DotNet.IVariable">
            <summary>
            Interface to access a local or a parameter
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IVariable.Type">
            <summary>
            Gets the variable type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IVariable.Index">
            <summary>
            Gets the 0-based position
            </summary>
        </member>
        <member name="P:dnlib.DotNet.IVariable.Name">
            <summary>
            Gets/sets the variable name
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ManifestResource">
            <summary>
            A high-level representation of a row in the ManifestResource table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ManifestResource.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.Offset">
            <summary>
            From column ManifestResource.Offset
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ManifestResource.offset">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.Flags">
            <summary>
            From column ManifestResource.Flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ManifestResource.attributes">
            <summary>Attributes</summary>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.Name">
            <summary>
            From column ManifestResource.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ManifestResource.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.Implementation">
            <summary>
            From column ManifestResource.Implementation
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ManifestResource.implementation">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ManifestResource.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ManifestResource.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.ManifestResource.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ManifestResource.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ManifestResource.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.ManifestResource.customDebugInfos"/></summary>
        </member>
        <member name="M:dnlib.DotNet.ManifestResource.ModifyAttributes(dnlib.DotNet.ManifestResourceAttributes,dnlib.DotNet.ManifestResourceAttributes)">
            <summary>
            Modify <see cref="F:dnlib.DotNet.ManifestResource.attributes"/> property: <see cref="F:dnlib.DotNet.ManifestResource.attributes"/> =
            (<see cref="F:dnlib.DotNet.ManifestResource.attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
            </summary>
            <param name="andMask">Value to <c>AND</c></param>
            <param name="orMask">Value to OR</param>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.Visibility">
            <summary>
            Gets/sets the visibility
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.IsPublic">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.ManifestResourceAttributes.Public"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ManifestResource.IsPrivate">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.ManifestResourceAttributes.Private"/> is set
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ManifestResourceUser">
            <summary>
            A ManifestResource row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ManifestResourceUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ManifestResourceUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.IImplementation)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
            <param name="implementation">Implementation</param>
        </member>
        <member name="M:dnlib.DotNet.ManifestResourceUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.IImplementation,dnlib.DotNet.ManifestResourceAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
            <param name="implementation">Implementation</param>
            <param name="flags">Flags</param>
        </member>
        <member name="M:dnlib.DotNet.ManifestResourceUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.IImplementation,dnlib.DotNet.ManifestResourceAttributes,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
            <param name="implementation">Implementation</param>
            <param name="flags">Flags</param>
            <param name="offset">Offset</param>
        </member>
        <member name="T:dnlib.DotNet.ManifestResourceMD">
            <summary>
            Created from a row in the ManifestResource table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ManifestResourceMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.ManifestResourceMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ManifestResourceMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ManifestResourceMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ManifestResourceMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>ManifestResource</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.ManifestResourceAttributes">
            <summary>
            ManifestResource flags. See CorHdr.h/CorManifestResourceFlags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ManifestResourceAttributes.VisibilityMask">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.ManifestResourceAttributes.Public">
            <summary>The Resource is exported from the Assembly.</summary>
        </member>
        <member name="F:dnlib.DotNet.ManifestResourceAttributes.Private">
            <summary>The Resource is private to the Assembly.</summary>
        </member>
        <member name="T:dnlib.DotNet.MarshalBlobReader">
            <summary>
            Reads <see cref="T:dnlib.DotNet.MarshalType"/>s
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MarshalBlobReader.Read(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.MarshalType"/> from the <c>#Blob</c> heap
            </summary>
            <param name="module">Module</param>
            <param name="sig">Blob offset</param>
            <returns>A new <see cref="T:dnlib.DotNet.MarshalType"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MarshalBlobReader.Read(dnlib.DotNet.ModuleDefMD,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.MarshalType"/> from the <c>#Blob</c> heap
            </summary>
            <param name="module">Module</param>
            <param name="sig">Blob offset</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.MarshalType"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MarshalBlobReader.Read(dnlib.DotNet.ModuleDef,System.Byte[])">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.MarshalType"/> from <paramref name="data"/>
            </summary>
            <param name="module">Owner module</param>
            <param name="data">Marshal data</param>
            <returns>A new <see cref="T:dnlib.DotNet.MarshalType"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MarshalBlobReader.Read(dnlib.DotNet.ModuleDef,System.Byte[],dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.MarshalType"/> from <paramref name="data"/>
            </summary>
            <param name="module">Owner module</param>
            <param name="data">Marshal data</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.MarshalType"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MarshalBlobReader.Read(dnlib.DotNet.ModuleDef,dnlib.IO.DataReader)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.MarshalType"/> from <see cref="F:dnlib.DotNet.MarshalBlobReader.reader"/>
            </summary>
            <param name="module">Owner module</param>
            <param name="reader">A reader that will be owned by us</param>
            <returns>A new <see cref="T:dnlib.DotNet.MarshalType"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MarshalBlobReader.Read(dnlib.DotNet.ModuleDef,dnlib.IO.DataReader,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.MarshalType"/> from <see cref="F:dnlib.DotNet.MarshalBlobReader.reader"/>
            </summary>
            <param name="module">Owner module</param>
            <param name="reader">A reader that will be owned by us</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.MarshalType"/> instance</returns>
        </member>
        <member name="T:dnlib.DotNet.MarshalType">
            <summary>
            Base class of all marshal types
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MarshalType.nativeType">
            <summary>
            The native type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MarshalType.NativeType">
            <summary>
            Gets the <see cref="T:dnlib.DotNet.NativeType"/>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MarshalType.#ctor(dnlib.DotNet.NativeType)">
            <summary>
            Constructor
            </summary>
            <param name="nativeType">Native type</param>
        </member>
        <member name="M:dnlib.DotNet.MarshalType.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.RawMarshalType">
            <summary>
            Contains the raw marshal blob data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.RawMarshalType.Data">
            <summary>
            Gets/sets the raw data
            </summary>
        </member>
        <member name="M:dnlib.DotNet.RawMarshalType.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="data">Raw data</param>
        </member>
        <member name="T:dnlib.DotNet.FixedSysStringMarshalType">
            <summary>
            A <see cref="F:dnlib.DotNet.NativeType.FixedSysString"/> marshal type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FixedSysStringMarshalType.Size">
            <summary>
            Gets/sets the size
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FixedSysStringMarshalType.IsSizeValid">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.FixedSysStringMarshalType.Size"/> is valid
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FixedSysStringMarshalType.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FixedSysStringMarshalType.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size">Size</param>
        </member>
        <member name="M:dnlib.DotNet.FixedSysStringMarshalType.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.SafeArrayMarshalType">
            <summary>
            A <see cref="F:dnlib.DotNet.NativeType.SafeArray"/> marshal type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.SafeArrayMarshalType.VariantType">
            <summary>
            Gets/sets the variant type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.SafeArrayMarshalType.UserDefinedSubType">
            <summary>
            Gets/sets the user-defined sub type (it's usually <c>null</c>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.SafeArrayMarshalType.IsVariantTypeValid">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.SafeArrayMarshalType.VariantType"/> is valid
            </summary>
        </member>
        <member name="P:dnlib.DotNet.SafeArrayMarshalType.IsUserDefinedSubTypeValid">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.SafeArrayMarshalType.UserDefinedSubType"/> is valid
            </summary>
        </member>
        <member name="M:dnlib.DotNet.SafeArrayMarshalType.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.SafeArrayMarshalType.#ctor(dnlib.DotNet.VariantType)">
            <summary>
            Constructor
            </summary>
            <param name="vt">Variant type</param>
        </member>
        <member name="M:dnlib.DotNet.SafeArrayMarshalType.#ctor(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="userDefinedSubType">User-defined sub type</param>
        </member>
        <member name="M:dnlib.DotNet.SafeArrayMarshalType.#ctor(dnlib.DotNet.VariantType,dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="vt">Variant type</param>
            <param name="userDefinedSubType">User-defined sub type</param>
        </member>
        <member name="M:dnlib.DotNet.SafeArrayMarshalType.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.FixedArrayMarshalType">
            <summary>
            A <see cref="F:dnlib.DotNet.NativeType.FixedArray"/> marshal type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FixedArrayMarshalType.ElementType">
            <summary>
            Gets/sets the element type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FixedArrayMarshalType.Size">
            <summary>
            Gets/sets the size
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FixedArrayMarshalType.IsElementTypeValid">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.FixedArrayMarshalType.ElementType"/> is valid
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FixedArrayMarshalType.IsSizeValid">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.FixedArrayMarshalType.Size"/> is valid
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FixedArrayMarshalType.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FixedArrayMarshalType.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size">Size</param>
        </member>
        <member name="M:dnlib.DotNet.FixedArrayMarshalType.#ctor(System.Int32,dnlib.DotNet.NativeType)">
            <summary>
            Constructor
            </summary>
            <param name="size">Size</param>
            <param name="elementType">Element type</param>
        </member>
        <member name="M:dnlib.DotNet.FixedArrayMarshalType.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.ArrayMarshalType">
            <summary>
            A <see cref="F:dnlib.DotNet.NativeType.Array"/> marshal type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ArrayMarshalType.ElementType">
            <summary>
            Gets/sets the element type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ArrayMarshalType.ParamNumber">
            <summary>
            Gets/sets the parameter number
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ArrayMarshalType.Size">
            <summary>
            Gets/sets the size of the array
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ArrayMarshalType.Flags">
            <summary>
            Gets/sets the flags
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ArrayMarshalType.IsElementTypeValid">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ArrayMarshalType.ElementType"/> is valid
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ArrayMarshalType.IsParamNumberValid">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ArrayMarshalType.ParamNumber"/> is valid
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ArrayMarshalType.IsSizeValid">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ArrayMarshalType.Size"/> is valid
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ArrayMarshalType.IsFlagsValid">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ArrayMarshalType.Flags"/> is valid
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ArrayMarshalType.IsSizeParamIndexSpecified">
            <summary>
            <c>true</c> if <c>ntaSizeParamIndexSpecified</c> bit is set, <c>false</c> if it's not
            set or if <see cref="P:dnlib.DotNet.ArrayMarshalType.Flags"/> is invalid.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ArrayMarshalType.IsSizeParamIndexNotSpecified">
            <summary>
            <c>true</c> if <c>ntaSizeParamIndexSpecified</c> bit is not set, <c>false</c> if it's
            set or if <see cref="P:dnlib.DotNet.ArrayMarshalType.Flags"/> is invalid.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ArrayMarshalType.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ArrayMarshalType.#ctor(dnlib.DotNet.NativeType)">
            <summary>
            Constructor
            </summary>
            <param name="elementType">Element type</param>
        </member>
        <member name="M:dnlib.DotNet.ArrayMarshalType.#ctor(dnlib.DotNet.NativeType,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="elementType">Element type</param>
            <param name="paramNum">Parameter number</param>
        </member>
        <member name="M:dnlib.DotNet.ArrayMarshalType.#ctor(dnlib.DotNet.NativeType,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="elementType">Element type</param>
            <param name="paramNum">Parameter number</param>
            <param name="numElems">Number of elements</param>
        </member>
        <member name="M:dnlib.DotNet.ArrayMarshalType.#ctor(dnlib.DotNet.NativeType,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="elementType">Element type</param>
            <param name="paramNum">Parameter number</param>
            <param name="numElems">Number of elements</param>
            <param name="flags">Flags</param>
        </member>
        <member name="M:dnlib.DotNet.ArrayMarshalType.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.CustomMarshalType">
            <summary>
            A <see cref="F:dnlib.DotNet.NativeType.CustomMarshaler"/> marshal type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomMarshalType.Guid">
            <summary>
            Gets/sets the <c>GUID</c> string
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomMarshalType.NativeTypeName">
            <summary>
            Gets/sets the native type name string
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomMarshalType.CustomMarshaler">
            <summary>
            Gets/sets the custom marshaler
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CustomMarshalType.Cookie">
            <summary>
            Gets/sets the cookie string
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CustomMarshalType.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CustomMarshalType.#ctor(dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="guid">GUID string</param>
        </member>
        <member name="M:dnlib.DotNet.CustomMarshalType.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="guid">GUID string</param>
            <param name="nativeTypeName">Native type name string</param>
        </member>
        <member name="M:dnlib.DotNet.CustomMarshalType.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String,dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="guid">GUID string</param>
            <param name="nativeTypeName">Native type name string</param>
            <param name="custMarshaler">Custom marshaler name string</param>
        </member>
        <member name="M:dnlib.DotNet.CustomMarshalType.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String,dnlib.DotNet.ITypeDefOrRef,dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="guid">GUID string</param>
            <param name="nativeTypeName">Native type name string</param>
            <param name="custMarshaler">Custom marshaler name string</param>
            <param name="cookie">Cookie string</param>
        </member>
        <member name="M:dnlib.DotNet.CustomMarshalType.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.InterfaceMarshalType">
            <summary>
            A <see cref="F:dnlib.DotNet.NativeType.IUnknown"/>, <see cref="F:dnlib.DotNet.NativeType.IDispatch"/> or a
            <see cref="F:dnlib.DotNet.NativeType.IntF"/> marshal type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.InterfaceMarshalType.IidParamIndex">
            <summary>
            Gets/sets the IID parameter index
            </summary>
        </member>
        <member name="P:dnlib.DotNet.InterfaceMarshalType.IsIidParamIndexValid">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.InterfaceMarshalType.IidParamIndex"/> is valid
            </summary>
        </member>
        <member name="M:dnlib.DotNet.InterfaceMarshalType.#ctor(dnlib.DotNet.NativeType)">
            <summary>
            Constructor
            </summary>
            <param name="nativeType">Native type</param>
        </member>
        <member name="M:dnlib.DotNet.InterfaceMarshalType.#ctor(dnlib.DotNet.NativeType,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="nativeType">Native type</param>
            <param name="iidParamIndex">IID parameter index</param>
        </member>
        <member name="M:dnlib.DotNet.InterfaceMarshalType.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.MDToken">
            <summary>
            Metadata token
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MDToken.RID_MASK">
            <summary>
            Mask to get the rid from a raw metadata token
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MDToken.RID_MAX">
            <summary>
            Max rid value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MDToken.TABLE_SHIFT">
            <summary>
            Number of bits to right shift a raw metadata token to get the table index
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MDToken.Table">
            <summary>
            Returns the table type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MDToken.Rid">
            <summary>
            Returns the row id
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MDToken.Raw">
            <summary>
            Returns the raw token
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MDToken.IsNull">
            <summary>
            Returns <c>true</c> if it's a <c>null</c> token
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MDToken.#ctor(System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="token">Raw token</param>
        </member>
        <member name="M:dnlib.DotNet.MDToken.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="token">Raw token</param>
        </member>
        <member name="M:dnlib.DotNet.MDToken.#ctor(dnlib.DotNet.MD.Table,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="table">The table type</param>
            <param name="rid">Row id</param>
        </member>
        <member name="M:dnlib.DotNet.MDToken.#ctor(dnlib.DotNet.MD.Table,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="table">The table type</param>
            <param name="rid">Row id</param>
        </member>
        <member name="M:dnlib.DotNet.MDToken.ToRID(System.UInt32)">
            <summary>
            Returns the <c>rid</c> (row ID)
            </summary>
            <param name="token">A raw metadata token</param>
            <returns>A <c>rid</c></returns>
        </member>
        <member name="M:dnlib.DotNet.MDToken.ToRID(System.Int32)">
            <summary>
            Returns the <c>rid</c> (row ID)
            </summary>
            <param name="token">A raw metadata token</param>
            <returns>A <c>rid</c></returns>
        </member>
        <member name="M:dnlib.DotNet.MDToken.ToTable(System.UInt32)">
            <summary>
            Returns the <c>table</c>
            </summary>
            <param name="token">A raw metadata token</param>
            <returns>A metadata table index</returns>
        </member>
        <member name="M:dnlib.DotNet.MDToken.ToTable(System.Int32)">
            <summary>
            Returns the <c>table</c>
            </summary>
            <param name="token">A raw metadata token</param>
            <returns>A metadata table index</returns>
        </member>
        <member name="M:dnlib.DotNet.MDToken.ToInt32">
            <summary>
            Gets the token as a raw 32-bit signed integer
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MDToken.ToUInt32">
            <summary>
            Gets the token as a raw 32-bit unsigned integer
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MDToken.op_Equality(dnlib.DotNet.MDToken,dnlib.DotNet.MDToken)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.MDToken.op_Inequality(dnlib.DotNet.MDToken,dnlib.DotNet.MDToken)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.MDToken.op_LessThan(dnlib.DotNet.MDToken,dnlib.DotNet.MDToken)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.MDToken.op_GreaterThan(dnlib.DotNet.MDToken,dnlib.DotNet.MDToken)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.MDToken.op_LessThanOrEqual(dnlib.DotNet.MDToken,dnlib.DotNet.MDToken)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.MDToken.op_GreaterThanOrEqual(dnlib.DotNet.MDToken,dnlib.DotNet.MDToken)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.MDToken.CompareTo(dnlib.DotNet.MDToken)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MDToken.Equals(dnlib.DotNet.MDToken)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MDToken.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MDToken.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MDToken.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.MD.BlobStream">
            <summary>
            Represents the #Blob stream
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.BlobStream.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.BlobStream.#ctor(dnlib.IO.DataReaderFactory,System.UInt32,dnlib.DotNet.MD.StreamHeader)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.BlobStream.Read(System.UInt32)">
            <summary>
            Reads data
            </summary>
            <param name="offset">Offset of data</param>
            <returns>The data or <c>null</c> if invalid offset</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.BlobStream.ReadNoNull(System.UInt32)">
            <summary>
            Reads data just like <see cref="M:dnlib.DotNet.MD.BlobStream.Read(System.UInt32)"/>, but returns an empty array if
            offset is invalid
            </summary>
            <param name="offset">Offset of data</param>
            <returns>The data</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.BlobStream.CreateReader(System.UInt32)">
            <summary>
            Creates a reader that can access a blob
            </summary>
            <param name="offset">Offset of blob</param>
            <returns>A new stream</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.BlobStream.TryCreateReader(System.UInt32,dnlib.IO.DataReader@)">
            <summary>
            Creates a reader that can access a blob or returns false on failure
            </summary>
            <param name="offset">Offset of blob</param>
            <param name="reader">Updated with the reader</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.CodedToken">
            <summary>
            Contains all possible coded token classes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.TypeDefOrRef">
            <summary>TypeDefOrRef coded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.HasConstant">
            <summary>HasConstant coded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.HasCustomAttribute">
            <summary>HasCustomAttribute coded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.HasFieldMarshal">
            <summary>HasFieldMarshal coded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.HasDeclSecurity">
            <summary>HasDeclSecurity coded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.MemberRefParent">
            <summary>MemberRefParent coded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.HasSemantic">
            <summary>HasSemantic coded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.MethodDefOrRef">
            <summary>MethodDefOrRef coded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.MemberForwarded">
            <summary>MemberForwarded coded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.Implementation">
            <summary>Implementation coded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.CustomAttributeType">
            <summary>CustomAttributeType coded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.ResolutionScope">
            <summary>ResolutionScope coded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.TypeOrMethodDef">
            <summary>TypeOrMethodDef coded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.CodedToken.HasCustomDebugInformation">
            <summary>HasCustomDebugInformation coded token</summary>
        </member>
        <member name="P:dnlib.DotNet.MD.CodedToken.TableTypes">
            <summary>
            Returns all types of tables
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.CodedToken.Bits">
            <summary>
            Returns the number of bits that is used to encode table type
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.CodedToken.#ctor(System.Int32,dnlib.DotNet.MD.Table[])">
            <summary>
            Constructor
            </summary>
            <param name="bits">Number of bits used to encode token type</param>
            <param name="tableTypes">All table types</param>
        </member>
        <member name="M:dnlib.DotNet.MD.CodedToken.Encode(dnlib.DotNet.MDToken)">
            <summary>
            Encodes a token
            </summary>
            <param name="token">The token</param>
            <returns>Coded token</returns>
            <seealso cref="M:dnlib.DotNet.MD.CodedToken.Encode(dnlib.DotNet.MDToken,System.UInt32@)"/>
        </member>
        <member name="M:dnlib.DotNet.MD.CodedToken.Encode(System.UInt32)">
            <summary>
            Encodes a token
            </summary>
            <param name="token">The token</param>
            <returns>Coded token</returns>
            <seealso cref="M:dnlib.DotNet.MD.CodedToken.Encode(System.UInt32,System.UInt32@)"/>
        </member>
        <member name="M:dnlib.DotNet.MD.CodedToken.Encode(dnlib.DotNet.MDToken,System.UInt32@)">
            <summary>
            Encodes a token
            </summary>
            <param name="token">The token</param>
            <param name="codedToken">Coded token</param>
            <returns><c>true</c> if successful</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.CodedToken.Encode(System.UInt32,System.UInt32@)">
            <summary>
            Encodes a token
            </summary>
            <param name="token">The token</param>
            <param name="codedToken">Coded token</param>
            <returns><c>true</c> if successful</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.CodedToken.Decode2(System.UInt32)">
            <summary>
            Decodes a coded token
            </summary>
            <param name="codedToken">The coded token</param>
            <returns>Decoded token or 0 on failure</returns>
            <seealso cref="M:dnlib.DotNet.MD.CodedToken.Decode(System.UInt32,dnlib.DotNet.MDToken@)"/>
        </member>
        <member name="M:dnlib.DotNet.MD.CodedToken.Decode(System.UInt32)">
            <summary>
            Decodes a coded token
            </summary>
            <param name="codedToken">The coded token</param>
            <returns>Decoded token or 0 on failure</returns>
            <seealso cref="M:dnlib.DotNet.MD.CodedToken.Decode(System.UInt32,System.UInt32@)"/>
        </member>
        <member name="M:dnlib.DotNet.MD.CodedToken.Decode(System.UInt32,dnlib.DotNet.MDToken@)">
            <summary>
            Decodes a coded token
            </summary>
            <param name="codedToken">The coded token</param>
            <param name="token">Decoded token</param>
            <returns><c>true</c> if successful</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.CodedToken.Decode(System.UInt32,System.UInt32@)">
            <summary>
            Decodes a coded token
            </summary>
            <param name="codedToken">The coded token</param>
            <param name="token">Decoded token</param>
            <returns><c>true</c> if successful</returns>
        </member>
        <member name="T:dnlib.DotNet.MD.ColumnInfo">
            <summary>
            Info about one column in a MD table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ColumnInfo.Index">
            <summary>
            Gets the column index
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ColumnInfo.Offset">
            <summary>
            Returns the column offset within the table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ColumnInfo.Size">
            <summary>
            Returns the column size
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ColumnInfo.Name">
            <summary>
            Returns the column name
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ColumnInfo.ColumnSize">
            <summary>
            Returns the ColumnSize enum value
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.ColumnInfo.#ctor(System.Byte,System.String,dnlib.DotNet.MD.ColumnSize)">
            <summary>
            Constructor
            </summary>
            <param name="index">Column index</param>
            <param name="name">The column name</param>
            <param name="columnSize">Column size</param>
        </member>
        <member name="M:dnlib.DotNet.MD.ColumnInfo.#ctor(System.Byte,System.String,dnlib.DotNet.MD.ColumnSize,System.Byte,System.Byte)">
            <summary>
            Constructor
            </summary>
            <param name="index">Column index</param>
            <param name="name">The column name</param>
            <param name="columnSize">Column size</param>
            <param name="offset">Offset of column</param>
            <param name="size">Size of column</param>
        </member>
        <member name="M:dnlib.DotNet.MD.ColumnInfo.Read(dnlib.IO.DataReader@)">
            <summary>
            Reads the column
            </summary>
            <param name="reader">A reader positioned on this column</param>
            <returns>The column value</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.ColumnInfo.Write(dnlib.DotNet.Writer.DataWriter,System.UInt32)">
            <summary>
            Writes a column
            </summary>
            <param name="writer">The writer position on this column</param>
            <param name="value">The column value</param>
        </member>
        <member name="T:dnlib.DotNet.MD.ColumnSize">
            <summary>
            MD table column size
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Module">
            <summary>RID into Module table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.TypeRef">
            <summary>RID into TypeRef table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.TypeDef">
            <summary>RID into TypeDef table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.FieldPtr">
            <summary>RID into FieldPtr table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Field">
            <summary>RID into Field table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.MethodPtr">
            <summary>RID into MethodPtr table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Method">
            <summary>RID into Method table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.ParamPtr">
            <summary>RID into ParamPtr table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Param">
            <summary>RID into Param table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.InterfaceImpl">
            <summary>RID into InterfaceImpl table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.MemberRef">
            <summary>RID into MemberRef table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Constant">
            <summary>RID into Constant table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.CustomAttribute">
            <summary>RID into CustomAttribute table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.FieldMarshal">
            <summary>RID into FieldMarshal table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.DeclSecurity">
            <summary>RID into DeclSecurity table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.ClassLayout">
            <summary>RID into ClassLayout table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.FieldLayout">
            <summary>RID into FieldLayout table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.StandAloneSig">
            <summary>RID into StandAloneSig table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.EventMap">
            <summary>RID into EventMap table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.EventPtr">
            <summary>RID into EventPtr table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Event">
            <summary>RID into Event table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.PropertyMap">
            <summary>RID into PropertyMap table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.PropertyPtr">
            <summary>RID into PropertyPtr table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Property">
            <summary>RID into Property table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.MethodSemantics">
            <summary>RID into MethodSemantics table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.MethodImpl">
            <summary>RID into MethodImpl table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.ModuleRef">
            <summary>RID into ModuleRef table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.TypeSpec">
            <summary>RID into TypeSpec table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.ImplMap">
            <summary>RID into ImplMap table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.FieldRVA">
            <summary>RID into FieldRVA table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.ENCLog">
            <summary>RID into ENCLog table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.ENCMap">
            <summary>RID into ENCMap table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Assembly">
            <summary>RID into Assembly table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.AssemblyProcessor">
            <summary>RID into AssemblyProcessor table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.AssemblyOS">
            <summary>RID into AssemblyOS table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.AssemblyRef">
            <summary>RID into AssemblyRef table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.AssemblyRefProcessor">
            <summary>RID into AssemblyRefProcessor table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.AssemblyRefOS">
            <summary>RID into AssemblyRefOS table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.File">
            <summary>RID into File table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.ExportedType">
            <summary>RID into ExportedType table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.ManifestResource">
            <summary>RID into ManifestResource table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.NestedClass">
            <summary>RID into NestedClass table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.GenericParam">
            <summary>RID into GenericParam table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.MethodSpec">
            <summary>RID into MethodSpec table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.GenericParamConstraint">
            <summary>RID into GenericParamConstraint table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Document">
            <summary>RID into Document table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.MethodDebugInformation">
            <summary>RID into MethodDebugInformation table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.LocalScope">
            <summary>RID into LocalScope table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.LocalVariable">
            <summary>RID into LocalVariable table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.LocalConstant">
            <summary>RID into LocalConstant table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.ImportScope">
            <summary>RID into ImportScope table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.StateMachineMethod">
            <summary>RID into StateMachineMethod table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.CustomDebugInformation">
            <summary>RID into CustomDebugInformation table</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Byte">
            <summary>8-bit byte</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Int16">
            <summary>16-bit signed int</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.UInt16">
            <summary>16-bit unsigned int</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Int32">
            <summary>32-bit signed int</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.UInt32">
            <summary>32-bit unsigned int</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Strings">
            <summary>Index into #Strings stream</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.GUID">
            <summary>Index into #GUID stream</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Blob">
            <summary>Index into #Blob stream</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.TypeDefOrRef">
            <summary>TypeDefOrRef encoded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.HasConstant">
            <summary>HasConstant encoded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.HasCustomAttribute">
            <summary>HasCustomAttribute encoded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.HasFieldMarshal">
            <summary>HasFieldMarshal encoded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.HasDeclSecurity">
            <summary>HasDeclSecurity encoded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.MemberRefParent">
            <summary>MemberRefParent encoded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.HasSemantic">
            <summary>HasSemantic encoded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.MethodDefOrRef">
            <summary>MethodDefOrRef encoded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.MemberForwarded">
            <summary>MemberForwarded encoded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.Implementation">
            <summary>Implementation encoded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.CustomAttributeType">
            <summary>CustomAttributeType encoded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.ResolutionScope">
            <summary>ResolutionScope encoded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.TypeOrMethodDef">
            <summary>TypeOrMethodDef encoded token</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ColumnSize.HasCustomDebugInformation">
            <summary>HasCustomDebugInformation encoded token</summary>
        </member>
        <member name="T:dnlib.DotNet.MD.ComImageFlags">
            <summary>
            See COMIMAGE_FLAGS_XXX in CorHdr.h in the Windows SDK
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ComImageFlags.ILOnly">
            <summary>
            See COMIMAGE_FLAGS_ILONLY in the Windows SDK
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ComImageFlags.Bit32Required">
            <summary>
            See COMIMAGE_FLAGS_32BITREQUIRED in the Windows SDK
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ComImageFlags.ILLibrary">
            <summary>
            Set if a native header exists (COMIMAGE_FLAGS_IL_LIBRARY)
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ComImageFlags.StrongNameSigned">
            <summary>
            See COMIMAGE_FLAGS_STRONGNAMESIGNED in the Windows SDK
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ComImageFlags.NativeEntryPoint">
            <summary>
            See COMIMAGE_FLAGS_NATIVE_ENTRYPOINT in the Windows SDK
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ComImageFlags.TrackDebugData">
            <summary>
            See COMIMAGE_FLAGS_TRACKDEBUGDATA in the Windows SDK
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.ComImageFlags.Bit32Preferred">
            <summary>
            See COMIMAGE_FLAGS_32BITPREFERRED in the Windows SDK
            </summary>
        </member>
        <member name="T:dnlib.DotNet.MD.CompressedMetadata">
            <summary>
            Used when a #~ stream is present in the metadata
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.CompressedMetadata.IsCompressed">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.CompressedMetadata.#ctor(dnlib.PE.IPEImage,dnlib.DotNet.MD.ImageCor20Header,dnlib.DotNet.MD.MetadataHeader)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.CompressedMetadata.#ctor(dnlib.DotNet.MD.MetadataHeader,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.CompressedMetadata.InitializeInternal(dnlib.IO.DataReaderFactory,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.CompressedMetadata.GetFieldRidList(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.CompressedMetadata.GetMethodRidList(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.CompressedMetadata.GetParamRidList(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.CompressedMetadata.GetEventRidList(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.CompressedMetadata.GetPropertyRidList(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.CompressedMetadata.GetRidList(dnlib.DotNet.MD.MDTable,System.UInt32,System.Int32,dnlib.DotNet.MD.MDTable)">
            <summary>
            Gets a rid list (eg. field list)
            </summary>
            <param name="tableSource">Source table, eg. <c>TypeDef</c></param>
            <param name="tableSourceRid">Row ID in <paramref name="tableSource"/></param>
            <param name="colIndex">Column index in <paramref name="tableSource"/>, eg. 4 for <c>TypeDef.FieldList</c></param>
            <param name="tableDest">Destination table, eg. <c>Field</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.RidList"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.CompressedMetadata.BinarySearch(dnlib.DotNet.MD.MDTable,System.Int32,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.MD.CustomDotNetStream">
            <summary>
            A custom .NET metadata stream
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.CustomDotNetStream.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.CustomDotNetStream.#ctor(dnlib.IO.DataReaderFactory,System.UInt32,dnlib.DotNet.MD.StreamHeader)">
            <summary>
            Constructor
            </summary>
            <param name="mdReaderFactory">Data reader factory</param>
            <param name="metadataBaseOffset">Offset of metadata</param>
            <param name="streamHeader">The stream header</param>
        </member>
        <member name="T:dnlib.DotNet.MD.DotNetStream">
            <summary>
            .NET metadata stream
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.DotNetStream.dataReader">
            <summary>
            Reader that can access the whole stream.
            
            NOTE: Always copy this field to a local variable before using it since it must be thread safe.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.DotNetStream.streamHeader">
            <summary>
            <c>null</c> if it wasn't present in the file
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.DotNetStream.StartOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MD.DotNetStream.EndOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MD.DotNetStream.StreamLength">
            <summary>
            Gets the length of this stream in the metadata
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.DotNetStream.StreamHeader">
            <summary>
            Gets the stream header
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.DotNetStream.Name">
            <summary>
            Gets the name of the stream
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.DotNetStream.CreateReader">
            <summary>
            Gets a data reader that can read the full stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.DotNetStream.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.DotNetStream.#ctor(dnlib.IO.DataReaderFactory,System.UInt32,dnlib.DotNet.MD.StreamHeader)">
            <summary>
            Constructor
            </summary>
            <param name="mdReaderFactory">Data reader factory</param>
            <param name="metadataBaseOffset">Offset of metadata</param>
            <param name="streamHeader">The stream header</param>
        </member>
        <member name="M:dnlib.DotNet.MD.DotNetStream.OnReaderRecreated">
            <summary>
            Called after <see cref="F:dnlib.DotNet.MD.DotNetStream.dataReader"/> gets recreated
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.DotNetStream.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.DotNetStream.Dispose(System.Boolean)">
            <summary>
            Dispose method
            </summary>
            <param name="disposing"><c>true</c> if called by <see cref="M:dnlib.DotNet.MD.DotNetStream.Dispose"/></param>
        </member>
        <member name="M:dnlib.DotNet.MD.DotNetStream.IsValidIndex(System.UInt32)">
            <summary>
            Checks whether an index is valid
            </summary>
            <param name="index">The index</param>
            <returns><c>true</c> if the index is valid</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.DotNetStream.IsValidOffset(System.UInt32)">
            <summary>
            Check whether an offset is within the stream
            </summary>
            <param name="offset">Stream offset</param>
            <returns><c>true</c> if the offset is valid</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.DotNetStream.IsValidOffset(System.UInt32,System.Int32)">
            <summary>
            Check whether an offset is within the stream
            </summary>
            <param name="offset">Stream offset</param>
            <param name="size">Size of data</param>
            <returns><c>true</c> if the offset is valid</returns>
        </member>
        <member name="T:dnlib.DotNet.MD.HeapStream">
            <summary>
            Base class of #US, #Strings, #Blob, and #GUID classes
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.HeapStream.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.HeapStream.#ctor(dnlib.IO.DataReaderFactory,System.UInt32,dnlib.DotNet.MD.StreamHeader)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.MD.DotNetTableSizes">
            <summary>
            Initializes .NET table row sizes
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.DotNetTableSizes.InitializeSizes(System.Boolean,System.Boolean,System.Boolean,System.Collections.Generic.IList{System.UInt32},System.Collections.Generic.IList{System.UInt32})">
            <summary>
            Initializes the table sizes
            </summary>
            <param name="bigStrings"><c>true</c> if #Strings size >= 0x10000</param>
            <param name="bigGuid"><c>true</c> if #GUID size >= 0x10000</param>
            <param name="bigBlob"><c>true</c> if #Blob size >= 0x10000</param>
            <param name="systemRowCounts">Count of rows in each table</param>
            <param name="debugRowCounts">Count of rows in each table (debug tables)</param>
        </member>
        <member name="M:dnlib.DotNet.MD.DotNetTableSizes.CreateTables(System.Byte,System.Byte)">
            <summary>
            Creates the table infos
            </summary>
            <param name="majorVersion">Major table version</param>
            <param name="minorVersion">Minor table version</param>
            <returns>All table infos (not completely initialized)</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.DotNetTableSizes.CreateTables(System.Byte,System.Byte,System.Int32@)">
            <summary>
            Creates the table infos
            </summary>
            <param name="majorVersion">Major table version</param>
            <param name="minorVersion">Minor table version</param>
            <param name="maxPresentTables">Initialized to max present tables (eg. 42 or 45)</param>
            <returns>All table infos (not completely initialized)</returns>
        </member>
        <member name="T:dnlib.DotNet.MD.ENCMetadata">
            <summary>
            Used when a #- stream is present in the metadata
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ENCMetadata.IsCompressed">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.#ctor(dnlib.PE.IPEImage,dnlib.DotNet.MD.ImageCor20Header,dnlib.DotNet.MD.MetadataHeader)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.#ctor(dnlib.DotNet.MD.MetadataHeader,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.InitializeInternal(dnlib.IO.DataReaderFactory,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.GetTypeDefRidList">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.GetExportedTypeRidList">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.ToFieldRid(System.UInt32)">
            <summary>
            Converts a logical <c>Field</c> rid to a physical <c>Field</c> rid
            </summary>
            <param name="listRid">A valid rid</param>
            <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.ToMethodRid(System.UInt32)">
            <summary>
            Converts a logical <c>Method</c> rid to a physical <c>Method</c> rid
            </summary>
            <param name="listRid">A valid rid</param>
            <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.ToParamRid(System.UInt32)">
            <summary>
            Converts a logical <c>Param</c> rid to a physical <c>Param</c> rid
            </summary>
            <param name="listRid">A valid rid</param>
            <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.ToEventRid(System.UInt32)">
            <summary>
            Converts a logical <c>Event</c> rid to a physical <c>Event</c> rid
            </summary>
            <param name="listRid">A valid rid</param>
            <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.ToPropertyRid(System.UInt32)">
            <summary>
            Converts a logical <c>Property</c> rid to a physical <c>Property</c> rid
            </summary>
            <param name="listRid">A valid rid</param>
            <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.GetFieldRidList(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.GetMethodRidList(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.GetParamRidList(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.GetEventRidList(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.GetPropertyRidList(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.GetRidList(dnlib.DotNet.MD.MDTable,System.UInt32,System.Int32,dnlib.DotNet.MD.MDTable)">
            <summary>
            Gets a rid list (eg. field list)
            </summary>
            <param name="tableSource">Source table, eg. <c>TypeDef</c></param>
            <param name="tableSourceRid">Row ID in <paramref name="tableSource"/></param>
            <param name="colIndex">Column index in <paramref name="tableSource"/>, eg. 4 for <c>TypeDef.FieldList</c></param>
            <param name="tableDest">Destination table, eg. <c>Field</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.RidList"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.BinarySearch(dnlib.DotNet.MD.MDTable,System.Int32,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.LinearSearch(dnlib.DotNet.MD.MDTable,System.Int32,System.UInt32)">
            <summary>
            Linear searches the table (O(n)) for a <c>rid</c> whose key column at index
            <paramref name="keyColIndex"/> is equal to <paramref name="key"/>.
            </summary>
            <param name="tableSource">Table to search</param>
            <param name="keyColIndex">Key column index</param>
            <param name="key">Key</param>
            <returns>The <c>rid</c> of the found row, or 0 if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.ENCMetadata.FindAllRowsUnsorted(dnlib.DotNet.MD.MDTable,System.Int32,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.MD.GuidStream">
            <summary>
            Represents the #GUID stream
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.GuidStream.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.GuidStream.#ctor(dnlib.IO.DataReaderFactory,System.UInt32,dnlib.DotNet.MD.StreamHeader)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.GuidStream.IsValidIndex(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.GuidStream.Read(System.UInt32)">
            <summary>
            Read a <see cref="T:System.Guid"/>
            </summary>
            <param name="index">Index into this stream</param>
            <returns>A <see cref="T:System.Guid"/> or <c>null</c> if <paramref name="index"/> is 0 or invalid</returns>
        </member>
        <member name="T:dnlib.DotNet.MD.HeapType">
            <summary>
            Heap type. The values are set in stone by MS. Don't change.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.HeapType.Strings">
            <summary>#Strings heap</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.HeapType.Guid">
            <summary>#GUID heap</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.HeapType.Blob">
            <summary>#Blob heap</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.HeapType.US">
            <summary>#US heap</summary>
        </member>
        <member name="T:dnlib.DotNet.MD.ImageCor20Header">
            <summary>
            Represents the IMAGE_COR20_HEADER structure
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ImageCor20Header.HasNativeHeader">
            <summary>
            Returns <c>true</c> if it has a native header
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ImageCor20Header.CB">
            <summary>
            Returns the IMAGE_COR20_HEADER.cb field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ImageCor20Header.MajorRuntimeVersion">
            <summary>
            Returns the IMAGE_COR20_HEADER.MajorRuntimeVersion field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ImageCor20Header.MinorRuntimeVersion">
            <summary>
            Returns the IMAGE_COR20_HEADER.MinorRuntimeVersion field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ImageCor20Header.Metadata">
            <summary>
            Returns the IMAGE_COR20_HEADER.Metadata field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ImageCor20Header.Flags">
            <summary>
            Returns the IMAGE_COR20_HEADER.Flags field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ImageCor20Header.EntryPointToken_or_RVA">
            <summary>
            Returns the IMAGE_COR20_HEADER.EntryPointToken/EntryPointTokenRVA field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ImageCor20Header.Resources">
            <summary>
            Returns the IMAGE_COR20_HEADER.Resources field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ImageCor20Header.StrongNameSignature">
            <summary>
            Returns the IMAGE_COR20_HEADER.StrongNameSignature field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ImageCor20Header.CodeManagerTable">
            <summary>
            Returns the IMAGE_COR20_HEADER.CodeManagerTable field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ImageCor20Header.VTableFixups">
            <summary>
            Returns the IMAGE_COR20_HEADER.VTableFixups field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ImageCor20Header.ExportAddressTableJumps">
            <summary>
            Returns the IMAGE_COR20_HEADER.ExportAddressTableJumps field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.ImageCor20Header.ManagedNativeHeader">
            <summary>
            Returns the IMAGE_COR20_HEADER.ManagedNativeHeader field
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.ImageCor20Header.#ctor(dnlib.IO.DataReader@,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="reader">PE file reader pointing to the start of this section</param>
            <param name="verify">Verify section</param>
            <exception cref="T:System.BadImageFormatException">Thrown if verification fails</exception>
        </member>
        <member name="T:dnlib.DotNet.MD.IColumnReader">
            <summary>
            Reads metadata table columns
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.IColumnReader.ReadColumn(dnlib.DotNet.MD.MDTable,System.UInt32,dnlib.DotNet.MD.ColumnInfo,System.UInt32@)">
            <summary>
            Reads a column
            </summary>
            <param name="table">The table to read from</param>
            <param name="rid">Table row id</param>
            <param name="column">The column to read</param>
            <param name="value">Result</param>
            <returns><c>true</c> if <paramref name="value"/> was updated, <c>false</c> if
            the column should be read from the original table.</returns>
        </member>
        <member name="T:dnlib.DotNet.MD.IRowReader`1">
            <summary>
            Reads table rows
            </summary>
            <typeparam name="TRow">Raw row</typeparam>
        </member>
        <member name="M:dnlib.DotNet.MD.IRowReader`1.TryReadRow(System.UInt32,`0@)">
            <summary>
            Reads a table row or returns false if the row should be read from the original table
            </summary>
            <param name="rid">Row id</param>
            <param name="row">The row</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.MDHeaderRuntimeVersion">
            <summary>
            Version strings found in the meta data header
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.MS_CLR_10">
            <summary>
            MS CLR 1.0 version string (.NET 1.0)
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.MS_CLR_10_X86RETAIL">
            <summary>
            MS CLR 1.0 version string (.NET 1.0). This is an incorrect version that shouldn't be used.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.MS_CLR_10_RETAIL">
            <summary>
            MS CLR 1.0 version string (.NET 1.0). This is an incorrect version that shouldn't be used.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.MS_CLR_10_COMPLUS">
            <summary>
            MS CLR 1.0 version string (.NET 1.0). This is an incorrect version that shouldn't be used.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.MS_CLR_11">
            <summary>
            MS CLR 1.1 version string (.NET 1.1)
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.MS_CLR_20">
            <summary>
            MS CLR 2.0 version string (.NET 2.0-3.5)
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.MS_CLR_40">
            <summary>
            MS CLR 4.0 version string (.NET 4.0-4.5)
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.MS_CLR_10_PREFIX">
            <summary>
            MS CLR 1.0 any version
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.MS_CLR_10_PREFIX_X86RETAIL">
            <summary>
            MS CLR 1.0 any version
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.MS_CLR_11_PREFIX">
            <summary>
            MS CLR 1.1 any version
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.MS_CLR_20_PREFIX">
            <summary>
            MS CLR 2.0 any version
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.MS_CLR_40_PREFIX">
            <summary>
            MS CLR 4.0 any version
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.ECMA_2002">
            <summary>
            ECMA 2002 version string
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.ECMA_2005">
            <summary>
            ECMA 2005 version string
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDHeaderRuntimeVersion.PORTABLE_PDB_V1_0">
            <summary>
            Portable PDB v1.0
            </summary>
        </member>
        <member name="T:dnlib.DotNet.MD.MDStreamFlags">
            <summary>
            MDStream flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDStreamFlags.BigStrings">
            <summary>#Strings stream is big and requires 4 byte offsets</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDStreamFlags.BigGUID">
            <summary>#GUID stream is big and requires 4 byte offsets</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDStreamFlags.BigBlob">
            <summary>#Blob stream is big and requires 4 byte offsets</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDStreamFlags.Padding">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.MD.MDStreamFlags.DeltaOnly">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.MD.MDStreamFlags.ExtraData">
            <summary>Extra data follows the row counts</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MDStreamFlags.HasDelete">
            <summary>Set if certain tables can contain deleted rows. The name column (if present) is set to "_Deleted"</summary>
        </member>
        <member name="T:dnlib.DotNet.MD.MDTable">
            <summary>
            A MD table (eg. Method table)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MDTable.StartOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MD.MDTable.EndOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MD.MDTable.Table">
            <summary>
            Gets the table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MDTable.Name">
            <summary>
            Gets the name of this table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MDTable.Rows">
            <summary>
            Returns total number of rows
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MDTable.RowSize">
            <summary>
            Gets the total size in bytes of one row in this table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MDTable.Columns">
            <summary>
            Returns all the columns
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MDTable.IsEmpty">
            <summary>
            Returns <c>true</c> if there are no valid rows
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MDTable.TableInfo">
            <summary>
            Returns info about this table
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.MDTable.#ctor(dnlib.DotNet.MD.Table,System.UInt32,dnlib.DotNet.MD.TableInfo)">
            <summary>
            Constructor
            </summary>
            <param name="table">The table</param>
            <param name="numRows">Number of rows in this table</param>
            <param name="tableInfo">Info about this table</param>
        </member>
        <member name="M:dnlib.DotNet.MD.MDTable.IsValidRID(System.UInt32)">
            <summary>
            Checks whether the row <paramref name="rid"/> exists
            </summary>
            <param name="rid">Row ID</param>
        </member>
        <member name="M:dnlib.DotNet.MD.MDTable.IsInvalidRID(System.UInt32)">
            <summary>
            Checks whether the row <paramref name="rid"/> does not exist
            </summary>
            <param name="rid">Row ID</param>
        </member>
        <member name="M:dnlib.DotNet.MD.MDTable.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.MD.Metadata">
            <summary>
            Reads .NET metadata
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.IsCompressed">
            <summary>
            <c>true</c> if the compressed (normal) metadata is used, <c>false</c> if the non-compressed
            (Edit N' Continue) metadata is used. This can be <c>false</c> even if the table stream
            is <c>#~</c> but that's very uncommon.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.IsStandalonePortablePdb">
            <summary>
            <c>true</c> if this is standalone Portable PDB metadata
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.ImageCor20Header">
            <summary>
            Gets the .NET header
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.Version">
            <summary>
            Gets the version found in the metadata header. The major version number is in the high 16 bits
            and the lower version number is in the low 16 bits.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.VersionString">
            <summary>
            Gets the version string found in the metadata header
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.PEImage">
            <summary>
            Gets the <see cref="T:dnlib.PE.IPEImage"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.MetadataHeader">
            <summary>
            Gets the metadata header
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.StringsStream">
            <summary>
            Returns the #Strings stream or a default empty one if it's not present
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.USStream">
            <summary>
            Returns the #US stream or a default empty one if it's not present
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.BlobStream">
            <summary>
            Returns the #Blob stream or a default empty one if it's not present
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.GuidStream">
            <summary>
            Returns the #GUID stream or a default empty one if it's not present
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.TablesStream">
            <summary>
            Returns the #~ or #- tables stream
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.PdbStream">
            <summary>
            Returns the #Pdb stream or null if it's not a standalone portable PDB file
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.Metadata.AllStreams">
            <summary>
            Gets all streams
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetTypeDefRidList">
            <summary>
            Gets a list of all the valid <c>TypeDef</c> rids. It's usually every rid in the
            <c>TypeDef</c> table, but could be less if a type has been deleted.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetExportedTypeRidList">
            <summary>
            Gets a list of all the valid <c>ExportedType</c> rids. It's usually every rid in the
            <c>ExportedType</c> table, but could be less if a type has been deleted.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetFieldRidList(System.UInt32)">
            <summary>
            Gets the <c>Field</c> rid list
            </summary>
            <param name="typeDefRid"><c>TypeDef</c> rid</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.RidList"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetMethodRidList(System.UInt32)">
            <summary>
            Gets the <c>Method</c> rid list
            </summary>
            <param name="typeDefRid"><c>TypeDef</c> rid</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.RidList"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetParamRidList(System.UInt32)">
            <summary>
            Gets the <c>Param</c> rid list
            </summary>
            <param name="methodRid"><c>Method</c> rid</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.RidList"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetEventRidList(System.UInt32)">
            <summary>
            Gets the <c>Event</c> rid list
            </summary>
            <param name="eventMapRid"><c>EventMap</c> rid</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.RidList"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetPropertyRidList(System.UInt32)">
            <summary>
            Gets the <c>Property</c> rid list
            </summary>
            <param name="propertyMapRid"><c>PropertyMap</c> rid</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.RidList"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetInterfaceImplRidList(System.UInt32)">
            <summary>
            Finds all <c>InterfaceImpl</c> rids owned by <paramref name="typeDefRid"/>
            </summary>
            <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
            <returns>A <see cref="T:dnlib.DotNet.MD.RidList"/> instance containing the valid <c>InterfaceImpl</c> rids</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetGenericParamRidList(dnlib.DotNet.MD.Table,System.UInt32)">
            <summary>
            Finds all <c>GenericParam</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
            </summary>
            <param name="table">A <c>TypeOrMethodDef</c> table</param>
            <param name="rid">Owner rid</param>
            <returns>A <see cref="T:dnlib.DotNet.MD.RidList"/> instance containing the valid <c>GenericParam</c> rids</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetGenericParamConstraintRidList(System.UInt32)">
            <summary>
            Finds all <c>GenericParamConstraint</c> rids owned by <paramref name="genericParamRid"/>
            </summary>
            <param name="genericParamRid">Owner <c>GenericParam</c> rid</param>
            <returns>A <see cref="T:dnlib.DotNet.MD.RidList"/> instance containing the valid <c>GenericParamConstraint</c> rids</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetCustomAttributeRidList(dnlib.DotNet.MD.Table,System.UInt32)">
            <summary>
            Finds all <c>CustomAttribute</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
            </summary>
            <param name="table">A <c>HasCustomAttribute</c> table</param>
            <param name="rid">Owner rid</param>
            <returns>A <see cref="T:dnlib.DotNet.MD.RidList"/> instance containing the valid <c>CustomAttribute</c> rids</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetDeclSecurityRidList(dnlib.DotNet.MD.Table,System.UInt32)">
            <summary>
            Finds all <c>DeclSecurity</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
            </summary>
            <param name="table">A <c>HasDeclSecurity</c> table</param>
            <param name="rid">Owner rid</param>
            <returns>A <see cref="T:dnlib.DotNet.MD.RidList"/> instance containing the valid <c>DeclSecurity</c> rids</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetMethodSemanticsRidList(dnlib.DotNet.MD.Table,System.UInt32)">
            <summary>
            Finds all <c>MethodSemantics</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
            </summary>
            <param name="table">A <c>HasSemantic</c> table</param>
            <param name="rid">Owner rid</param>
            <returns>A <see cref="T:dnlib.DotNet.MD.RidList"/> instance containing the valid <c>MethodSemantics</c> rids</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetMethodImplRidList(System.UInt32)">
            <summary>
            Finds all <c>MethodImpl</c> rids owned by <paramref name="typeDefRid"/>
            </summary>
            <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
            <returns>A <see cref="T:dnlib.DotNet.MD.RidList"/> instance containing the valid <c>MethodImpl</c> rids</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetClassLayoutRid(System.UInt32)">
            <summary>
            Finds a <c>ClassLayout</c> rid
            </summary>
            <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
            <returns>The <c>ClassLayout</c> rid or 0 if <paramref name="typeDefRid"/> is invalid
            or if it has no row in the <c>ClassLayout</c> table.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetFieldLayoutRid(System.UInt32)">
            <summary>
            Finds a <c>FieldLayout</c> rid
            </summary>
            <param name="fieldRid">Owner <c>Field</c> rid</param>
            <returns>The <c>FieldLayout</c> rid or 0 if <paramref name="fieldRid"/> is invalid
            or if it has no row in the <c>FieldLayout</c> table.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetFieldMarshalRid(dnlib.DotNet.MD.Table,System.UInt32)">
            <summary>
            Finds a <c>FieldMarshal</c> rid
            </summary>
            <param name="table">A <c>HasFieldMarshal</c> table</param>
            <param name="rid">Owner rid</param>
            <returns>The <c>FieldMarshal</c> rid or 0 if <paramref name="rid"/> is invalid
            or if it has no row in the <c>FieldMarshal</c> table.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetFieldRVARid(System.UInt32)">
            <summary>
            Finds a <c>FieldRVA</c> rid
            </summary>
            <param name="fieldRid">Owner <c>Field</c> rid</param>
            <returns>The <c>FieldRVA</c> rid or 0 if <paramref name="fieldRid"/> is invalid
            or if it has no row in the <c>FieldRVA</c> table.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetImplMapRid(dnlib.DotNet.MD.Table,System.UInt32)">
            <summary>
            Finds an <c>ImplMap</c> rid
            </summary>
            <param name="table">A <c>MemberForwarded</c> table</param>
            <param name="rid">Owner rid</param>
            <returns>The <c>ImplMap</c> rid or 0 if <paramref name="rid"/> is invalid
            or if it has no row in the <c>ImplMap</c> table.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetNestedClassRid(System.UInt32)">
            <summary>
            Finds a <c>NestedClass</c> rid
            </summary>
            <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
            <returns>The <c>NestedClass</c> rid or 0 if <paramref name="typeDefRid"/> is invalid
            or if it has no row in the <c>NestedClass</c> table.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetEventMapRid(System.UInt32)">
            <summary>
            Finds an <c>EventMap</c> rid
            </summary>
            <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
            <returns>The <c>EventMap</c> rid or 0 if <paramref name="typeDefRid"/> is invalid
            or if it has no row in the <c>EventMap</c> table.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetPropertyMapRid(System.UInt32)">
            <summary>
            Finds a <c>PropertyMap</c> rid
            </summary>
            <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
            <returns>The <c>PropertyMap</c> rid or 0 if <paramref name="typeDefRid"/> is invalid
            or if it has no row in the <c>PropertyMap</c> table.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetConstantRid(dnlib.DotNet.MD.Table,System.UInt32)">
            <summary>
            Finds a <c>Constant</c> rid
            </summary>
            <param name="table">A <c>HasConstant</c> table</param>
            <param name="rid">Owner rid</param>
            <returns>The <c>Constant</c> rid or 0 if <paramref name="rid"/> is invalid
            or if it has no row in the <c>Constant</c> table.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetOwnerTypeOfField(System.UInt32)">
            <summary>
            Returns the owner <c>TypeDef</c> rid
            </summary>
            <param name="fieldRid">A <c>Field</c> rid</param>
            <returns>The owner <c>TypeDef</c> rid or 0 if <paramref name="fieldRid"/> is invalid
            or if it has no owner.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetOwnerTypeOfMethod(System.UInt32)">
            <summary>
            Returns the owner <c>TypeDef</c> rid
            </summary>
            <param name="methodRid">A <c>Method</c> rid</param>
            <returns>The owner <c>TypeDef</c> rid or 0 if <paramref name="methodRid"/> is invalid
            or if it has no owner.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetOwnerTypeOfEvent(System.UInt32)">
            <summary>
            Returns the owner <c>TypeDef</c> rid
            </summary>
            <param name="eventRid">A <c>Event</c> rid</param>
            <returns>The owner <c>TypeDef</c> rid or 0 if <paramref name="eventRid"/> is invalid
            or if it has no owner.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetOwnerTypeOfProperty(System.UInt32)">
            <summary>
            Returns the owner <c>TypeDef</c> rid
            </summary>
            <param name="propertyRid">A <c>Property</c> rid</param>
            <returns>The owner <c>TypeDef</c> rid or 0 if <paramref name="propertyRid"/> is invalid
            or if it has no owner.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetOwnerOfGenericParam(System.UInt32)">
            <summary>
            Returns the owner <c>TypeOrMethodDef</c> rid
            </summary>
            <param name="gpRid">A <c>GenericParam</c> rid</param>
            <returns>The owner <c>TypeOrMethodDef</c> rid or 0 if <paramref name="gpRid"/> is
            invalid or if it has no owner.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetOwnerOfGenericParamConstraint(System.UInt32)">
            <summary>
            Returns the owner <c>GenericParam</c> rid
            </summary>
            <param name="gpcRid">A <c>GenericParamConstraint</c> rid</param>
            <returns>The owner <c>GenericParam</c> rid or 0 if <paramref name="gpcRid"/> is
            invalid or if it has no owner.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetOwnerOfParam(System.UInt32)">
            <summary>
            Returns the owner <c>Method</c> rid
            </summary>
            <param name="paramRid">A <c>Param</c> rid</param>
            <returns>The owner <c>Method</c> rid or 0 if <paramref name="paramRid"/> is invalid
            or if it has no owner.</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetNestedClassRidList(System.UInt32)">
            <summary>
            Gets a list of all nested classes owned by <paramref name="typeDefRid"/>
            </summary>
            <param name="typeDefRid">A <c>TypeDef</c> rid</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.RidList"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetNonNestedClassRidList">
            <summary>
            Gets a list of all non-nested classes. A type is a non-nested type if
            <see cref="M:dnlib.DotNet.MD.Metadata.GetNestedClassRidList(System.UInt32)"/> returns an empty list.
            </summary>
            <returns>A new <see cref="T:dnlib.DotNet.MD.RidList"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetLocalScopeRidList(System.UInt32)">
            <summary>
            Finds all <c>LocalScope</c> rids owned by <paramref name="methodRid"/>
            </summary>
            <param name="methodRid">Owner <c>Method</c> rid</param>
            <returns>A <see cref="T:dnlib.DotNet.MD.RidList"/> instance containing the valid <c>LocalScope</c> rids</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetStateMachineMethodRid(System.UInt32)">
            <summary>
            Gets the <c>StateMachineMethod</c> rid or 0 if it's not a state machine method
            </summary>
            <param name="methodRid">Owner <c>Method</c> rid</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.GetCustomDebugInformationRidList(dnlib.DotNet.MD.Table,System.UInt32)">
            <summary>
            Finds all <c>CustomDebugInformation</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
            </summary>
            <param name="table">A <c>HasCustomDebugInformation</c> table</param>
            <param name="rid">Owner rid</param>
            <returns>A <see cref="T:dnlib.DotNet.MD.RidList"/> instance containing the valid <c>CustomDebugInformation</c> rids</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.Metadata.Dispose">
            <summary>
            Disposes of this instance
            </summary>
        </member>
        <member name="T:dnlib.DotNet.MD.MetadataBase">
            <summary>
            Common base class for #~ and #- metadata classes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MetadataBase.peImage">
            <summary>
            The PE image
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MetadataBase.cor20Header">
            <summary>
            The .NET header
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MetadataBase.mdHeader">
            <summary>
            The MD header
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MetadataBase.stringsStream">
            <summary>
            The #Strings stream
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MetadataBase.usStream">
            <summary>
            The #US stream
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MetadataBase.blobStream">
            <summary>
            The #Blob stream
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MetadataBase.guidStream">
            <summary>
            The #GUID stream
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MetadataBase.tablesStream">
            <summary>
            The #~ or #- stream
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MetadataBase.pdbStream">
            <summary>
            The #Pdb stream
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MetadataBase.allStreams">
            <summary>
            All the streams that are present in the PE image
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.MetadataBase.isStandalonePortablePdb">
            <summary><c>true</c> if this is standalone Portable PDB metadata</summary>
        </member>
        <member name="T:dnlib.DotNet.MD.MetadataBase.SortedTable">
            <summary>
            Sorts a table by key column
            </summary>
        </member>
        <member name="T:dnlib.DotNet.MD.MetadataBase.SortedTable.RowInfo">
            <summary>
            Remembers <c>rid</c> and key
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataBase.SortedTable.RowInfo.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="rid">Row ID</param>
            <param name="key">Key</param>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataBase.SortedTable.#ctor(dnlib.DotNet.MD.MDTable,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="mdTable">The MD table</param>
            <param name="keyColIndex">Index of key column</param>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataBase.SortedTable.BinarySearch(System.UInt32)">
            <summary>
            Binary searches for a row with a certain key
            </summary>
            <param name="key">The key</param>
            <returns>The row or 0 if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataBase.SortedTable.FindAllRows(System.UInt32)">
            <summary>
            Find all rids that contain <paramref name="key"/>
            </summary>
            <param name="key">The key</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.RidList"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataBase.#ctor(dnlib.PE.IPEImage,dnlib.DotNet.MD.ImageCor20Header,dnlib.DotNet.MD.MetadataHeader)">
            <summary>
            Constructor
            </summary>
            <param name="peImage">The PE image</param>
            <param name="cor20Header">The .NET header</param>
            <param name="mdHeader">The MD header</param>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataBase.Initialize(dnlib.IO.DataReaderFactory)">
            <summary>
            Initializes the metadata, tables, streams
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataBase.InitializeNonExistentHeaps">
            <summary>
            Creates empty heap objects if they're not present in the metadata
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataBase.InitializeInternal(dnlib.IO.DataReaderFactory,System.UInt32)">
            <summary>
            Called by <see cref="M:dnlib.DotNet.MD.MetadataBase.Initialize(dnlib.IO.DataReaderFactory)"/>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataBase.BinarySearch(dnlib.DotNet.MD.MDTable,System.Int32,System.UInt32)">
            <summary>
            Binary searches the table for a <c>rid</c> whose key column at index
            <paramref name="keyColIndex"/> is equal to <paramref name="key"/>.
            </summary>
            <param name="tableSource">Table to search</param>
            <param name="keyColIndex">Key column index</param>
            <param name="key">Key</param>
            <returns>The <c>rid</c> of the found row, or 0 if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataBase.FindAllRows(dnlib.DotNet.MD.MDTable,System.Int32,System.UInt32)">
            <summary>
            Finds all rows owned by <paramref name="key"/> in table <paramref name="tableSource"/>
            whose index is <paramref name="keyColIndex"/>
            </summary>
            <param name="tableSource">Table to search</param>
            <param name="keyColIndex">Key column index</param>
            <param name="key">Key</param>
            <returns>A <see cref="T:dnlib.DotNet.MD.RidList"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataBase.FindAllRowsUnsorted(dnlib.DotNet.MD.MDTable,System.Int32,System.UInt32)">
            <summary>
            Finds all rows owned by <paramref name="key"/> in table <paramref name="tableSource"/>
            whose index is <paramref name="keyColIndex"/>. Should be called if <paramref name="tableSource"/>
            could be unsorted.
            </summary>
            <param name="tableSource">Table to search</param>
            <param name="keyColIndex">Key column index</param>
            <param name="key">Key</param>
            <returns>A <see cref="T:dnlib.DotNet.MD.RidList"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataBase.Dispose(System.Boolean)">
            <summary>
            Dispose method
            </summary>
            <param name="disposing"><c>true</c> if called by <see cref="M:dnlib.DotNet.MD.MetadataBase.Dispose"/></param>
        </member>
        <member name="T:dnlib.DotNet.MD.MetadataFactory">
            <summary>
            Low level access to a .NET file's metadata
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataFactory.Load(System.String)">
            <summary>
            Create a <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance
            </summary>
            <param name="fileName">The file to load</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataFactory.Load(System.Byte[])">
            <summary>
            Create a <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance
            </summary>
            <param name="data">The .NET file data</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataFactory.Load(System.IntPtr)">
            <summary>
            Create a <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance
            </summary>
            <param name="addr">Address of a .NET file in memory</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataFactory.Load(System.IntPtr,dnlib.PE.ImageLayout)">
            <summary>
            Create a <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance
            </summary>
            <param name="addr">Address of a .NET file in memory</param>
            <param name="imageLayout">Image layout of the file in memory</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataFactory.Load(dnlib.PE.IPEImage)">
            <summary>
            Create a <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance
            </summary>
            <param name="peImage">The PE image</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataFactory.CreateMetadata(dnlib.PE.IPEImage)">
            <summary>
            Create a <see cref="T:dnlib.DotNet.MD.Metadata"/> instance
            </summary>
            <param name="peImage">The PE image</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.Metadata"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataFactory.CreateMetadata(dnlib.PE.IPEImage,System.Boolean)">
            <summary>
            Create a <see cref="T:dnlib.DotNet.MD.Metadata"/> instance
            </summary>
            <param name="peImage">The PE image</param>
            <param name="verify"><c>true</c> if we should verify that it's a .NET PE file</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.Metadata"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataFactory.Create(dnlib.PE.IPEImage,System.Boolean)">
            <summary>
            Create a <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance
            </summary>
            <param name="peImage">The PE image</param>
            <param name="verify"><c>true</c> if we should verify that it's a .NET PE file</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataFactory.CreateStandalonePortablePDB(dnlib.IO.DataReaderFactory,System.Boolean)">
            <summary>
            Create a standalone portable PDB <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance
            </summary>
            <param name="mdReaderFactory">Metadata stream</param>
            <param name="verify"><c>true</c> if we should verify that it's a .NET PE file</param>
            <returns>A new <see cref="T:dnlib.DotNet.MD.MetadataBase"/> instance</returns>
        </member>
        <member name="T:dnlib.DotNet.MD.MetadataHeader">
            <summary>
            Represents the .NET metadata header
            </summary>
            <remarks><c>IMAGE_COR20_HEADER.Metadata</c> points to this header</remarks>
        </member>
        <member name="P:dnlib.DotNet.MD.MetadataHeader.Signature">
            <summary>
            Returns the signature (should be 0x424A5342)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MetadataHeader.MajorVersion">
            <summary>
            Returns the major version
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MetadataHeader.MinorVersion">
            <summary>
            Returns the minor version
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MetadataHeader.Reserved1">
            <summary>
            Returns the reserved dword (pointer to extra header data)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MetadataHeader.StringLength">
            <summary>
            Returns the version string length value
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MetadataHeader.VersionString">
            <summary>
            Returns the version string
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MetadataHeader.StorageHeaderOffset">
            <summary>
            Returns the offset of <c>STORAGEHEADER</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MetadataHeader.Flags">
            <summary>
            Returns the flags (reserved)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MetadataHeader.Reserved2">
            <summary>
            Returns the reserved byte (padding)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MetadataHeader.Streams">
            <summary>
            Returns the number of streams
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.MetadataHeader.StreamHeaders">
            <summary>
            Returns all stream headers
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.MetadataHeader.#ctor(dnlib.IO.DataReader@,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="reader">PE file reader pointing to the start of this section</param>
            <param name="verify">Verify section</param>
            <exception cref="T:System.BadImageFormatException">Thrown if verification fails</exception>
        </member>
        <member name="T:dnlib.DotNet.MD.PdbStream">
            <summary>
            #Pdb stream
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.PdbStream.Id">
            <summary>
            Gets the PDB id
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.PdbStream.EntryPoint">
            <summary>
            Gets the entry point token or 0
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.PdbStream.ReferencedTypeSystemTables">
            <summary>
            Gets the referenced type system tables in the PE metadata file
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.PdbStream.TypeSystemTableRows">
            <summary>
            Gets all type system table rows. This array has exactly 64 elements.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.PdbStream.#ctor(dnlib.IO.DataReaderFactory,System.UInt32,dnlib.DotNet.MD.StreamHeader)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.MD.RawRowEqualityComparer">
            <summary>
            Equality comparer for all raw rows
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.RawRowEqualityComparer.Instance">
            <summary>
            Default instance
            </summary>
        </member>
        <member name="T:dnlib.DotNet.MD.RawModuleRow">
            <summary>
            Raw contents of an uncompressed Module table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawModuleRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawTypeRefRow">
            <summary>
            Raw contents of an uncompressed TypeRef table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawTypeRefRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawTypeDefRow">
            <summary>
            Raw contents of an uncompressed TypeDef table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawTypeDefRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawFieldPtrRow">
            <summary>
            Raw contents of an uncompressed FieldPtr table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawFieldPtrRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawFieldRow">
            <summary>
            Raw contents of an uncompressed Field table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawFieldRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawMethodPtrRow">
            <summary>
            Raw contents of an uncompressed MethodPtr table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawMethodPtrRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawMethodRow">
            <summary>
            Raw contents of an uncompressed Method table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawMethodRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawParamPtrRow">
            <summary>
            Raw contents of an uncompressed ParamPtr table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawParamPtrRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawParamRow">
            <summary>
            Raw contents of an uncompressed Param table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawParamRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawInterfaceImplRow">
            <summary>
            Raw contents of an uncompressed InterfaceImpl table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawInterfaceImplRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawMemberRefRow">
            <summary>
            Raw contents of an uncompressed MemberRef table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawMemberRefRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawConstantRow">
            <summary>
            Raw contents of an uncompressed Constant table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawConstantRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawCustomAttributeRow">
            <summary>
            Raw contents of an uncompressed CustomAttribute table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawCustomAttributeRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawFieldMarshalRow">
            <summary>
            Raw contents of an uncompressed FieldMarshal table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawFieldMarshalRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawDeclSecurityRow">
            <summary>
            Raw contents of an uncompressed DeclSecurity table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawDeclSecurityRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawClassLayoutRow">
            <summary>
            Raw contents of an uncompressed ClassLayout table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawClassLayoutRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawFieldLayoutRow">
            <summary>
            Raw contents of an uncompressed FieldLayout table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawFieldLayoutRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawStandAloneSigRow">
            <summary>
            Raw contents of an uncompressed StandAloneSig table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawStandAloneSigRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawEventMapRow">
            <summary>
            Raw contents of an uncompressed EventMap table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawEventMapRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawEventPtrRow">
            <summary>
            Raw contents of an uncompressed EventPtr table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawEventPtrRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawEventRow">
            <summary>
            Raw contents of an uncompressed Event table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawEventRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawPropertyMapRow">
            <summary>
            Raw contents of an uncompressed PropertyMap table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawPropertyMapRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawPropertyPtrRow">
            <summary>
            Raw contents of an uncompressed PropertyPtr table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawPropertyPtrRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawPropertyRow">
            <summary>
            Raw contents of an uncompressed Property table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawPropertyRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawMethodSemanticsRow">
            <summary>
            Raw contents of an uncompressed MethodSemantics table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawMethodSemanticsRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawMethodImplRow">
            <summary>
            Raw contents of an uncompressed MethodImpl table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawMethodImplRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawModuleRefRow">
            <summary>
            Raw contents of an uncompressed ModuleRef table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawModuleRefRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawTypeSpecRow">
            <summary>
            Raw contents of an uncompressed TypeSpec table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawTypeSpecRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawImplMapRow">
            <summary>
            Raw contents of an uncompressed ImplMap table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawImplMapRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawFieldRVARow">
            <summary>
            Raw contents of an uncompressed FieldRVA table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawFieldRVARow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawENCLogRow">
            <summary>
            Raw contents of an uncompressed ENCLog table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawENCLogRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawENCMapRow">
            <summary>
            Raw contents of an uncompressed ENCMap table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawENCMapRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawAssemblyRow">
            <summary>
            Raw contents of an uncompressed Assembly table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawAssemblyRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawAssemblyProcessorRow">
            <summary>
            Raw contents of an uncompressed AssemblyProcessor table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawAssemblyProcessorRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawAssemblyOSRow">
            <summary>
            Raw contents of an uncompressed AssemblyOS table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawAssemblyOSRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawAssemblyRefRow">
            <summary>
            Raw contents of an uncompressed AssemblyRef table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawAssemblyRefRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawAssemblyRefProcessorRow">
            <summary>
            Raw contents of an uncompressed AssemblyRefProcessor table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawAssemblyRefProcessorRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawAssemblyRefOSRow">
            <summary>
            Raw contents of an uncompressed AssemblyRefOS table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawAssemblyRefOSRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawFileRow">
            <summary>
            Raw contents of an uncompressed File table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawFileRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawExportedTypeRow">
            <summary>
            Raw contents of an uncompressed ExportedType table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawExportedTypeRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawManifestResourceRow">
            <summary>
            Raw contents of an uncompressed ManifestResource table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawManifestResourceRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawNestedClassRow">
            <summary>
            Raw contents of an uncompressed NestedClass table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawNestedClassRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawGenericParamRow">
            <summary>
            Raw contents of an uncompressed GenericParam table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawGenericParamRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawMethodSpecRow">
            <summary>
            Raw contents of an uncompressed MethodSpec table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawMethodSpecRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawGenericParamConstraintRow">
            <summary>
            Raw contents of an uncompressed GenericParamConstraint table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawGenericParamConstraintRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawDocumentRow">
            <summary>
            Raw contents of an uncompressed Document table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawDocumentRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawMethodDebugInformationRow">
            <summary>
            Raw contents of an uncompressed MethodDebugInformation table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawMethodDebugInformationRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawLocalScopeRow">
            <summary>
            Raw contents of an uncompressed LocalScope table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawLocalScopeRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawLocalVariableRow">
            <summary>
            Raw contents of an uncompressed LocalVariable table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawLocalVariableRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawLocalConstantRow">
            <summary>
            Raw contents of an uncompressed LocalConstant table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawLocalConstantRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawImportScopeRow">
            <summary>
            Raw contents of an uncompressed ImportScope table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawImportScopeRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawStateMachineMethodRow">
            <summary>
            Raw contents of an uncompressed StateMachineMethod table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawStateMachineMethodRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RawCustomDebugInformationRow">
            <summary>
            Raw contents of an uncompressed CustomDebugInformation table row
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RawCustomDebugInformationRow.Item(System.Int32)">
            <summary>
            Gets a column
            </summary>
            <param name="index">Index of column</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.RidList">
            <summary>
            Stores a list of rids
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.RidList.Empty">
            <summary>
            Gets the empty instance
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.RidList.Create(System.UInt32,System.UInt32)">
            <summary>
            Creates a new instance
            </summary>
            <param name="startRid"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.RidList.Create(System.Collections.Generic.IList{System.UInt32})">
            <summary>
            Creates a new instance
            </summary>
            <param name="rids">List of valid rids</param>
            <returns></returns>
        </member>
        <member name="P:dnlib.DotNet.MD.RidList.Item(System.Int32)">
            <summary>
            Gets the <paramref name="index"/>'th rid
            </summary>
            <param name="index">Index. Must be &lt; <see cref="P:dnlib.DotNet.MD.RidList.Count"/></param>
            <returns>A rid or 0 if <paramref name="index"/> is invalid</returns>
        </member>
        <member name="P:dnlib.DotNet.MD.RidList.Count">
            <summary>
            Gets the number of rids it will iterate over
            </summary>
        </member>
        <member name="T:dnlib.DotNet.MD.RidList.Enumerator">
            <summary>
            Enumerator
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.RidList.Enumerator.Current">
            <summary>
            Gets the current rid
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.RidList.Enumerator.Dispose">
            <summary>
            Disposes this instance
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.RidList.Enumerator.MoveNext">
            <summary>
            Moves to the next rid
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.RidList.GetEnumerator">
            <summary>
            Gets the enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.MD.StorageFlags">
            <summary>
            Storage flags found in the MD header
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.StorageFlags.Normal">
            <summary>
            Normal flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.StorageFlags.ExtraData">
            <summary>
            More data after the header but before the streams.
            </summary>
            <remarks>The CLR will fail to load the file if this flag (or any other bits) is set.</remarks>
        </member>
        <member name="T:dnlib.DotNet.MD.StreamHeader">
            <summary>
            A metadata stream header
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.StreamHeader.Offset">
            <summary>
            The offset of the stream relative to the start of the metadata header
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.StreamHeader.StreamSize">
            <summary>
            The size of the stream
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.StreamHeader.Name">
            <summary>
            The name of the stream
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.StreamHeader.#ctor(dnlib.IO.DataReader@,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="reader">PE file reader pointing to the start of this section</param>
            <param name="verify">Verify section</param>
            <exception cref="T:System.BadImageFormatException">Thrown if verification fails</exception>
        </member>
        <member name="T:dnlib.DotNet.MD.StringsStream">
            <summary>
            Represents the #Strings stream
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.StringsStream.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.StringsStream.#ctor(dnlib.IO.DataReaderFactory,System.UInt32,dnlib.DotNet.MD.StreamHeader)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.StringsStream.Read(System.UInt32)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.UTF8String"/>
            </summary>
            <param name="offset">Offset of string</param>
            <returns>A <see cref="T:dnlib.DotNet.UTF8String"/> instance or <c>null</c> if invalid offset</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.StringsStream.ReadNoNull(System.UInt32)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.UTF8String"/>. The empty string is returned if <paramref name="offset"/>
            is invalid.
            </summary>
            <param name="offset">Offset of string</param>
            <returns>A <see cref="T:dnlib.DotNet.UTF8String"/> instance</returns>
        </member>
        <member name="T:dnlib.DotNet.MD.Table">
            <summary>
            The metadata tables
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.Module">
            <summary>Module table (00h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.TypeRef">
            <summary>TypeRef table (01h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.TypeDef">
            <summary>TypeDef table (02h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.FieldPtr">
            <summary>FieldPtr table (03h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.Field">
            <summary>Field table (04h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.MethodPtr">
            <summary>MethodPtr table (05h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.Method">
            <summary>Method table (06h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.ParamPtr">
            <summary>ParamPtr table (07h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.Param">
            <summary>Param table (08h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.InterfaceImpl">
            <summary>InterfaceImpl table (09h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.MemberRef">
            <summary>MemberRef table (0Ah)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.Constant">
            <summary>Constant table (0Bh)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.CustomAttribute">
            <summary>CustomAttribute table (0Ch)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.FieldMarshal">
            <summary>FieldMarshal table (0Dh)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.DeclSecurity">
            <summary>DeclSecurity table (0Eh)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.ClassLayout">
            <summary>ClassLayout table (0Fh)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.FieldLayout">
            <summary>FieldLayout table (10h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.StandAloneSig">
            <summary>StandAloneSig table (11h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.EventMap">
            <summary>EventMap table (12h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.EventPtr">
            <summary>EventPtr table (13h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.Event">
            <summary>Event table (14h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.PropertyMap">
            <summary>PropertyMap table (15h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.PropertyPtr">
            <summary>PropertyPtr table (16h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.Property">
            <summary>Property table (17h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.MethodSemantics">
            <summary>MethodSemantics table (18h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.MethodImpl">
            <summary>MethodImpl table (19h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.ModuleRef">
            <summary>ModuleRef table (1Ah)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.TypeSpec">
            <summary>TypeSpec table (1Bh)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.ImplMap">
            <summary>ImplMap table (1Ch)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.FieldRVA">
            <summary>FieldRVA table (1Dh)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.ENCLog">
            <summary>ENCLog table (1Eh)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.ENCMap">
            <summary>ENCMap table (1Fh)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.Assembly">
            <summary>Assembly table (20h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.AssemblyProcessor">
            <summary>AssemblyProcessor table (21h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.AssemblyOS">
            <summary>AssemblyOS table (22h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.AssemblyRef">
            <summary>AssemblyRef table (23h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.AssemblyRefProcessor">
            <summary>AssemblyRefProcessor table (24h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.AssemblyRefOS">
            <summary>AssemblyRefOS table (25h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.File">
            <summary>File table (26h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.ExportedType">
            <summary>ExportedType table (27h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.ManifestResource">
            <summary>ManifestResource table (28h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.NestedClass">
            <summary>NestedClass table (29h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.GenericParam">
            <summary>GenericParam table (2Ah)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.MethodSpec">
            <summary>MethodSpec table (2Bh)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.GenericParamConstraint">
            <summary>GenericParamConstraint table (2Ch)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.Document">
            <summary>(Portable PDB) Document table (30h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.MethodDebugInformation">
            <summary>(Portable PDB) MethodDebugInformation table (31h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.LocalScope">
            <summary>(Portable PDB) LocalScope table (32h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.LocalVariable">
            <summary>(Portable PDB) LocalVariable table (33h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.LocalConstant">
            <summary>(Portable PDB) LocalConstant table (34h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.ImportScope">
            <summary>(Portable PDB) ImportScope table (35h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.StateMachineMethod">
            <summary>(Portable PDB) StateMachineMethod table (36h)</summary>
        </member>
        <member name="F:dnlib.DotNet.MD.Table.CustomDebugInformation">
            <summary>(Portable PDB) CustomDebugInformation table (37h)</summary>
        </member>
        <member name="T:dnlib.DotNet.MD.TableInfo">
            <summary>
            Info about one MD table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TableInfo.Table">
            <summary>
            Returns the table type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TableInfo.RowSize">
            <summary>
            Returns the total size of a row in bytes
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TableInfo.Columns">
            <summary>
            Returns all the columns
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TableInfo.Name">
            <summary>
            Returns the name of the table
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.TableInfo.#ctor(dnlib.DotNet.MD.Table,System.String,dnlib.DotNet.MD.ColumnInfo[])">
            <summary>
            Constructor
            </summary>
            <param name="table">Table type</param>
            <param name="name">Table name</param>
            <param name="columns">All columns</param>
        </member>
        <member name="M:dnlib.DotNet.MD.TableInfo.#ctor(dnlib.DotNet.MD.Table,System.String,dnlib.DotNet.MD.ColumnInfo[],System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="table">Table type</param>
            <param name="name">Table name</param>
            <param name="columns">All columns</param>
            <param name="rowSize">Row size</param>
        </member>
        <member name="T:dnlib.DotNet.MD.TablesStream">
            <summary>
            .NET metadata tables stream
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.ColumnReader">
            <summary>
            Gets/sets the column reader
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.MethodRowReader">
            <summary>
            Gets/sets the <c>Method</c> table reader
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.Reserved1">
            <summary>
            Gets the reserved field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.Version">
            <summary>
            Gets the version. The major version is in the upper 8 bits, and the minor version
            is in the lower 8 bits.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.Flags">
            <summary>
            Gets <see cref="T:dnlib.DotNet.MD.MDStreamFlags"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.Log2Rid">
            <summary>
            Gets the reserved log2 rid field
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.ValidMask">
            <summary>
            Gets the valid mask
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.SortedMask">
            <summary>
            Gets the sorted mask
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.ExtraData">
            <summary>
            Gets the extra data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.MDTables">
            <summary>
            Gets the MD tables
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.HasBigStrings">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.MD.MDStreamFlags.BigStrings"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.HasBigGUID">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.MD.MDStreamFlags.BigGUID"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.HasBigBlob">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.MD.MDStreamFlags.BigBlob"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.HasPadding">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.MD.MDStreamFlags.Padding"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.HasDeltaOnly">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.MD.MDStreamFlags.DeltaOnly"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.HasExtraData">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.MD.MDStreamFlags.ExtraData"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MD.TablesStream.HasDelete">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.MD.MDStreamFlags.HasDelete"/> bit
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.#ctor(dnlib.IO.DataReaderFactory,System.UInt32,dnlib.DotNet.MD.StreamHeader)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.Initialize(System.UInt32[])">
            <summary>
            Initializes MD tables
            </summary>
            <param name="typeSystemTableRows">Type system table rows (from #Pdb stream)</param>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.OnReaderRecreated">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.Get(dnlib.DotNet.MD.Table)">
            <summary>
            Returns a MD table
            </summary>
            <param name="table">The table type</param>
            <returns>A <see cref="T:dnlib.DotNet.MD.MDTable"/> or <c>null</c> if table doesn't exist</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.HasTable(dnlib.DotNet.MD.Table)">
            <summary>
            Checks whether a table exists
            </summary>
            <param name="table">The table type</param>
            <returns><c>true</c> if the table exists</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.IsSorted(dnlib.DotNet.MD.MDTable)">
            <summary>
            Checks whether table <paramref name="table"/> is sorted
            </summary>
            <param name="table">The table</param>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadModuleRow(System.UInt32,dnlib.DotNet.MD.RawModuleRow@)">
            <summary>
            Reads a raw <c>Module</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadTypeRefRow(System.UInt32,dnlib.DotNet.MD.RawTypeRefRow@)">
            <summary>
            Reads a raw <c>TypeRef</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadTypeDefRow(System.UInt32,dnlib.DotNet.MD.RawTypeDefRow@)">
            <summary>
            Reads a raw <c>TypeDef</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadFieldPtrRow(System.UInt32,dnlib.DotNet.MD.RawFieldPtrRow@)">
            <summary>
            Reads a raw <c>FieldPtr</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadFieldRow(System.UInt32,dnlib.DotNet.MD.RawFieldRow@)">
            <summary>
            Reads a raw <c>Field</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadMethodPtrRow(System.UInt32,dnlib.DotNet.MD.RawMethodPtrRow@)">
            <summary>
            Reads a raw <c>MethodPtr</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadMethodRow(System.UInt32,dnlib.DotNet.MD.RawMethodRow@)">
            <summary>
            Reads a raw <c>Method</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadParamPtrRow(System.UInt32,dnlib.DotNet.MD.RawParamPtrRow@)">
            <summary>
            Reads a raw <c>ParamPtr</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadParamRow(System.UInt32,dnlib.DotNet.MD.RawParamRow@)">
            <summary>
            Reads a raw <c>Param</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadInterfaceImplRow(System.UInt32,dnlib.DotNet.MD.RawInterfaceImplRow@)">
            <summary>
            Reads a raw <c>InterfaceImpl</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadMemberRefRow(System.UInt32,dnlib.DotNet.MD.RawMemberRefRow@)">
            <summary>
            Reads a raw <c>MemberRef</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadConstantRow(System.UInt32,dnlib.DotNet.MD.RawConstantRow@)">
            <summary>
            Reads a raw <c>Constant</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadCustomAttributeRow(System.UInt32,dnlib.DotNet.MD.RawCustomAttributeRow@)">
            <summary>
            Reads a raw <c>CustomAttribute</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadFieldMarshalRow(System.UInt32,dnlib.DotNet.MD.RawFieldMarshalRow@)">
            <summary>
            Reads a raw <c>FieldMarshal</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadDeclSecurityRow(System.UInt32,dnlib.DotNet.MD.RawDeclSecurityRow@)">
            <summary>
            Reads a raw <c>DeclSecurity</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadClassLayoutRow(System.UInt32,dnlib.DotNet.MD.RawClassLayoutRow@)">
            <summary>
            Reads a raw <c>ClassLayout</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadFieldLayoutRow(System.UInt32,dnlib.DotNet.MD.RawFieldLayoutRow@)">
            <summary>
            Reads a raw <c>FieldLayout</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadStandAloneSigRow(System.UInt32,dnlib.DotNet.MD.RawStandAloneSigRow@)">
            <summary>
            Reads a raw <c>StandAloneSig</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadEventMapRow(System.UInt32,dnlib.DotNet.MD.RawEventMapRow@)">
            <summary>
            Reads a raw <c>EventMap</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadEventPtrRow(System.UInt32,dnlib.DotNet.MD.RawEventPtrRow@)">
            <summary>
            Reads a raw <c>EventPtr</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadEventRow(System.UInt32,dnlib.DotNet.MD.RawEventRow@)">
            <summary>
            Reads a raw <c>Event</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadPropertyMapRow(System.UInt32,dnlib.DotNet.MD.RawPropertyMapRow@)">
            <summary>
            Reads a raw <c>PropertyMap</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadPropertyPtrRow(System.UInt32,dnlib.DotNet.MD.RawPropertyPtrRow@)">
            <summary>
            Reads a raw <c>PropertyPtr</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadPropertyRow(System.UInt32,dnlib.DotNet.MD.RawPropertyRow@)">
            <summary>
            Reads a raw <c>Property</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadMethodSemanticsRow(System.UInt32,dnlib.DotNet.MD.RawMethodSemanticsRow@)">
            <summary>
            Reads a raw <c>MethodSemantics</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadMethodImplRow(System.UInt32,dnlib.DotNet.MD.RawMethodImplRow@)">
            <summary>
            Reads a raw <c>MethodImpl</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadModuleRefRow(System.UInt32,dnlib.DotNet.MD.RawModuleRefRow@)">
            <summary>
            Reads a raw <c>ModuleRef</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadTypeSpecRow(System.UInt32,dnlib.DotNet.MD.RawTypeSpecRow@)">
            <summary>
            Reads a raw <c>TypeSpec</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadImplMapRow(System.UInt32,dnlib.DotNet.MD.RawImplMapRow@)">
            <summary>
            Reads a raw <c>ImplMap</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadFieldRVARow(System.UInt32,dnlib.DotNet.MD.RawFieldRVARow@)">
            <summary>
            Reads a raw <c>FieldRVA</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadENCLogRow(System.UInt32,dnlib.DotNet.MD.RawENCLogRow@)">
            <summary>
            Reads a raw <c>ENCLog</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadENCMapRow(System.UInt32,dnlib.DotNet.MD.RawENCMapRow@)">
            <summary>
            Reads a raw <c>ENCMap</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadAssemblyRow(System.UInt32,dnlib.DotNet.MD.RawAssemblyRow@)">
            <summary>
            Reads a raw <c>Assembly</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadAssemblyProcessorRow(System.UInt32,dnlib.DotNet.MD.RawAssemblyProcessorRow@)">
            <summary>
            Reads a raw <c>AssemblyProcessor</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadAssemblyOSRow(System.UInt32,dnlib.DotNet.MD.RawAssemblyOSRow@)">
            <summary>
            Reads a raw <c>AssemblyOS</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadAssemblyRefRow(System.UInt32,dnlib.DotNet.MD.RawAssemblyRefRow@)">
            <summary>
            Reads a raw <c>AssemblyRef</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadAssemblyRefProcessorRow(System.UInt32,dnlib.DotNet.MD.RawAssemblyRefProcessorRow@)">
            <summary>
            Reads a raw <c>AssemblyRefProcessor</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadAssemblyRefOSRow(System.UInt32,dnlib.DotNet.MD.RawAssemblyRefOSRow@)">
            <summary>
            Reads a raw <c>AssemblyRefOS</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadFileRow(System.UInt32,dnlib.DotNet.MD.RawFileRow@)">
            <summary>
            Reads a raw <c>File</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadExportedTypeRow(System.UInt32,dnlib.DotNet.MD.RawExportedTypeRow@)">
            <summary>
            Reads a raw <c>ExportedType</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadManifestResourceRow(System.UInt32,dnlib.DotNet.MD.RawManifestResourceRow@)">
            <summary>
            Reads a raw <c>ManifestResource</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadNestedClassRow(System.UInt32,dnlib.DotNet.MD.RawNestedClassRow@)">
            <summary>
            Reads a raw <c>NestedClass</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadGenericParamRow(System.UInt32,dnlib.DotNet.MD.RawGenericParamRow@)">
            <summary>
            Reads a raw <c>GenericParam</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadMethodSpecRow(System.UInt32,dnlib.DotNet.MD.RawMethodSpecRow@)">
            <summary>
            Reads a raw <c>MethodSpec</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadGenericParamConstraintRow(System.UInt32,dnlib.DotNet.MD.RawGenericParamConstraintRow@)">
            <summary>
            Reads a raw <c>GenericParamConstraint</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadDocumentRow(System.UInt32,dnlib.DotNet.MD.RawDocumentRow@)">
            <summary>
            Reads a raw <c>Document</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadMethodDebugInformationRow(System.UInt32,dnlib.DotNet.MD.RawMethodDebugInformationRow@)">
            <summary>
            Reads a raw <c>MethodDebugInformation</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadLocalScopeRow(System.UInt32,dnlib.DotNet.MD.RawLocalScopeRow@)">
            <summary>
            Reads a raw <c>LocalScope</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadLocalVariableRow(System.UInt32,dnlib.DotNet.MD.RawLocalVariableRow@)">
            <summary>
            Reads a raw <c>LocalVariable</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadLocalConstantRow(System.UInt32,dnlib.DotNet.MD.RawLocalConstantRow@)">
            <summary>
            Reads a raw <c>LocalConstant</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadImportScopeRow(System.UInt32,dnlib.DotNet.MD.RawImportScopeRow@)">
            <summary>
            Reads a raw <c>ImportScope</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadStateMachineMethodRow(System.UInt32,dnlib.DotNet.MD.RawStateMachineMethodRow@)">
            <summary>
            Reads a raw <c>StateMachineMethod</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadCustomDebugInformationRow(System.UInt32,dnlib.DotNet.MD.RawCustomDebugInformationRow@)">
            <summary>
            Reads a raw <c>CustomDebugInformation</c> row or returns false if the row doesn't exist
            </summary>
            <param name="rid">Row ID</param>
            <param name="row">Row data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadColumn(dnlib.DotNet.MD.MDTable,System.UInt32,System.Int32,System.UInt32@)">
            <summary>
            Reads a column
            </summary>
            <param name="table">The table</param>
            <param name="rid">Row ID</param>
            <param name="colIndex">Column index in <paramref name="table"/></param>
            <param name="value">Result is put here or 0 if we return <c>false</c></param>
            <returns><c>true</c> if we could read the column, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.TablesStream.TryReadColumn(dnlib.DotNet.MD.MDTable,System.UInt32,dnlib.DotNet.MD.ColumnInfo,System.UInt32@)">
            <summary>
            Reads a column
            </summary>
            <param name="table">The table</param>
            <param name="rid">Row ID</param>
            <param name="column">Column</param>
            <param name="value">Result is put here or 0 if we return <c>false</c></param>
            <returns><c>true</c> if we could read the column, <c>false</c> otherwise</returns>
        </member>
        <member name="T:dnlib.DotNet.MD.USStream">
            <summary>
            Represents the #US stream
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MD.USStream.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.USStream.#ctor(dnlib.IO.DataReaderFactory,System.UInt32,dnlib.DotNet.MD.StreamHeader)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MD.USStream.Read(System.UInt32)">
            <summary>
            Reads a unicode string
            </summary>
            <param name="offset">Offset of unicode string</param>
            <returns>A string or <c>null</c> if <paramref name="offset"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.MD.USStream.ReadNoNull(System.UInt32)">
            <summary>
            Reads data just like <see cref="M:dnlib.DotNet.MD.USStream.Read(System.UInt32)"/>, but returns an empty string if
            offset is invalid
            </summary>
            <param name="offset">Offset of unicode string</param>
            <returns>The string</returns>
        </member>
        <member name="T:dnlib.DotNet.MemberFinder">
            <summary>
            Finds types, fields, methods, etc in a module. If nothing has been added to the module, it's
            faster to call ResolveMethodDef(), ResolveTypeRef() etc.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberFinder.CustomAttributes">
            <summary>
            All found <see cref="T:dnlib.DotNet.CustomAttribute"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberFinder.EventDefs">
            <summary>
            All found <see cref="T:dnlib.DotNet.EventDef"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberFinder.FieldDefs">
            <summary>
            All found <see cref="T:dnlib.DotNet.FieldDef"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberFinder.GenericParams">
            <summary>
            All found <see cref="T:dnlib.DotNet.GenericParam"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberFinder.MemberRefs">
            <summary>
            All found <see cref="T:dnlib.DotNet.MemberRef"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberFinder.MethodDefs">
            <summary>
            All found <see cref="T:dnlib.DotNet.MethodDef"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberFinder.MethodSpecs">
            <summary>
            All found <see cref="T:dnlib.DotNet.MethodSpec"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberFinder.PropertyDefs">
            <summary>
            All found <see cref="T:dnlib.DotNet.PropertyDef"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberFinder.TypeDefs">
            <summary>
            All found <see cref="T:dnlib.DotNet.TypeDef"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberFinder.TypeRefs">
            <summary>
            All found <see cref="T:dnlib.DotNet.TypeRef"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberFinder.TypeSigs">
            <summary>
            All found <see cref="T:dnlib.DotNet.TypeSig"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberFinder.TypeSpecs">
            <summary>
            All found <see cref="T:dnlib.DotNet.TypeSpec"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberFinder.ExportedTypes">
            <summary>
            All found <see cref="T:dnlib.DotNet.ExportedType"/>s
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MemberFinder.FindAll(dnlib.DotNet.ModuleDef)">
            <summary>
            Finds all types, fields, etc
            </summary>
            <param name="module">The module to scan</param>
            <returns>Itself</returns>
        </member>
        <member name="T:dnlib.DotNet.MemberMDInitializer">
            <summary>
            Methods to load properties to make sure they're initialized
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MemberMDInitializer.Initialize``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Read every collection element
            </summary>
            <typeparam name="T">Collection element type</typeparam>
            <param name="coll">Collection</param>
        </member>
        <member name="M:dnlib.DotNet.MemberMDInitializer.Initialize(System.Object)">
            <summary>
            Load the object instance
            </summary>
            <param name="o">The value (ignored)</param>
        </member>
        <member name="T:dnlib.DotNet.MemberRef">
            <summary>
            A high-level representation of a row in the MemberRef table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberRef.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberRef.module">
            <summary>
            The owner module
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.MethodDefOrRefTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.CustomAttributeTypeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.Class">
            <summary>
            From column MemberRef.Class
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberRef.class">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.Name">
            <summary>
            From column MemberRef.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberRef.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.Signature">
            <summary>
            From column MemberRef.Signature
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberRef.signature">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberRef.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.MemberRef.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.MemberRef.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberRef.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.MemberRef.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.MemberRef.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.DeclaringType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.IsMethodRef">
            <summary>
            <c>true</c> if this is a method reference (<see cref="P:dnlib.DotNet.MemberRef.MethodSig"/> != <c>null</c>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.IsFieldRef">
            <summary>
            <c>true</c> if this is a field reference (<see cref="P:dnlib.DotNet.MemberRef.FieldSig"/> != <c>null</c>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.MethodSig">
            <summary>
            Gets/sets the method sig
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.FieldSig">
            <summary>
            Gets/sets the field sig
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.HasThis">
            <summary>
            <c>true</c> if the method has a hidden 'this' parameter
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.ExplicitThis">
            <summary>
            <c>true</c> if the method has an explicit 'this' parameter
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.CallingConvention">
            <summary>
            Gets the calling convention
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.ReturnType">
            <summary>
            Gets/sets the method return type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.dnlib#DotNet#IGenericParameterProvider#NumberOfGenericParameters">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MemberRef.FullName">
            <summary>
            Gets the full name
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MemberRef.GetDeclaringTypeFullName">
            <summary>
            Get the declaring type's full name
            </summary>
            <returns>Full name or <c>null</c> if there's no declaring type</returns>
        </member>
        <member name="M:dnlib.DotNet.MemberRef.Resolve">
            <summary>
            Resolves the method/field
            </summary>
            <returns>A <see cref="T:dnlib.DotNet.MethodDef"/> or a <see cref="T:dnlib.DotNet.FieldDef"/> instance or <c>null</c>
            if it couldn't be resolved.</returns>
        </member>
        <member name="M:dnlib.DotNet.MemberRef.ResolveThrow">
            <summary>
            Resolves the method/field
            </summary>
            <returns>A <see cref="T:dnlib.DotNet.MethodDef"/> or a <see cref="T:dnlib.DotNet.FieldDef"/> instance</returns>
            <exception cref="T:dnlib.DotNet.MemberRefResolveException">If the method/field couldn't be resolved</exception>
        </member>
        <member name="M:dnlib.DotNet.MemberRef.ResolveField">
            <summary>
            Resolves the field
            </summary>
            <returns>A <see cref="T:dnlib.DotNet.FieldDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
        </member>
        <member name="M:dnlib.DotNet.MemberRef.ResolveFieldThrow">
            <summary>
            Resolves the field
            </summary>
            <returns>A <see cref="T:dnlib.DotNet.FieldDef"/> instance</returns>
            <exception cref="T:dnlib.DotNet.MemberRefResolveException">If the field couldn't be resolved</exception>
        </member>
        <member name="M:dnlib.DotNet.MemberRef.ResolveMethod">
            <summary>
            Resolves the method
            </summary>
            <returns>A <see cref="T:dnlib.DotNet.MethodDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
        </member>
        <member name="M:dnlib.DotNet.MemberRef.ResolveMethodThrow">
            <summary>
            Resolves the method
            </summary>
            <returns>A <see cref="T:dnlib.DotNet.MethodDef"/> instance</returns>
            <exception cref="T:dnlib.DotNet.MemberRefResolveException">If the method couldn't be resolved</exception>
        </member>
        <member name="M:dnlib.DotNet.MemberRef.GetSignatureGenericParamContext(dnlib.DotNet.GenericParamContext,dnlib.DotNet.IMemberRefParent)">
            <summary>
            Gets a <see cref="T:dnlib.DotNet.GenericParamContext"/> that can be used as signature context
            </summary>
            <param name="gpContext">Context passed to the constructor</param>
            <param name="class">Field/method class owner</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.MemberRef.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.MemberRefUser">
            <summary>
            A MemberRef row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MemberRefUser.#ctor(dnlib.DotNet.ModuleDef)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
        </member>
        <member name="M:dnlib.DotNet.MemberRefUser.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
            <param name="name">Name of ref</param>
        </member>
        <member name="M:dnlib.DotNet.MemberRefUser.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.UTF8String,dnlib.DotNet.FieldSig)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
            <param name="name">Name of field ref</param>
            <param name="sig">Field sig</param>
        </member>
        <member name="M:dnlib.DotNet.MemberRefUser.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.UTF8String,dnlib.DotNet.FieldSig,dnlib.DotNet.IMemberRefParent)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
            <param name="name">Name of field ref</param>
            <param name="sig">Field sig</param>
            <param name="class">Owner of field</param>
        </member>
        <member name="M:dnlib.DotNet.MemberRefUser.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.UTF8String,dnlib.DotNet.MethodSig)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
            <param name="name">Name of method ref</param>
            <param name="sig">Method sig</param>
        </member>
        <member name="M:dnlib.DotNet.MemberRefUser.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.UTF8String,dnlib.DotNet.MethodSig,dnlib.DotNet.IMemberRefParent)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
            <param name="name">Name of method ref</param>
            <param name="sig">Method sig</param>
            <param name="class">Owner of method</param>
        </member>
        <member name="T:dnlib.DotNet.MemberRefMD">
            <summary>
            Created from a row in the MemberRef table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MemberRefMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.MemberRefMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MemberRefMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MemberRefMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MemberRefMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>MemberRef</c> row</param>
            <param name="rid">Row ID</param>
            <param name="gpContext">Generic parameter context</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.MethodAttributes">
            <summary>
            Method attributes, see CorHdr.h/CorMethodAttr
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.MemberAccessMask">
            <summary>member access mask - Use this mask to retrieve accessibility information.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.PrivateScope">
            <summary>Member not referenceable.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.CompilerControlled">
            <summary>Member not referenceable.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.Private">
            <summary>Accessible only by the parent type.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.FamANDAssem">
            <summary>Accessible by sub-types only in this Assembly.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.Assembly">
            <summary>Accessibly by anyone in the Assembly.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.Family">
            <summary>Accessible only by type and sub-types.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.FamORAssem">
            <summary>Accessibly by sub-types anywhere, plus anyone in assembly.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.Public">
            <summary>Accessibly by anyone who has visibility to this scope.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.Static">
            <summary>Defined on type, else per instance.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.Final">
            <summary>Method may not be overridden.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.Virtual">
            <summary>Method virtual.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.HideBySig">
            <summary>Method hides by name+sig, else just by name.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.VtableLayoutMask">
            <summary>vtable layout mask - Use this mask to retrieve vtable attributes.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.ReuseSlot">
            <summary>The default.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.NewSlot">
            <summary>Method always gets a new slot in the vtable.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.CheckAccessOnOverride">
            <summary>Overridability is the same as the visibility.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.Abstract">
            <summary>Method does not provide an implementation.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.SpecialName">
            <summary>Method is special.  Name describes how.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.PinvokeImpl">
            <summary>Implementation is forwarded through pinvoke.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.PInvokeImpl">
            <summary>Implementation is forwarded through pinvoke.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.UnmanagedExport">
            <summary>Managed method exported via thunk to unmanaged code.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.RTSpecialName">
            <summary>Runtime should check name encoding.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.HasSecurity">
            <summary>Method has security associate with it.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodAttributes.RequireSecObject">
            <summary>Method calls another method containing security code.</summary>
        </member>
        <member name="T:dnlib.DotNet.MethodDef">
            <summary>
            A high-level representation of a row in the Method table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.parameterList">
            <summary>
            All parameters
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasDeclSecurityTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.MemberRefParentTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.MethodDefOrRefTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.MemberForwardedTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.CustomAttributeTypeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.TypeOrMethodDefTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.RVA">
            <summary>
            From column Method.RVA
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.rva">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.ImplAttributes">
            <summary>
            From column Method.ImplFlags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.implAttributes">
            <summary>Implementation attributes</summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.Attributes">
            <summary>
            From column Method.Flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.attributes">
            <summary>Attributes</summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.Name">
            <summary>
            From column Method.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.Signature">
            <summary>
            From column Method.Signature
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.signature">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.ParamDefs">
            <summary>
            From column Method.ParamList
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.paramDefs">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.InitializeParamDefs">
            <summary>Initializes <see cref="F:dnlib.DotNet.MethodDef.paramDefs"/></summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.GenericParameters">
            <inheritdoc/>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.genericParameters">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.InitializeGenericParameters">
            <summary>Initializes <see cref="F:dnlib.DotNet.MethodDef.genericParameters"/></summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.DeclSecurities">
            <inheritdoc/>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.declSecurities">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.InitializeDeclSecurities">
            <summary>Initializes <see cref="F:dnlib.DotNet.MethodDef.declSecurities"/></summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.ImplMap">
            <inheritdoc/>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.implMap">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.implMap_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.GetImplMap_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.MethodDef.implMap"/></summary>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.ResetImplMap">
            <summary>Reset <see cref="P:dnlib.DotNet.MethodDef.ImplMap"/></summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.MethodBody">
            <summary>
            Gets/sets the method body. See also <see cref="P:dnlib.DotNet.MethodDef.Body"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.methodBody">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.methodBody_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.FreeMethodBody">
            <summary>
            Frees the method body if it has been loaded. This does nothing if <see cref="P:dnlib.DotNet.MethodDef.CanFreeMethodBody"/>
            returns <c>false</c>.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.GetMethodBody_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.MethodDef.methodBody"/></summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.CanFreeMethodBody">
            <summary>
            true if <see cref="M:dnlib.DotNet.MethodDef.FreeMethodBody"/> can free the method body
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.MethodDef.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.MethodDef.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.Overrides">
            <summary>
            Gets the methods this method implements
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.overrides">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.InitializeOverrides">
            <summary>Initializes <see cref="F:dnlib.DotNet.MethodDef.overrides"/></summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.ExportInfo">
            <summary>
            Gets the export info or null if the method isn't exported to unmanaged code.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.exportInfo">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasDeclSecurities">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasParamDefs">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.MethodDef.ParamDefs"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.DeclaringType">
            <summary>
            Gets/sets the declaring type (owner type)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.dnlib#DotNet#IMemberRef#DeclaringType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.DeclaringType2">
            <summary>
            Called by <see cref="P:dnlib.DotNet.MethodDef.DeclaringType"/> and should normally not be called by any user
            code. Use <see cref="P:dnlib.DotNet.MethodDef.DeclaringType"/> instead. Only call this if you must set the
            declaring type without inserting it in the declaring type's method list.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.declaringType2">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.Body">
            <summary>
            Gets/sets the CIL method body. See also <see cref="M:dnlib.DotNet.MethodDef.FreeMethodBody"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.NativeBody">
            <summary>
            Gets/sets the native method body
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasGenericParameters">
            <summary>
            <c>true</c> if there's at least one <see cref="T:dnlib.DotNet.GenericParam"/> in <see cref="P:dnlib.DotNet.MethodDef.GenericParameters"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasBody">
            <summary>
            <c>true</c> if it has a <see cref="P:dnlib.DotNet.MethodDef.Body"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasOverrides">
            <summary>
            <c>true</c> if there's at least one <see cref="T:dnlib.DotNet.MethodOverride"/> in <see cref="P:dnlib.DotNet.MethodDef.Overrides"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasImplMap">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.MethodDef.ImplMap"/> is not <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.FullName">
            <summary>
            Gets the full name
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.MethodSig">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.MethodDef.MethodSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.Parameters">
            <summary>
            Gets the parameters
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.dnlib#DotNet#IGenericParameterProvider#NumberOfGenericParameters">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasThis">
            <summary>
            <c>true</c> if the method has a hidden 'this' parameter
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.ExplicitThis">
            <summary>
            <c>true</c> if the method has an explicit 'this' parameter
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.CallingConvention">
            <summary>
            Gets the calling convention
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.ReturnType">
            <summary>
            Gets/sets the method return type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasReturnType">
            <summary>
            <c>true</c> if the method returns a value (i.e., return type is not <see cref="T:System.Void"/>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.SemanticsAttributes">
            <summary>
            Gets/sets the method semantics attributes. If you remove/add a method to a property or
            an event, you must manually update this property or eg. <see cref="P:dnlib.DotNet.MethodDef.IsSetter"/> won't
            work as expected.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.SEMATTRS_INITD">
            <summary>Set when <see cref="F:dnlib.DotNet.MethodDef.semAttrs"/> has been initialized</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDef.semAttrs">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.InitializeSemanticsAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.MethodDef.semAttrs"/></summary>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.ModifyAttributes(System.Boolean,dnlib.DotNet.MethodSemanticsAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.MethodDef.semAttrs"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.ModifyAttributes(dnlib.DotNet.MethodAttributes,dnlib.DotNet.MethodAttributes)">
            <summary>
            Modify <see cref="F:dnlib.DotNet.MethodDef.attributes"/> property: <see cref="F:dnlib.DotNet.MethodDef.attributes"/> =
            (<see cref="F:dnlib.DotNet.MethodDef.attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
            </summary>
            <param name="andMask">Value to <c>AND</c></param>
            <param name="orMask">Value to OR</param>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.ModifyAttributes(System.Boolean,dnlib.DotNet.MethodAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.MethodDef.attributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.ModifyImplAttributes(dnlib.DotNet.MethodImplAttributes,dnlib.DotNet.MethodImplAttributes)">
            <summary>
            Modify <see cref="F:dnlib.DotNet.MethodDef.implAttributes"/> property: <see cref="F:dnlib.DotNet.MethodDef.implAttributes"/> =
            (<see cref="F:dnlib.DotNet.MethodDef.implAttributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
            </summary>
            <param name="andMask">Value to <c>AND</c></param>
            <param name="orMask">Value to OR</param>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.ModifyImplAttributes(System.Boolean,dnlib.DotNet.MethodImplAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.MethodDef.implAttributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.Access">
            <summary>
            Gets/sets the method access
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsCompilerControlled">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.MethodAttributes.PrivateScope"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsPrivateScope">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.MethodAttributes.PrivateScope"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsPrivate">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.MethodAttributes.Private"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsFamilyAndAssembly">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.MethodAttributes.FamANDAssem"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsAssembly">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.MethodAttributes.Assembly"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsFamily">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.MethodAttributes.Family"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsFamilyOrAssembly">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.MethodAttributes.FamORAssem"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsPublic">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.MethodAttributes.Public"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsStatic">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.Static"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsFinal">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.Final"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsVirtual">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.Virtual"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsHideBySig">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.HideBySig"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsNewSlot">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.NewSlot"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsReuseSlot">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.ReuseSlot"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsCheckAccessOnOverride">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.CheckAccessOnOverride"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsAbstract">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.Abstract"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsSpecialName">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.SpecialName"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsPinvokeImpl">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.PinvokeImpl"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsUnmanagedExport">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.UnmanagedExport"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsRuntimeSpecialName">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.RTSpecialName"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasSecurity">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.HasSecurity"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsRequireSecObject">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodAttributes.RequireSecObject"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.CodeType">
            <summary>
            Gets/sets the code type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsIL">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.MethodImplAttributes.IL"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsNative">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.MethodImplAttributes.Native"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsOPTIL">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.MethodImplAttributes.OPTIL"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsRuntime">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.MethodImplAttributes.Runtime"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsUnmanaged">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodImplAttributes.Unmanaged"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsManaged">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodImplAttributes.Managed"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsForwardRef">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodImplAttributes.ForwardRef"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsPreserveSig">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodImplAttributes.PreserveSig"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsInternalCall">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodImplAttributes.InternalCall"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsSynchronized">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodImplAttributes.Synchronized"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsNoInlining">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodImplAttributes.NoInlining"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsAggressiveInlining">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodImplAttributes.AggressiveInlining"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsNoOptimization">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodImplAttributes.NoOptimization"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsAggressiveOptimization">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodImplAttributes.AggressiveOptimization"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.HasSecurityMitigations">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodImplAttributes.SecurityMitigations"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsSetter">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodSemanticsAttributes.Setter"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsGetter">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodSemanticsAttributes.Getter"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsOther">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodSemanticsAttributes.Other"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsAddOn">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodSemanticsAttributes.AddOn"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsRemoveOn">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodSemanticsAttributes.RemoveOn"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsFire">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MethodSemanticsAttributes.Fire"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsStaticConstructor">
            <summary>
            <c>true</c> if this is the static type constructor
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsInstanceConstructor">
            <summary>
            <c>true</c> if this is an instance constructor
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDef.IsConstructor">
            <summary>
            <c>true</c> if this is a static or an instance constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.dnlib#Utils#IListListener{dnlib#DotNet#GenericParam}#OnLazyAdd(System.Int32,dnlib.DotNet.GenericParam@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.dnlib#Utils#IListListener{dnlib#DotNet#GenericParam}#OnAdd(System.Int32,dnlib.DotNet.GenericParam)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.dnlib#Utils#IListListener{dnlib#DotNet#GenericParam}#OnRemove(System.Int32,dnlib.DotNet.GenericParam)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.dnlib#Utils#IListListener{dnlib#DotNet#GenericParam}#OnResize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.dnlib#Utils#IListListener{dnlib#DotNet#GenericParam}#OnClear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.dnlib#Utils#IListListener{dnlib#DotNet#ParamDef}#OnLazyAdd(System.Int32,dnlib.DotNet.ParamDef@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.dnlib#Utils#IListListener{dnlib#DotNet#ParamDef}#OnAdd(System.Int32,dnlib.DotNet.ParamDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.dnlib#Utils#IListListener{dnlib#DotNet#ParamDef}#OnRemove(System.Int32,dnlib.DotNet.ParamDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.dnlib#Utils#IListListener{dnlib#DotNet#ParamDef}#OnResize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.dnlib#Utils#IListListener{dnlib#DotNet#ParamDef}#OnClear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDef.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.MethodDefUser">
            <summary>
            A Method row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodDefUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodDefUser.#ctor(dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Method name</param>
        </member>
        <member name="M:dnlib.DotNet.MethodDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.MethodSig)">
            <summary>
            Constructor
            </summary>
            <param name="name">Method name</param>
            <param name="methodSig">Method sig</param>
        </member>
        <member name="M:dnlib.DotNet.MethodDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.MethodSig,dnlib.DotNet.MethodAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="name">Method name</param>
            <param name="methodSig">Method sig</param>
            <param name="flags">Flags</param>
        </member>
        <member name="M:dnlib.DotNet.MethodDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.MethodSig,dnlib.DotNet.MethodImplAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="name">Method name</param>
            <param name="methodSig">Method sig</param>
            <param name="implFlags">Impl flags</param>
        </member>
        <member name="M:dnlib.DotNet.MethodDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.MethodSig,dnlib.DotNet.MethodImplAttributes,dnlib.DotNet.MethodAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="name">Method name</param>
            <param name="methodSig">Method sig</param>
            <param name="implFlags">Impl flags</param>
            <param name="flags">Flags</param>
        </member>
        <member name="T:dnlib.DotNet.MethodDefMD">
            <summary>
            Created from a row in the Method table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodDefMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.MethodDefMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDefMD.InitializeParamDefs">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDefMD.InitializeGenericParameters">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDefMD.InitializeDeclSecurities">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDefMD.GetImplMap_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDefMD.GetMethodBody_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDefMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDefMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDefMD.InitializeOverrides">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDefMD.InitializeSemanticsAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDefMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>Method</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.MethodDefMD.OnLazyAdd2(System.Int32,dnlib.DotNet.GenericParam@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodDefMD.OnLazyAdd2(System.Int32,dnlib.DotNet.ParamDef@)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.MethodExportInfo">
            <summary>
            Contains the name and ordinal of a method that gets exported to unmanaged code.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodExportInfo.Ordinal">
            <summary>
            Gets the ordinal or null
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodExportInfo.Name">
            <summary>
            Gets the name. If it's null, and <see cref="P:dnlib.DotNet.MethodExportInfo.Ordinal"/> is also null, the name of the method
            (<see cref="P:dnlib.DotNet.MethodDef.Name"/>) is used as the exported name.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodExportInfo.Options">
            <summary>
            Gets the options
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodExportInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodExportInfo.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name or null to export by ordinal</param>
        </member>
        <member name="M:dnlib.DotNet.MethodExportInfo.#ctor(System.UInt16)">
            <summary>
            Constructor
            </summary>
            <param name="ordinal">Ordinal</param>
        </member>
        <member name="M:dnlib.DotNet.MethodExportInfo.#ctor(System.String,System.Nullable{System.UInt16})">
            <summary>
            Constructor
            </summary>
            <param name="name">Name or null to export by ordinal</param>
            <param name="ordinal">Ordinal or null to export by name</param>
        </member>
        <member name="M:dnlib.DotNet.MethodExportInfo.#ctor(System.String,System.Nullable{System.UInt16},dnlib.DotNet.MethodExportInfoOptions)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name or null to export by ordinal</param>
            <param name="ordinal">Ordinal or null to export by name</param>
            <param name="options">Options</param>
        </member>
        <member name="T:dnlib.DotNet.MethodExportInfoOptions">
            <summary>
            Exported method options
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodExportInfoOptions.None">
            <summary>
            No bit is set
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodExportInfoOptions.FromUnmanaged">
            <summary>
            Transition from unmanaged code
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodExportInfoOptions.FromUnmanagedRetainAppDomain">
            <summary>
            Also retain app domain
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodExportInfoOptions.CallMostDerived">
            <summary>
            Call most derived method
            </summary>
        </member>
        <member name="T:dnlib.DotNet.MethodImplAttributes">
            <summary>
            Method impl attributes, see CorHdr.h/CorMethodImpl
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.CodeTypeMask">
            <summary>Flags about code type.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.IL">
            <summary>Method impl is IL.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.Native">
            <summary>Method impl is native.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.OPTIL">
            <summary>Method impl is OPTIL</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.Runtime">
            <summary>Method impl is provided by the runtime.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.ManagedMask">
            <summary>Flags specifying whether the code is managed or unmanaged.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.Unmanaged">
            <summary>Method impl is unmanaged, otherwise managed.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.Managed">
            <summary>Method impl is managed.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.ForwardRef">
            <summary>Indicates method is defined; used primarily in merge scenarios.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.PreserveSig">
            <summary>Indicates method sig is not to be mangled to do HRESULT conversion.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.InternalCall">
            <summary>Reserved for internal use.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.Synchronized">
            <summary>Method is single threaded through the body.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.NoInlining">
            <summary>Method may not be inlined.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.AggressiveInlining">
            <summary>Method should be inlined if possible.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.NoOptimization">
            <summary>Method may not be optimized.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.AggressiveOptimization">
            <summary>Method may contain hot code and should be aggressively optimized.</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodImplAttributes.SecurityMitigations">
            <summary>The JIT compiler should look for security mitigation attributes, such as the user-defined System.Runtime.CompilerServices.SecurityMitigationsAttribute. If found, the JIT compiler applies any related security mitigations. Available starting with .NET Framework 4.8.</summary>
        </member>
        <member name="T:dnlib.DotNet.MethodOverride">
            <summary>
            Describes which method some method implements
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodOverride.MethodBody">
            <summary>
            The method body. Usually a <see cref="T:dnlib.DotNet.MethodDef"/> but could be a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodOverride.MethodDeclaration">
            <summary>
            The method <see cref="F:dnlib.DotNet.MethodOverride.MethodBody"/> implements
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodOverride.#ctor(dnlib.DotNet.IMethodDefOrRef,dnlib.DotNet.IMethodDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="methodBody">Method body</param>
            <param name="methodDeclaration">The method <paramref name="methodBody"/> implements</param>
        </member>
        <member name="T:dnlib.DotNet.MethodSemanticsAttributes">
            <summary>
            Method semantics flags, see CorHdr.h/CorMethodSemanticsAttr
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodSemanticsAttributes.None">
            <summary>No bit is set</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodSemanticsAttributes.Setter">
            <summary>Setter for property</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodSemanticsAttributes.Getter">
            <summary>Getter for property</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodSemanticsAttributes.Other">
            <summary>other method for property or event</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodSemanticsAttributes.AddOn">
            <summary>AddOn method for event</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodSemanticsAttributes.RemoveOn">
            <summary>RemoveOn method for event</summary>
        </member>
        <member name="F:dnlib.DotNet.MethodSemanticsAttributes.Fire">
            <summary>Fire method for event</summary>
        </member>
        <member name="T:dnlib.DotNet.MethodSpec">
            <summary>
            A high-level representation of a row in the MethodSpec table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodSpec.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.Method">
            <summary>
            From column MethodSpec.Method
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodSpec.method">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.Instantiation">
            <summary>
            From column MethodSpec.Instantiation
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodSpec.instantiation">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodSpec.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.MethodSpec.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.MethodSpec.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodSpec.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.MethodSpec.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.MethodSpec.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.dnlib#DotNet#IMethod#MethodSig">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.Name">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.DeclaringType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.GenericInstMethodSig">
            <summary>
            Gets/sets the generic instance method sig
            </summary>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.dnlib#DotNet#IGenericParameterProvider#NumberOfGenericParameters">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.MethodSpec.FullName">
            <summary>
            Gets the full name
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodSpec.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.MethodSpecUser">
            <summary>
            A MethodSpec row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodSpecUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodSpecUser.#ctor(dnlib.DotNet.IMethodDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="method">The generic method</param>
        </member>
        <member name="M:dnlib.DotNet.MethodSpecUser.#ctor(dnlib.DotNet.IMethodDefOrRef,dnlib.DotNet.GenericInstMethodSig)">
            <summary>
            Constructor
            </summary>
            <param name="method">The generic method</param>
            <param name="sig">The instantiated method sig</param>
        </member>
        <member name="T:dnlib.DotNet.MethodSpecMD">
            <summary>
            Created from a row in the MethodSpec table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodSpecMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.MethodSpecMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodSpecMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodSpecMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodSpecMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>MethodSpec</c> row</param>
            <param name="rid">Row ID</param>
            <param name="gpContext">Generic parameter context</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.ModuleContext">
            <summary>
            <see cref="T:dnlib.DotNet.ModuleDef"/> context
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleContext.AssemblyResolver">
            <summary>
            Gets/sets the assembly resolver. This is never <c>null</c>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleContext.Resolver">
            <summary>
            Gets/sets the resolver. This is never <c>null</c>.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleContext.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleContext.#ctor(dnlib.DotNet.IAssemblyResolver)">
            <summary>
            Constructor
            </summary>
            <param name="assemblyResolver">Assembly resolver or <c>null</c></param>
        </member>
        <member name="M:dnlib.DotNet.ModuleContext.#ctor(dnlib.DotNet.IResolver)">
            <summary>
            Constructor
            </summary>
            <param name="resolver">Type/method/field resolver or <c>null</c></param>
        </member>
        <member name="M:dnlib.DotNet.ModuleContext.#ctor(dnlib.DotNet.IAssemblyResolver,dnlib.DotNet.IResolver)">
            <summary>
            Constructor
            </summary>
            <param name="assemblyResolver">Assembly resolver or <c>null</c></param>
            <param name="resolver">Type/method/field resolver or <c>null</c></param>
        </member>
        <member name="T:dnlib.DotNet.ModuleCreationOptions">
            <summary>
            <see cref="T:dnlib.DotNet.ModuleDefMD"/> creation options
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleCreationOptions.Context">
            <summary>
            Module context
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleCreationOptions.PdbOptions">
            <summary>
            PDB reader options
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleCreationOptions.PdbFileOrData">
            <summary>
            Set it to A) the path (string) of the PDB file, B) the data (byte[]) of the PDB file or
            C) to an <see cref="T:dnlib.IO.DataReaderFactory"/> of the PDB data. The <see cref="T:dnlib.IO.DataReaderFactory"/> will
            be owned by the module. You don't need to initialize <see cref="P:dnlib.DotNet.ModuleCreationOptions.TryToLoadPdbFromDisk"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleCreationOptions.TryToLoadPdbFromDisk">
            <summary>
            If <c>true</c>, will load the PDB file from disk if present, or an embedded portable PDB file
            stored in the PE file. The default value is <c>true</c>.
            You don't need to initialize <see cref="P:dnlib.DotNet.ModuleCreationOptions.PdbFileOrData"/>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleCreationOptions.CorLibAssemblyRef">
            <summary>
            corlib assembly reference to use or <c>null</c> if the default one from the opened
            module should be used.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleCreationOptions.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleCreationOptions.#ctor(dnlib.DotNet.ModuleContext)">
            <summary>
            Constructor
            </summary>
            <param name="context">Module context</param>
        </member>
        <member name="T:dnlib.DotNet.ModuleDef">
            <summary>
            A high-level representation of a row in the Module table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.DefaultCharacteristics">
            <summary>Default characteristics</summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.DefaultDllCharacteristics">
            <summary>Default DLL characteristics</summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.corLibTypes">
            <summary>
            Initialize this in the ctor
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.pdbState">
            <summary>
            PDB state
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.lastUsedRids">
            <summary>
            Array of last used rid in each table. I.e., next free rid is value + 1
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.context">
            <summary>Module context</summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.ResolutionScopeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Tag">
            <summary>
            Gets/sets a user value. This is never used by dnlib. This property isn't thread safe.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.ScopeType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.ScopeName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Generation">
            <summary>
            Gets/sets Module.Generation column
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.generation">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Name">
            <summary>
            Gets/sets Module.Name column
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Mvid">
            <summary>
            Gets/sets Module.Mvid column
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.mvid">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.EncId">
            <summary>
            Gets/sets Module.EncId column
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.encId">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.EncBaseId">
            <summary>
            Gets/sets Module.EncBaseId column
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.encBaseId">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.ModuleDef.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.ModuleDef.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Assembly">
            <summary>
            Gets the module's assembly. To set this value, add this <see cref="T:dnlib.DotNet.ModuleDef"/>
            to <see cref="P:dnlib.DotNet.AssemblyDef.Modules"/>.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.assembly">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Types">
            <summary>
            Gets a list of all non-nested <see cref="T:dnlib.DotNet.TypeDef"/>s. See also <see cref="M:dnlib.DotNet.ModuleDef.GetTypes"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.types">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.InitializeTypes">
            <summary>Initializes <see cref="F:dnlib.DotNet.ModuleDef.types"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.ExportedTypes">
            <summary>
            Gets a list of all <see cref="T:dnlib.DotNet.ExportedType"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.exportedTypes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.InitializeExportedTypes">
            <summary>Initializes <see cref="F:dnlib.DotNet.ModuleDef.exportedTypes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.NativeEntryPoint">
            <summary>
            Gets/sets the native entry point. Only one of <see cref="P:dnlib.DotNet.ModuleDef.NativeEntryPoint"/> and
            <see cref="P:dnlib.DotNet.ModuleDef.ManagedEntryPoint"/> can be set. You write to one and the other one gets cleared.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.ManagedEntryPoint">
            <summary>
            Gets/sets the managed entry point. Only one of <see cref="P:dnlib.DotNet.ModuleDef.NativeEntryPoint"/> and
            <see cref="P:dnlib.DotNet.ModuleDef.ManagedEntryPoint"/> can be set. You write to one and the other one gets cleared.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.nativeEntryPoint">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.managedEntryPoint">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.nativeAndManagedEntryPoint_initialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetNativeEntryPoint_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.ModuleDef.nativeEntryPoint"/></summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetManagedEntryPoint_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.ModuleDef.managedEntryPoint"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.EntryPoint">
            <summary>
            Gets/sets the entry point method
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsNativeEntryPointValid">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.NativeEntryPoint"/> is non-zero
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsManagedEntryPointValid">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.ManagedEntryPoint"/> is non-null
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsEntryPointValid">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.EntryPoint"/> is non-null
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Resources">
            <summary>
            Gets a list of all <see cref="T:dnlib.DotNet.Resource"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.resources">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.InitializeResources">
            <summary>Initializes <see cref="F:dnlib.DotNet.ModuleDef.resources"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.VTableFixups">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.ModuleDef.VTableFixups"/>. This is <c>null</c> if there are no
            vtable fixups.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.vtableFixups">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.vtableFixups_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetVTableFixups_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.ModuleDef.vtableFixups"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.HasTypes">
            <summary>
            <c>true</c> if there's at least one <see cref="T:dnlib.DotNet.TypeDef"/> in <see cref="P:dnlib.DotNet.ModuleDef.Types"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.HasExportedTypes">
            <summary>
            <c>true</c> if there's at least one <see cref="T:dnlib.DotNet.ExportedType"/> in <see cref="P:dnlib.DotNet.ModuleDef.ExportedTypes"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.HasResources">
            <summary>
            <c>true</c> if there's at least one <see cref="T:dnlib.DotNet.Resource"/> in <see cref="P:dnlib.DotNet.ModuleDef.Resources"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.FullName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Location">
            <summary>
            Gets/sets the path of the module or an empty string if it wasn't loaded from disk
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.location">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.CorLibTypes">
            <summary>
            Gets the <see cref="T:dnlib.DotNet.ICorLibTypes"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.TypeDefFinder">
            <summary>
            Gets the <see cref="P:dnlib.DotNet.ModuleDef.TypeDefFinder"/> instance
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Context">
            <summary>
            Gets/sets the module context. This is never <c>null</c>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.EnableTypeDefFindCache">
            <summary>
            If <c>true</c>, the <see cref="T:dnlib.DotNet.TypeDef"/> cache is enabled. The cache is used by
            <see cref="M:dnlib.DotNet.ModuleDef.Find(System.String,System.Boolean)"/> and <see cref="M:dnlib.DotNet.ModuleDef.Find(dnlib.DotNet.TypeRef)"/> to find types.
            <br/><br/>
            <c>IMPORTANT:</c> Only enable the cache if this module's types keep their exact
            name, namespace, and declaring type and if <c>no</c> type is either added or
            removed from <see cref="P:dnlib.DotNet.ModuleDef.Types"/> or from any type that is reachable from the
            top-level types in <see cref="P:dnlib.DotNet.ModuleDef.Types"/> (i.e., any type owned by this module).
            This is disabled by default. When disabled, all calls to <see cref="M:dnlib.DotNet.ModuleDef.Find(System.String,System.Boolean)"/>
            and <see cref="M:dnlib.DotNet.ModuleDef.Find(dnlib.DotNet.TypeRef)"/> will result in a slow <c>O(n)</c> (linear) search.
            </summary>
            <seealso cref="M:dnlib.DotNet.ModuleDef.ResetTypeDefFindCache"/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsManifestModule">
            <summary>
            <c>true</c> if this is the manifest (main) module
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.GlobalType">
            <summary>
            Gets the global (aka. &lt;Module&gt;) type or <c>null</c> if there are no types
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsCoreLibraryModule">
            <summary>
            true if it's the core library module, false if it's not the core library module,
            and null if it's not known.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Win32Resources">
            <summary>
            Gets/sets the Win32 resources
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.win32Resources">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.win32Resources_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetWin32Resources_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.ModuleDef.win32Resources"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.PdbState">
            <summary>
            Gets the <see cref="T:dnlib.DotNet.Pdb.PdbState"/>. This is <c>null</c> if no PDB file
            has been loaded or if no PDB file could be found.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Kind">
            <summary>
            Module kind
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Characteristics">
            <summary>
            Gets/sets the characteristics (from PE file header)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.DllCharacteristics">
            <summary>
            Gets/sets the DLL characteristics (from PE optional header)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.RuntimeVersion">
            <summary>
            Gets/sets the runtime version which is stored in the metadata header.
            See <see cref="T:dnlib.DotNet.MD.MDHeaderRuntimeVersion"/>.
            </summary>
            <remarks>Not thread safe</remarks>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.WinMDStatus">
            <summary>
            Gets the WinMD status
            </summary>
            <remarks>Not thread safe</remarks>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsWinMD">
            <summary>
            <c>true</c> if this is a WinMD file
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsManagedWinMD">
            <summary>
            <c>true</c> if this is a managed WinMD file
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsPureWinMD">
            <summary>
            <c>true</c> if this is a pure (non-managed) WinMD file
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.RuntimeVersionWinMD">
            <summary>
            Gets the CLR runtime version of the managed WinMD file or <c>null</c> if none. This is
            similar to <see cref="P:dnlib.DotNet.ModuleDef.RuntimeVersion"/> for normal non-WinMD files.
            </summary>
            <remarks>Not thread safe</remarks>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.WinMDVersion">
            <summary>
            Gets the WinMD version or <c>null</c> if none
            </summary>
            <remarks>Not thread safe</remarks>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsClr10">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.RuntimeVersion"/> is the CLR v1.0 string (only the major
            and minor version numbers are checked)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsClr10Exactly">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.RuntimeVersion"/> is the CLR v1.0 string
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsClr11">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.RuntimeVersion"/> is the CLR v1.1 string (only the major
            and minor version numbers are checked)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsClr11Exactly">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.RuntimeVersion"/> is the CLR v1.1 string
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsClr1x">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.RuntimeVersion"/> is the CLR v1.0 or v1.1 string (only the
            major and minor version numbers are checked)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsClr1xExactly">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.RuntimeVersion"/> is the CLR v1.0 or v1.1 string
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsClr20">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.RuntimeVersion"/> is the CLR v2.0 string (only the major
            and minor version numbers are checked)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsClr20Exactly">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.RuntimeVersion"/> is the CLR v2.0 string
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsClr40">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.RuntimeVersion"/> is the CLR v4.0 string (only the major
            and minor version numbers are checked)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsClr40Exactly">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.RuntimeVersion"/> is the CLR v4.0 string
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsEcma2002">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.RuntimeVersion"/> is the ECMA 2002 string
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsEcma2005">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.RuntimeVersion"/> is the ECMA 2005 string
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Machine">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.ModuleDef.Machine"/> (from PE header)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsI386">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.Machine"/> is <see cref="F:dnlib.PE.Machine.I386"/>, <see cref="F:dnlib.PE.Machine.I386_Native_Apple"/>, ...
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsIA64">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.Machine"/> is <see cref="F:dnlib.PE.Machine.IA64"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsAMD64">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.Machine"/> is <see cref="F:dnlib.PE.Machine.AMD64"/>, <see cref="F:dnlib.PE.Machine.AMD64_Native_Apple"/>, ...
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsARM">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.Machine"/> is <see cref="F:dnlib.PE.Machine.ARMNT"/>, <see cref="F:dnlib.PE.Machine.ARMNT_Native_Apple"/>, ...
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsARM64">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ModuleDef.Machine"/> is <see cref="F:dnlib.PE.Machine.ARM64"/>, <see cref="F:dnlib.PE.Machine.ARM64_Native_Apple"/>, ...
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Cor20HeaderFlags">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.ModuleDef.Cor20HeaderFlags"/> (from .NET header)
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDef.cor20HeaderFlags">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Cor20HeaderRuntimeVersion">
            <summary>
            Gets/sets the runtime version number in the COR20 header. The major version is
            in the high 16 bits. The minor version is in the low 16 bits. This is normally 2.5
            (0x00020005), but if it's .NET 1.x, it should be 2.0 (0x00020000). If this is
            <c>null</c>, the default value will be used when saving the module (2.0 if CLR 1.x,
            and 2.5 if not CLR 1.x).
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.TablesHeaderVersion">
            <summary>
            Gets the tables header version. The major version is in the upper 8 bits and the
            minor version is in the lower 8 bits. .NET 1.0/1.1 use version 1.0 (0x0100) and
            .NET 2.x and later use version 2.0 (0x0200). 1.0 has no support for generics,
            1.1 has support for generics (GenericParam rows have an extra Kind column),
            and 2.0 has support for generics (GenericParam rows have the standard 4 columns).
            No other version is supported. If this is <c>null</c>, the default version is
            used (1.0 if .NET 1.x, else 2.0).
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.ModifyComImageFlags(System.Boolean,dnlib.DotNet.MD.ComImageFlags)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.ModuleDef.cor20HeaderFlags"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsILOnly">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MD.ComImageFlags.ILOnly"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Is32BitRequired">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MD.ComImageFlags.Bit32Required"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.IsStrongNameSigned">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MD.ComImageFlags.StrongNameSigned"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.HasNativeEntryPoint">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MD.ComImageFlags.NativeEntryPoint"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDef.Is32BitPreferred">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.MD.ComImageFlags.Bit32Preferred"/> bit
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Dispose(System.Boolean)">
            <summary>
            Dispose method
            </summary>
            <param name="disposing"><c>true</c> if called by <see cref="M:dnlib.DotNet.ModuleDef.Dispose"/></param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetTypes">
            <summary>
            Gets all the types (including nested types) present in this module
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.AddAsNonNestedType(dnlib.DotNet.TypeDef)">
            <summary>
            Adds <paramref name="typeDef"/> as a non-nested type. If it's already nested, its
            <see cref="P:dnlib.DotNet.TypeDef.DeclaringType"/> will be set to <c>null</c>.
            </summary>
            <param name="typeDef">The <see cref="T:dnlib.DotNet.TypeDef"/> to insert</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.UpdateRowId``1(``0)">
            <summary>
            Updates the <c>rid</c> to the next free <c>rid</c> available. It's only updated if
            the original <c>rid</c> is 0.
            </summary>
            <typeparam name="T">IMDTokenProvider</typeparam>
            <param name="tableRow">The row that should be updated</param>
            <returns>Returns the input</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.ForceUpdateRowId``1(``0)">
            <summary>
            Updates the <c>rid</c> to the next free <c>rid</c> available.
            </summary>
            <typeparam name="T">IMDTokenProvider</typeparam>
            <param name="tableRow">The row that should be updated</param>
            <returns>Returns the input</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(System.Type)">
            <summary>
            Imports a <see cref="T:System.Type"/> as a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.ImportAsTypeSig(System.Type)">
            <summary>
            Imports a <see cref="T:System.Type"/> as a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(System.Reflection.FieldInfo)">
            <summary>
            Imports a <see cref="T:System.Reflection.FieldInfo"/> as a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
            <param name="fieldInfo">The field</param>
            <returns>The imported field or <c>null</c> if <paramref name="fieldInfo"/> is invalid
            or if we failed to import the field</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(System.Reflection.MethodBase)">
            <summary>
            Imports a <see cref="T:System.Reflection.MethodBase"/> as a <see cref="T:dnlib.DotNet.IMethod"/>. This will be either
            a <see cref="T:dnlib.DotNet.MemberRef"/> or a <see cref="T:dnlib.DotNet.MethodSpec"/>.
            </summary>
            <param name="methodBase">The method</param>
            <returns>The imported method or <c>null</c> if <paramref name="methodBase"/> is invalid
            or if we failed to import the method</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(dnlib.DotNet.IType)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.IType"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(dnlib.DotNet.TypeDef)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.TypeDef"/> as a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(dnlib.DotNet.TypeRef)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(dnlib.DotNet.TypeSpec)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.TypeSpec"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(dnlib.DotNet.TypeSig)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="type">The type</param>
            <returns>The imported type or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(dnlib.DotNet.IField)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.IField"/>
            </summary>
            <param name="field">The field</param>
            <returns>The imported type or <c>null</c> if <paramref name="field"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(dnlib.DotNet.FieldDef)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.FieldDef"/> as a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
            <param name="field">The field</param>
            <returns>The imported type or <c>null</c> if <paramref name="field"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(dnlib.DotNet.IMethod)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.IMethod"/>
            </summary>
            <param name="method">The method</param>
            <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(dnlib.DotNet.MethodDef)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.MethodDef"/> as a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
            <param name="method">The method</param>
            <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(dnlib.DotNet.MethodSpec)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.MethodSpec"/>
            </summary>
            <param name="method">The method</param>
            <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Import(dnlib.DotNet.MemberRef)">
            <summary>
            Imports a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
            <param name="memberRef">The member ref</param>
            <returns>The imported member ref or <c>null</c> if <paramref name="memberRef"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Write(System.String)">
            <summary>
            Writes the module to a file on disk. If the file exists, it will be overwritten.
            </summary>
            <param name="filename">Filename</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Write(System.String,dnlib.DotNet.Writer.ModuleWriterOptions)">
            <summary>
            Writes the module to a file on disk. If the file exists, it will be overwritten.
            </summary>
            <param name="filename">Filename</param>
            <param name="options">Writer options</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Write(System.IO.Stream)">
            <summary>
            Writes the module to a stream.
            </summary>
            <param name="dest">Destination stream</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Write(System.IO.Stream,dnlib.DotNet.Writer.ModuleWriterOptions)">
            <summary>
            Writes the module to a stream.
            </summary>
            <param name="dest">Destination stream</param>
            <param name="options">Writer options</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.ResetTypeDefFindCache">
            <summary>
            Resets the <see cref="T:dnlib.DotNet.TypeDef"/> cache which can be enabled by setting
            <see cref="P:dnlib.DotNet.ModuleDef.EnableTypeDefFindCache"/> to <c>true</c>. Use this method if the cache is
            enabled but some of the types have been modified (eg. removed, added, renamed).
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.FindWin32ResourceData(dnlib.W32Resources.ResourceName,dnlib.W32Resources.ResourceName,dnlib.W32Resources.ResourceName)">
            <summary>
            Finds a <see cref="T:dnlib.W32Resources.ResourceData"/>
            </summary>
            <param name="type">Type</param>
            <param name="name">Name</param>
            <param name="langId">Language ID</param>
            <returns>The <see cref="T:dnlib.W32Resources.ResourceData"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.CreatePdbState(dnlib.DotNet.Pdb.PdbFileKind)">
            <summary>
            Creates a new <see cref="T:dnlib.DotNet.Pdb.PdbState"/>
            </summary>
            <param name="pdbFileKind">PDB file kind</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.SetPdbState(dnlib.DotNet.Pdb.PdbState)">
            <summary>
            Sets a <see cref="T:dnlib.DotNet.Pdb.PdbState"/>
            </summary>
            <param name="pdbState">New <see cref="T:dnlib.DotNet.Pdb.PdbState"/></param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetPointerSize">
            <summary>
            Returns the size of a pointer. Assumes it's 32-bit if pointer size is unknown or
            if it can be 32-bit or 64-bit.
            </summary>
            <returns>Size of a pointer (4 or 8)</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetPointerSize(System.Int32)">
            <summary>
            Returns the size of a pointer
            </summary>
            <param name="defaultPointerSize">Default pointer size if it's not known or if it
            can be 32-bit or 64-bit</param>
            <returns>Size of a pointer (4 or 8)</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetPointerSize(System.Int32,System.Int32)">
            <summary>
            Returns the size of a pointer
            </summary>
            <param name="defaultPointerSize">Default pointer size</param>
            <param name="prefer32bitPointerSize">Pointer size if it's prefer-32-bit (should usually be 4)</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.dnlib#Utils#IListListener{dnlib#DotNet#TypeDef}#OnLazyAdd(System.Int32,dnlib.DotNet.TypeDef@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.dnlib#Utils#IListListener{dnlib#DotNet#TypeDef}#OnAdd(System.Int32,dnlib.DotNet.TypeDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.dnlib#Utils#IListListener{dnlib#DotNet#TypeDef}#OnRemove(System.Int32,dnlib.DotNet.TypeDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.dnlib#Utils#IListListener{dnlib#DotNet#TypeDef}#OnResize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.dnlib#Utils#IListListener{dnlib#DotNet#TypeDef}#OnClear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Find(System.String,System.Boolean)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeDef"/>. For speed, enable <see cref="P:dnlib.DotNet.ModuleDef.EnableTypeDefFindCache"/>
            if possible (read the documentation first).
            </summary>
            <param name="fullName">Full name of the type (no assembly information)</param>
            <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
            type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
            are separated by a <c>/</c> character.</param>
            <returns>An existing <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if it wasn't found.</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Find(dnlib.DotNet.TypeRef)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeDef"/>. Its scope (i.e., module or assembly) is ignored when
            looking up the type. For speed, enable <see cref="P:dnlib.DotNet.ModuleDef.EnableTypeDefFindCache"/> if possible
            (read the documentation first).
            </summary>
            <param name="typeRef">The type ref</param>
            <returns>An existing <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if it wasn't found.</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.Find(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="typeRef">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.CreateModuleContext">
            <summary>
            Creates a new <see cref="T:dnlib.DotNet.ModuleContext"/> instance. There should normally only be one
            instance shared by all <see cref="T:dnlib.DotNet.ModuleDef"/>s.
            </summary>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleContext"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.LoadEverything(dnlib.Threading.ICancellationToken)">
            <summary>
            Load everything in this module. All types, fields, asm refs, etc are loaded, all their
            properties are read to make sure everything is cached.
            </summary>
            <param name="cancellationToken">Cancellation token or <c>null</c></param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.ToString">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.ResolveToken(dnlib.DotNet.MDToken)">
            <summary>
            Resolves a token
            </summary>
            <param name="mdToken">The metadata token</param>
            <returns>A <see cref="T:dnlib.DotNet.IMDTokenProvider"/> or <c>null</c> if <paramref name="mdToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.ResolveToken(dnlib.DotNet.MDToken,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a token
            </summary>
            <param name="mdToken">The metadata token</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.IMDTokenProvider"/> or <c>null</c> if <paramref name="mdToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.ResolveToken(System.Int32)">
            <summary>
            Resolves a token
            </summary>
            <param name="token">The metadata token</param>
            <returns>A <see cref="T:dnlib.DotNet.IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.ResolveToken(System.Int32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a token
            </summary>
            <param name="token">The metadata token</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.ResolveToken(System.UInt32)">
            <summary>
            Resolves a token
            </summary>
            <param name="token">The metadata token</param>
            <returns>A <see cref="T:dnlib.DotNet.IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.ResolveToken(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a token
            </summary>
            <param name="token">The metadata token</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetAssemblyRefs">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.AssemblyRef"/>s
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetModuleRefs">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.ModuleRef"/>s
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetMemberRefs">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.MemberRef"/>s. <see cref="T:dnlib.DotNet.MemberRef"/>s with generic parameters
            aren't cached and a new copy is always returned.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetMemberRefs(dnlib.DotNet.GenericParamContext)">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.MemberRef"/>s. <see cref="T:dnlib.DotNet.MemberRef"/>s with generic parameters
            aren't cached and a new copy is always returned.
            </summary>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetTypeRefs">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.TypeRef"/>s
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.GetAssemblyRef(dnlib.DotNet.UTF8String)">
            <summary>
            Finds an assembly reference by name. If there's more than one, pick the one with
            the greatest version number.
            </summary>
            <param name="simpleName">Simple name of assembly (eg. "mscorlib")</param>
            <returns>The found <see cref="T:dnlib.DotNet.AssemblyRef"/> or <c>null</c> if there's no such
            assembly reference.</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDef.IsGreaterAssemblyRefVersion(dnlib.DotNet.AssemblyRef,dnlib.DotNet.AssemblyRef)">
            <summary>
            Compare asm refs' version
            </summary>
            <param name="found">First asm ref</param>
            <param name="newOne">New asm ref</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.ModuleDefUser">
            <summary>
            A Module row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefUser.#ctor(dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <remarks><see cref="P:dnlib.DotNet.ModuleDef.Mvid"/> is initialized to a random <see cref="T:System.Guid"/></remarks>
            <param name="name">Module nam</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefUser.#ctor(dnlib.DotNet.UTF8String,System.Nullable{System.Guid})">
            <summary>
            Constructor
            </summary>
            <param name="name">Module name</param>
            <param name="mvid">Module version ID</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefUser.#ctor(dnlib.DotNet.UTF8String,System.Nullable{System.Guid},dnlib.DotNet.AssemblyRef)">
            <summary>
            Constructor
            </summary>
            <param name="name">Module name</param>
            <param name="mvid">Module version ID</param>
            <param name="corLibAssemblyRef">Corlib assembly ref or <c>null</c></param>
        </member>
        <member name="T:dnlib.DotNet.ModuleDefMD2">
            <summary>
            Created from a row in the Module table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDefMD2.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDefMD2.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD2.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD2.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD2.GetNativeEntryPoint_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD2.GetManagedEntryPoint_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD2.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>Module</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD2.InitializeFromRawRow">
            <summary>
            Initialize fields from the raw <c>Module</c> row
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ModuleDefMD">
            <summary>
            Created from a row in the Module table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleDefMD.metadata">
            <summary>The file that contains all .NET metadata</summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDefMD.MethodDecrypter">
            <summary>
            Gets/sets the method decrypter
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDefMD.StringDecrypter">
            <summary>
            Gets/sets the string decrypter
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDefMD.Metadata">
            <summary>
            Returns the .NET metadata interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDefMD.TablesStream">
            <summary>
            Returns the #~ or #- tables stream
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDefMD.StringsStream">
            <summary>
            Returns the #Strings stream
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDefMD.BlobStream">
            <summary>
            Returns the #Blob stream
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDefMD.GuidStream">
            <summary>
            Returns the #GUID stream
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleDefMD.USStream">
            <summary>
            Returns the #US stream
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.InitializeTypes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.InitializeExportedTypes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.InitializeResources">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetWin32Resources_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetVTableFixups_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.String,dnlib.DotNet.ModuleContext)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a file
            </summary>
            <param name="fileName">File name of an existing .NET module/assembly</param>
            <param name="context">Module context or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.String,dnlib.DotNet.ModuleCreationOptions)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a file
            </summary>
            <param name="fileName">File name of an existing .NET module/assembly</param>
            <param name="options">Module creation options or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.Byte[],dnlib.DotNet.ModuleContext)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a byte[]
            </summary>
            <param name="data">Contents of a .NET module/assembly</param>
            <param name="context">Module context or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.Byte[],dnlib.DotNet.ModuleCreationOptions)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a byte[]
            </summary>
            <param name="data">Contents of a .NET module/assembly</param>
            <param name="options">Module creation options or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.Reflection.Module)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a reflection module
            </summary>
            <param name="mod">An existing reflection module</param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.Reflection.Module,dnlib.DotNet.ModuleContext)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a reflection module
            </summary>
            <param name="mod">An existing reflection module</param>
            <param name="context">Module context or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.Reflection.Module,dnlib.DotNet.ModuleCreationOptions)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a reflection module
            </summary>
            <param name="mod">An existing reflection module</param>
            <param name="options">Module creation options or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.Reflection.Module,dnlib.DotNet.ModuleContext,dnlib.PE.ImageLayout)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a reflection module
            </summary>
            <param name="mod">An existing reflection module</param>
            <param name="context">Module context or <c>null</c></param>
            <param name="imageLayout">Image layout of the module in memory</param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.Reflection.Module,dnlib.DotNet.ModuleCreationOptions,dnlib.PE.ImageLayout)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a reflection module
            </summary>
            <param name="mod">An existing reflection module</param>
            <param name="options">Module creation options or <c>null</c></param>
            <param name="imageLayout">Image layout of the module in memory</param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.IntPtr)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a memory location
            </summary>
            <param name="addr">Address of a .NET module/assembly</param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.IntPtr,dnlib.DotNet.ModuleContext)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a memory location
            </summary>
            <param name="addr">Address of a .NET module/assembly</param>
            <param name="context">Module context or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.IntPtr,dnlib.DotNet.ModuleCreationOptions)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a memory location
            </summary>
            <param name="addr">Address of a .NET module/assembly</param>
            <param name="options">Module creation options or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(dnlib.PE.IPEImage)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance
            </summary>
            <param name="peImage">PE image</param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(dnlib.PE.IPEImage,dnlib.DotNet.ModuleContext)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance
            </summary>
            <param name="peImage">PE image</param>
            <param name="context">Module context or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(dnlib.PE.IPEImage,dnlib.DotNet.ModuleCreationOptions)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance
            </summary>
            <param name="peImage">PE image</param>
            <param name="options">Module creation options or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.IntPtr,dnlib.DotNet.ModuleContext,dnlib.PE.ImageLayout)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a memory location
            </summary>
            <param name="addr">Address of a .NET module/assembly</param>
            <param name="context">Module context or <c>null</c></param>
            <param name="imageLayout">Image layout of the file in memory</param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.IntPtr,dnlib.DotNet.ModuleCreationOptions,dnlib.PE.ImageLayout)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a memory location
            </summary>
            <param name="addr">Address of a .NET module/assembly</param>
            <param name="options">Module creation options or <c>null</c></param>
            <param name="imageLayout">Image layout of the file in memory</param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.IO.Stream)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a stream
            </summary>
            <remarks>This will read all bytes from the stream and call <see cref="M:dnlib.DotNet.ModuleDefMD.Load(System.Byte[],dnlib.DotNet.ModuleCreationOptions)"/>.
            It's better to use one of the other Load() methods.</remarks>
            <param name="stream">The stream (owned by caller)</param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.IO.Stream,dnlib.DotNet.ModuleContext)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a stream
            </summary>
            <remarks>This will read all bytes from the stream and call <see cref="M:dnlib.DotNet.ModuleDefMD.Load(System.Byte[],dnlib.DotNet.ModuleContext)"/>.
            It's better to use one of the other Load() methods.</remarks>
            <param name="stream">The stream (owned by caller)</param>
            <param name="context">Module context or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(System.IO.Stream,dnlib.DotNet.ModuleCreationOptions)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a stream
            </summary>
            <remarks>This will read all bytes from the stream and call <see cref="M:dnlib.DotNet.ModuleDefMD.Load(System.Byte[],dnlib.DotNet.ModuleContext)"/>.
            It's better to use one of the other Load() methods.</remarks>
            <param name="stream">The stream (owned by caller)</param>
            <param name="options">Module creation options or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Load(dnlib.DotNet.MD.MetadataBase,dnlib.DotNet.ModuleCreationOptions)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance from a <see cref="P:dnlib.DotNet.ModuleDefMD.Metadata"/>
            </summary>
            <param name="metadata">The metadata</param>
            <param name="options">Module creation options or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance that now owns <paramref name="metadata"/></returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.#ctor(dnlib.DotNet.MD.MetadataBase,dnlib.DotNet.ModuleCreationOptions)">
            <summary>
            Constructor
            </summary>
            <param name="metadata">The metadata</param>
            <param name="options">Module creation options or <c>null</c></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="metadata"/> is <c>null</c></exception>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.LoadPdb(dnlib.DotNet.Pdb.Symbols.SymbolReader)">
            <summary>
            Loads symbols using <paramref name="symbolReader"/>
            </summary>
            <param name="symbolReader">PDB symbol reader</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.LoadPdb(System.String)">
            <summary>
            Loads symbols from a PDB file
            </summary>
            <param name="pdbFileName">PDB file name</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.LoadPdb(dnlib.DotNet.Pdb.PdbReaderOptions,System.String)">
            <summary>
            Loads symbols from a PDB file
            </summary>
            <param name="options">PDB reader options</param>
            <param name="pdbFileName">PDB file name</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.LoadPdb(System.Byte[])">
            <summary>
            Loads symbols from a byte array
            </summary>
            <param name="pdbData">PDB data</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.LoadPdb(dnlib.DotNet.Pdb.PdbReaderOptions,System.Byte[])">
            <summary>
            Loads symbols from a byte array
            </summary>
            <param name="options">PDB reader options</param>
            <param name="pdbData">PDB data</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.LoadPdb(dnlib.IO.DataReaderFactory)">
            <summary>
            Loads symbols from a stream
            </summary>
            <param name="pdbStream">PDB file stream which is now owned by us</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.LoadPdb(dnlib.DotNet.Pdb.PdbReaderOptions,dnlib.IO.DataReaderFactory)">
            <summary>
            Loads symbols from a stream
            </summary>
            <param name="options">PDB reader options</param>
            <param name="pdbStream">PDB file stream which is now owned by us</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.LoadPdb">
            <summary>
            Loads symbols if a PDB file is available
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.LoadPdb(dnlib.DotNet.Pdb.PdbReaderOptions)">
            <summary>
            Loads symbols if a PDB file is available
            </summary>
            <param name="options">PDB reader options</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.FindCorLibAssemblyRef">
            <summary>
            Finds a mscorlib <see cref="T:dnlib.DotNet.AssemblyRef"/>
            </summary>
            <returns>An existing <see cref="T:dnlib.DotNet.AssemblyRef"/> instance or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.CreateDefaultCorLibAssemblyRef">
            <summary>
            Called when no corlib assembly reference was found
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveToken(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a token
            </summary>
            <param name="token">The metadata token</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveModule(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.ModuleDef"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.ModuleDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveTypeRef(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveTypeDef(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.TypeDef"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveField(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.FieldDef"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.FieldDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveMethod(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.MethodDef"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.MethodDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveParam(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.ParamDef"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.ParamDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveInterfaceImpl(System.UInt32)">
            <summary>
            Resolves an <see cref="T:dnlib.DotNet.InterfaceImpl"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.InterfaceImpl"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveInterfaceImpl(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves an <see cref="T:dnlib.DotNet.InterfaceImpl"/>
            </summary>
            <param name="rid">The row ID</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.InterfaceImpl"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveMemberRef(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.MemberRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveMemberRef(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
            <param name="rid">The row ID</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.MemberRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveConstant(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.Constant"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.Constant"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveDeclSecurity(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.DeclSecurity"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.DeclSecurity"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveClassLayout(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.ClassLayout"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.ClassLayout"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveStandAloneSig(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.StandAloneSig"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.StandAloneSig"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveStandAloneSig(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.StandAloneSig"/>
            </summary>
            <param name="rid">The row ID</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.StandAloneSig"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveEvent(System.UInt32)">
            <summary>
            Resolves an <see cref="T:dnlib.DotNet.EventDef"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.EventDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveProperty(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.PropertyDef"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.PropertyDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveModuleRef(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.ModuleRef"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.ModuleRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveTypeSpec(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.TypeSpec"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeSpec"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveTypeSpec(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.TypeSpec"/>
            </summary>
            <param name="rid">The row ID</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeSpec"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveImplMap(System.UInt32)">
            <summary>
            Resolves an <see cref="T:dnlib.DotNet.ImplMap"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.ImplMap"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveAssembly(System.UInt32)">
            <summary>
            Resolves an <see cref="T:dnlib.DotNet.AssemblyDef"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.AssemblyDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveAssemblyRef(System.UInt32)">
            <summary>
            Resolves an <see cref="T:dnlib.DotNet.AssemblyRef"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.AssemblyRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveFile(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.FileDef"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.FileDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveExportedType(System.UInt32)">
            <summary>
            Resolves an <see cref="T:dnlib.DotNet.ExportedType"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.ExportedType"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveManifestResource(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.ManifestResource"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.ManifestResource"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveGenericParam(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.GenericParam"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.GenericParam"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveMethodSpec(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.MethodSpec"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.MethodSpec"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveMethodSpec(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.MethodSpec"/>
            </summary>
            <param name="rid">The row ID</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.MethodSpec"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveGenericParamConstraint(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.GenericParamConstraint"/>
            </summary>
            <param name="rid">The row ID</param>
            <returns>A <see cref="T:dnlib.DotNet.GenericParamConstraint"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveGenericParamConstraint(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.GenericParamConstraint"/>
            </summary>
            <param name="rid">The row ID</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.GenericParamConstraint"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveTypeDefOrRef(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="codedToken">A <c>TypeDefOrRef</c> coded token</param>
            <returns>A <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveTypeDefOrRef(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="codedToken">A <c>TypeDefOrRef</c> coded token</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveHasConstant(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.IHasConstant"/>
            </summary>
            <param name="codedToken">A <c>HasConstant</c> coded token</param>
            <returns>A <see cref="T:dnlib.DotNet.IHasConstant"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveHasCustomAttribute(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.IHasCustomAttribute"/>
            </summary>
            <param name="codedToken">A <c>HasCustomAttribute</c> coded token</param>
            <returns>A <see cref="T:dnlib.DotNet.IHasCustomAttribute"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveHasCustomAttribute(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.IHasCustomAttribute"/>
            </summary>
            <param name="codedToken">A <c>HasCustomAttribute</c> coded token</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.IHasCustomAttribute"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveHasFieldMarshal(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.IHasFieldMarshal"/>
            </summary>
            <param name="codedToken">A <c>HasFieldMarshal</c> coded token</param>
            <returns>A <see cref="T:dnlib.DotNet.IHasFieldMarshal"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveHasDeclSecurity(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.IHasDeclSecurity"/>
            </summary>
            <param name="codedToken">A <c>HasDeclSecurity</c> coded token</param>
            <returns>A <see cref="T:dnlib.DotNet.IHasDeclSecurity"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveMemberRefParent(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.IMemberRefParent"/>
            </summary>
            <param name="codedToken">A <c>MemberRefParent</c> coded token</param>
            <returns>A <see cref="T:dnlib.DotNet.IMemberRefParent"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveMemberRefParent(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.IMemberRefParent"/>
            </summary>
            <param name="codedToken">A <c>MemberRefParent</c> coded token</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.IMemberRefParent"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveHasSemantic(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.IHasSemantic"/>
            </summary>
            <param name="codedToken">A <c>HasSemantic</c> coded token</param>
            <returns>A <see cref="T:dnlib.DotNet.IHasSemantic"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveMethodDefOrRef(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.IMethodDefOrRef"/>
            </summary>
            <param name="codedToken">A <c>MethodDefOrRef</c> coded token</param>
            <returns>A <see cref="T:dnlib.DotNet.IMethodDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveMethodDefOrRef(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.IMethodDefOrRef"/>
            </summary>
            <param name="codedToken">A <c>MethodDefOrRef</c> coded token</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.IMethodDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveMemberForwarded(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.IMemberForwarded"/>
            </summary>
            <param name="codedToken">A <c>MemberForwarded</c> coded token</param>
            <returns>A <see cref="T:dnlib.DotNet.IMemberForwarded"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveImplementation(System.UInt32)">
            <summary>
            Resolves an <see cref="T:dnlib.DotNet.IImplementation"/>
            </summary>
            <param name="codedToken">An <c>Implementation</c> coded token</param>
            <returns>A <see cref="T:dnlib.DotNet.IImplementation"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveCustomAttributeType(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.ICustomAttributeType"/>
            </summary>
            <param name="codedToken">A <c>CustomAttributeType</c> coded token</param>
            <returns>A <see cref="T:dnlib.DotNet.ICustomAttributeType"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveCustomAttributeType(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.ICustomAttributeType"/>
            </summary>
            <param name="codedToken">A <c>CustomAttributeType</c> coded token</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.ICustomAttributeType"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveResolutionScope(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.IResolutionScope"/>
            </summary>
            <param name="codedToken">A <c>ResolutionScope</c> coded token</param>
            <returns>A <see cref="T:dnlib.DotNet.IResolutionScope"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ResolveTypeOrMethodDef(System.UInt32)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.ITypeOrMethodDef"/>
            </summary>
            <param name="codedToken">A <c>TypeOrMethodDef</c>> coded token</param>
            <returns>A <see cref="T:dnlib.DotNet.ITypeOrMethodDef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadSignature(System.UInt32)">
            <summary>
            Reads a signature from the #Blob stream
            </summary>
            <param name="sig">#Blob stream offset of signature</param>
            <returns>A new <see cref="T:dnlib.DotNet.CallingConventionSig"/> instance or <c>null</c> if
            <paramref name="sig"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadSignature(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a signature from the #Blob stream
            </summary>
            <param name="sig">#Blob stream offset of signature</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.CallingConventionSig"/> instance or <c>null</c> if
            <paramref name="sig"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadTypeSignature(System.UInt32)">
            <summary>
            Reads a type signature from the #Blob stream
            </summary>
            <param name="sig">#Blob stream offset of signature</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="sig"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadTypeSignature(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a type signature from the #Blob stream
            </summary>
            <param name="sig">#Blob stream offset of signature</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="sig"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadTypeSignature(System.UInt32,System.Byte[]@)">
            <summary>
            Reads a type signature from the #Blob stream
            </summary>
            <param name="sig">#Blob stream offset of signature</param>
            <param name="extraData">If there's any extra data after the signature, it's saved
            here, else this will be <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="sig"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadTypeSignature(System.UInt32,dnlib.DotNet.GenericParamContext,System.Byte[]@)">
            <summary>
            Reads a type signature from the #Blob stream
            </summary>
            <param name="sig">#Blob stream offset of signature</param>
            <param name="extraData">If there's any extra data after the signature, it's saved
            here, else this will be <c>null</c></param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="sig"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadMarshalType(dnlib.DotNet.MD.Table,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.MarshalType"/> from the blob
            </summary>
            <param name="table">Table of owner</param>
            <param name="rid">Row ID of owner</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.MarshalType"/> instance or <c>null</c> if there's no field
            marshal for this owner.</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadCilBody(System.Collections.Generic.IList{dnlib.DotNet.Parameter},dnlib.PE.RVA)">
            <summary>
            Reads a CIL method body
            </summary>
            <param name="parameters">Method parameters</param>
            <param name="rva">RVA</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.CilBody"/> instance. It's empty if RVA is invalid (eg. 0 or
            it doesn't point to a CIL method body)</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadCilBody(System.Collections.Generic.IList{dnlib.DotNet.Parameter},dnlib.PE.RVA,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a CIL method body
            </summary>
            <param name="parameters">Method parameters</param>
            <param name="rva">RVA</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.Emit.CilBody"/> instance. It's empty if RVA is invalid (eg. 0 or
            it doesn't point to a CIL method body)</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetOwnerType(dnlib.DotNet.FieldDefMD)">
            <summary>
            Returns the owner type of a field
            </summary>
            <param name="field">The field</param>
            <returns>The owner type or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetOwnerType(dnlib.DotNet.MethodDefMD)">
            <summary>
            Returns the owner type of a method
            </summary>
            <param name="method">The method</param>
            <returns>The owner type or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetOwnerType(dnlib.DotNet.EventDefMD)">
            <summary>
            Returns the owner type of an event
            </summary>
            <param name="evt">The event</param>
            <returns>The owner type or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetOwnerType(dnlib.DotNet.PropertyDefMD)">
            <summary>
            Returns the owner type of a property
            </summary>
            <param name="property">The property</param>
            <returns>The owner type or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetOwner(dnlib.DotNet.GenericParamMD)">
            <summary>
            Returns the owner type/method of a generic param
            </summary>
            <param name="gp">The generic param</param>
            <returns>The owner type/method or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetOwner(dnlib.DotNet.GenericParamConstraintMD)">
            <summary>
            Returns the owner generic param of a generic param constraint
            </summary>
            <param name="gpc">The generic param constraint</param>
            <returns>The owner generic param or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetOwner(dnlib.DotNet.ParamDefMD)">
            <summary>
            Returns the owner method of a param
            </summary>
            <param name="pd">The param</param>
            <returns>The owner method or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadModule(System.UInt32,dnlib.DotNet.AssemblyDef)">
            <summary>
            Reads a module
            </summary>
            <param name="fileRid">File rid</param>
            <param name="owner">The assembly owning the module we should read</param>
            <returns>A new <see cref="T:dnlib.DotNet.ModuleDefMD"/> instance or <c>null</c> if <paramref name="fileRid"/>
            is invalid or if it's not a .NET module.</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetModuleRidList">
            <summary>
            Gets a list of all <c>File</c> rids that are .NET modules. Call <see cref="M:dnlib.DotNet.ModuleDefMD.ReadModule(System.UInt32,dnlib.DotNet.AssemblyDef)"/>
            to read one of these modules.
            </summary>
            <returns>A new <see cref="T:dnlib.DotNet.MD.RidList"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetValidFilename(System.String,System.String)">
            <summary>
            Concatenates the inputs and returns the result if it's a valid path
            </summary>
            <param name="baseDir">Base dir</param>
            <param name="name">File name</param>
            <returns>Full path to the file or <c>null</c> if one of the inputs is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetBaseDirectoryOfImage">
            <summary>
            Gets the base directory where this .NET module is located on disk
            </summary>
            <returns>Base directory or <c>null</c> if unknown or if an error occurred</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.CreateResource(System.UInt32)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.Resource"/> instance
            </summary>
            <param name="rid"><c>ManifestResource</c> rid</param>
            <returns>A new <see cref="T:dnlib.DotNet.Resource"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadCustomAttribute(System.UInt32)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.CustomAttribute"/>
            </summary>
            <param name="caRid">Custom attribute rid</param>
            <returns>A new <see cref="T:dnlib.DotNet.CustomAttribute"/> instance or <c>null</c> if
            <paramref name="caRid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadCustomAttribute(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.CustomAttribute"/>
            </summary>
            <param name="caRid">Custom attribute rid</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.CustomAttribute"/> instance or <c>null</c> if
            <paramref name="caRid"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadDataAt(dnlib.PE.RVA,System.Int32)">
            <summary>
            Reads data somewhere in the address space of the image
            </summary>
            <param name="rva">RVA of data</param>
            <param name="size">Size of data</param>
            <returns>All the data or <c>null</c> if <paramref name="rva"/> or <paramref name="size"/>
            is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetNativeEntryPoint">
            <summary>
            Gets the native entry point or 0 if none
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.GetManagedEntryPoint">
            <summary>
            Gets the managed entry point (a Method or a File) or null if none
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadField(System.UInt32)">
            <summary>
            Reads a new <see cref="T:dnlib.DotNet.FieldDefMD"/> instance. This one is not cached.
            </summary>
            <param name="rid">Row ID</param>
            <returns>A new <see cref="T:dnlib.DotNet.FieldDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadMethod(System.UInt32)">
            <summary>
            Reads a new <see cref="T:dnlib.DotNet.MethodDefMD"/> instance. This one is not cached.
            </summary>
            <param name="rid">Row ID</param>
            <returns>A new <see cref="T:dnlib.DotNet.MethodDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadEvent(System.UInt32)">
            <summary>
            Reads a new <see cref="T:dnlib.DotNet.EventDefMD"/> instance. This one is not cached.
            </summary>
            <param name="rid">Row ID</param>
            <returns>A new <see cref="T:dnlib.DotNet.EventDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadProperty(System.UInt32)">
            <summary>
            Reads a new <see cref="T:dnlib.DotNet.PropertyDefMD"/> instance. This one is not cached.
            </summary>
            <param name="rid">Row ID</param>
            <returns>A new <see cref="T:dnlib.DotNet.PropertyDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadParam(System.UInt32)">
            <summary>
            Reads a new <see cref="T:dnlib.DotNet.ParamDefMD"/> instance. This one is not cached.
            </summary>
            <param name="rid">Row ID</param>
            <returns>A new <see cref="T:dnlib.DotNet.ParamDefMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadGenericParam(System.UInt32)">
            <summary>
            Reads a new <see cref="T:dnlib.DotNet.GenericParamMD"/> instance. This one is not cached.
            </summary>
            <param name="rid">Row ID</param>
            <returns>A new <see cref="T:dnlib.DotNet.GenericParamMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadGenericParamConstraint(System.UInt32)">
            <summary>
            Reads a new <see cref="T:dnlib.DotNet.GenericParamConstraintMD"/> instance. This one is not cached.
            </summary>
            <param name="rid">Row ID</param>
            <returns>A new <see cref="T:dnlib.DotNet.GenericParamConstraintMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadGenericParamConstraint(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a new <see cref="T:dnlib.DotNet.GenericParamConstraintMD"/> instance. This one is not cached.
            </summary>
            <param name="rid">Row ID</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.GenericParamConstraintMD"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadMethodBody(dnlib.DotNet.MethodDefMD,dnlib.PE.RVA,dnlib.DotNet.MethodImplAttributes,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a method body
            </summary>
            <param name="method">Method</param>
            <param name="rva">Method RVA</param>
            <param name="implAttrs">Method impl attrs</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.Emit.MethodBody"/> or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.InitializeBodyFromPdb(dnlib.DotNet.MethodDefMD,dnlib.DotNet.Emit.CilBody)">
            <summary>
            Updates <paramref name="body"/> with the PDB info (if any)
            </summary>
            <param name="method">Owner method</param>
            <param name="body">Method body</param>
            <returns>Returns originak <paramref name="body"/> value</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadUserString(System.UInt32)">
            <summary>
            Reads a string from the #US heap
            </summary>
            <param name="token">String token</param>
            <returns>A non-null string</returns>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.NativeWrite(System.String)">
            <summary>
            Writes the mixed-mode module to a file on disk. If the file exists, it will be overwritten.
            </summary>
            <param name="filename">Filename</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.NativeWrite(System.String,dnlib.DotNet.Writer.NativeModuleWriterOptions)">
            <summary>
            Writes the mixed-mode module to a file on disk. If the file exists, it will be overwritten.
            </summary>
            <param name="filename">Filename</param>
            <param name="options">Writer options</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.NativeWrite(System.IO.Stream)">
            <summary>
            Writes the mixed-mode module to a stream.
            </summary>
            <param name="dest">Destination stream</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.NativeWrite(System.IO.Stream,dnlib.DotNet.Writer.NativeModuleWriterOptions)">
            <summary>
            Writes the mixed-mode module to a stream.
            </summary>
            <param name="dest">Destination stream</param>
            <param name="options">Writer options</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleDefMD.ReadBlob(System.UInt32)">
            <summary>
            Reads data from the #Blob. The following columns are returned:
            Field.Signature
            Method.Signature
            MemberRef.Signature
            Constant.Value
            CustomAttribute.Value
            FieldMarshal.NativeType
            DeclSecurity.PermissionSet
            StandAloneSig.Signature
            Property.Type
            TypeSpec.Signature
            Assembly.PublicKey
            AssemblyRef.PublicKeyOrToken
            File.HashValue
            MethodSpec.Instantiation
            </summary>
            <param name="token">A token</param>
            <returns>The value in the #Blob or <c>null</c> if <paramref name="token"/> is invalid</returns>
        </member>
        <member name="T:dnlib.DotNet.ModuleKind">
            <summary>
            Module kind
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleKind.Console">
            <summary>
            Console UI module
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleKind.Windows">
            <summary>
            Windows GUI module
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleKind.Dll">
            <summary>
            DLL module
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleKind.NetModule">
            <summary>
            Netmodule (it has no assembly manifest)
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ModuleRef">
            <summary>
            A high-level representation of a row in the ModuleRef table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleRef.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleRef.module">
            <summary>
            The owner module
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.MemberRefParentTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.ResolutionScopeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.ScopeType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.ScopeName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.Name">
            <summary>
            From column ModuleRef.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleRef.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleRef.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ModuleRef.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.ModuleRef.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleRef.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ModuleRef.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.ModuleRef.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.DefinitionModule">
            <summary>
            Gets the definition module, i.e., the module which it references, or <c>null</c>
            if the module can't be found.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.DefinitionAssembly">
            <summary>
            Gets the definition assembly, i.e., the assembly of the module it references, or
            <c>null</c> if the assembly can't be found.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleRef.FullName">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleRef.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.ModuleRefUser">
            <summary>
            A ModuleRef row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleRefUser.#ctor(dnlib.DotNet.ModuleDef)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
        </member>
        <member name="M:dnlib.DotNet.ModuleRefUser.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
            <param name="name">Module name</param>
        </member>
        <member name="T:dnlib.DotNet.ModuleRefMD">
            <summary>
            Created from a row in the ModuleRef table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ModuleRefMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleRefMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleRefMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleRefMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ModuleRefMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>ModuleRef</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.NativeType">
            <summary>
            Native types used by field marshals. See CorHdr.h/CorNativeType
            </summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.End">
            <summary>Deprecated</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.Void">
            <summary>void</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.Boolean">
            <summary>bool</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.I1">
            <summary>int8</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.U1">
            <summary>unsigned int8</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.I2">
            <summary>int16</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.U2">
            <summary>unsigned int16</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.I4">
            <summary>int32</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.U4">
            <summary>unsigned int32</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.I8">
            <summary>int64</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.U8">
            <summary>unsigned int64</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.R4">
            <summary>float32</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.R8">
            <summary>float64</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.SysChar">
            <summary>syschar</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.Variant">
            <summary>variant</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.Currency">
            <summary>currency</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.Ptr">
            <summary>ptr</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.Decimal">
            <summary>decimal</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.Date">
            <summary>date</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.BStr">
            <summary>bstr</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.LPStr">
            <summary>lpstr</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.LPWStr">
            <summary>lpwstr</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.LPTStr">
            <summary>lptstr</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.FixedSysString">
            <summary>fixed sysstring</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.ObjectRef">
            <summary>objectref</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.IUnknown">
            <summary>iunknown</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.IDispatch">
            <summary>idispatch</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.Struct">
            <summary>struct</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.IntF">
            <summary>interface</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.SafeArray">
            <summary>safearray</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.FixedArray">
            <summary>fixed array</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.Int">
            <summary>int</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.UInt">
            <summary>uint</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.NestedStruct">
            <summary>nested struct</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.ByValStr">
            <summary>byvalstr</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.ANSIBStr">
            <summary>ansi bstr</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.TBStr">
            <summary>tbstr</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.VariantBool">
            <summary>variant bool</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.Func">
            <summary>func</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.ASAny">
            <summary>as any</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.Array">
            <summary>array</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.LPStruct">
            <summary>lpstruct</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.CustomMarshaler">
            <summary>custom marshaler</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.Error">
            <summary>error</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.IInspectable">
            <summary>iinspectable</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.HString">
            <summary>hstring</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.LPUTF8Str">
            <summary>UTF-8 encoded string</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.Max">
            <summary>first invalid element type</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.NotInitialized">
            <summary>Value wasn't present in the blob</summary>
        </member>
        <member name="F:dnlib.DotNet.NativeType.RawBlob">
            <summary>Raw marshal blob type</summary>
        </member>
        <member name="T:dnlib.DotNet.NullResolver">
            <summary>
            A resolver that always fails
            </summary>
        </member>
        <member name="F:dnlib.DotNet.NullResolver.Instance">
            <summary>
            The one and only instance of this type
            </summary>
        </member>
        <member name="M:dnlib.DotNet.NullResolver.Resolve(dnlib.DotNet.IAssembly,dnlib.DotNet.ModuleDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.NullResolver.Resolve(dnlib.DotNet.TypeRef,dnlib.DotNet.ModuleDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.NullResolver.Resolve(dnlib.DotNet.MemberRef)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.ParamAttributes">
            <summary>
            Parameter flags. See CorHdr.h/CorParamAttr
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ParamAttributes.In">
            <summary>Param is [In]</summary>
        </member>
        <member name="F:dnlib.DotNet.ParamAttributes.Out">
            <summary>Param is [out]</summary>
        </member>
        <member name="F:dnlib.DotNet.ParamAttributes.Lcid">
            <summary>Param is a locale identifier</summary>
        </member>
        <member name="F:dnlib.DotNet.ParamAttributes.Retval">
            <summary>Param is a return value</summary>
        </member>
        <member name="F:dnlib.DotNet.ParamAttributes.Optional">
            <summary>Param is optional</summary>
        </member>
        <member name="F:dnlib.DotNet.ParamAttributes.HasDefault">
            <summary>Param has default value.</summary>
        </member>
        <member name="F:dnlib.DotNet.ParamAttributes.HasFieldMarshal">
            <summary>Param has FieldMarshal.</summary>
        </member>
        <member name="T:dnlib.DotNet.ParamDef">
            <summary>
            A high-level representation of a row in the Param table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ParamDef.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.HasConstantTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.HasFieldMarshalTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.DeclaringMethod">
            <summary>
            Gets the declaring method
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ParamDef.declaringMethod">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.Attributes">
            <summary>
            From column Param.Flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ParamDef.attributes">
            <summary>Attributes</summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.Sequence">
            <summary>
            From column Param.Sequence
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ParamDef.sequence">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.Name">
            <summary>
            From column Param.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ParamDef.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.MarshalType">
            <inheritdoc/>
        </member>
        <member name="F:dnlib.DotNet.ParamDef.marshalType">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.ParamDef.marshalType_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ParamDef.GetMarshalType_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.ParamDef.marshalType"/></summary>
        </member>
        <member name="M:dnlib.DotNet.ParamDef.ResetMarshalType">
            <summary>Reset <see cref="P:dnlib.DotNet.ParamDef.MarshalType"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.Constant">
            <inheritdoc/>
        </member>
        <member name="F:dnlib.DotNet.ParamDef.constant">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.ParamDef.constant_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ParamDef.GetConstant_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.ParamDef.constant"/></summary>
        </member>
        <member name="M:dnlib.DotNet.ParamDef.ResetConstant">
            <summary>Reset <see cref="P:dnlib.DotNet.ParamDef.Constant"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ParamDef.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ParamDef.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.ParamDef.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ParamDef.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.ParamDef.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.ParamDef.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.HasConstant">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ParamDef.Constant"/> is not <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.ElementType">
            <summary>
            Gets the constant element type or <see cref="F:dnlib.DotNet.ElementType.End"/> if there's no constant
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.HasMarshalType">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.ParamDef.MarshalType"/> is not <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.FullName">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ParamDef.ModifyAttributes(System.Boolean,dnlib.DotNet.ParamAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.ParamDef.attributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.IsIn">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.ParamAttributes.In"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.IsOut">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.ParamAttributes.Out"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.IsLcid">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.ParamAttributes.Lcid"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.IsRetval">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.ParamAttributes.Retval"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.IsOptional">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.ParamAttributes.Optional"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.HasDefault">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.ParamAttributes.HasDefault"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDef.HasFieldMarshal">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.ParamAttributes.HasFieldMarshal"/> bit
            </summary>
        </member>
        <member name="T:dnlib.DotNet.ParamDefUser">
            <summary>
            A Param row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ParamDefUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ParamDefUser.#ctor(dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:dnlib.DotNet.ParamDefUser.#ctor(dnlib.DotNet.UTF8String,System.UInt16)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
            <param name="sequence">Sequence</param>
        </member>
        <member name="M:dnlib.DotNet.ParamDefUser.#ctor(dnlib.DotNet.UTF8String,System.UInt16,dnlib.DotNet.ParamAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
            <param name="sequence">Sequence</param>
            <param name="flags">Flags</param>
        </member>
        <member name="T:dnlib.DotNet.ParamDefMD">
            <summary>
            Created from a row in the Param table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ParamDefMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.ParamDefMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ParamDefMD.GetMarshalType_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ParamDefMD.GetConstant_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ParamDefMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ParamDefMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ParamDefMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>Param</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.ParameterList">
            <summary>
            A list of all method parameters
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParameterList.Method">
            <summary>
            Gets the owner method
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParameterList.Count">
            <summary>
            Gets the number of parameters, including a possible hidden 'this' parameter
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParameterList.MethodSigIndexBase">
            <summary>
            Gets the index of the first parameter that is present in the method signature.
            If this is a static method, the value is 0, else it's an instance method so the
            index is 1 since the first parameter is the hidden 'this' parameter.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParameterList.Item(System.Int32)">
            <summary>
            Gets the N'th parameter
            </summary>
            <param name="index">The parameter index</param>
        </member>
        <member name="P:dnlib.DotNet.ParameterList.ReturnParameter">
            <summary>
            Gets the method return parameter
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ParameterList.#ctor(dnlib.DotNet.MethodDef,dnlib.DotNet.TypeDef)">
            <summary>
            Constructor
            </summary>
            <param name="method">The method with all parameters</param>
            <param name="declaringType"><paramref name="method"/>'s declaring type</param>
        </member>
        <member name="M:dnlib.DotNet.ParameterList.UpdateThisParameterType(dnlib.DotNet.TypeDef)">
            <summary>
            Should be called when the method's declaring type has changed
            </summary>
            <param name="methodDeclaringType">Method declaring type</param>
        </member>
        <member name="M:dnlib.DotNet.ParameterList.UpdateParameterTypes">
            <summary>
            Should be called when the method sig has changed
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ParameterList.IndexOf(dnlib.DotNet.Parameter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.ParameterList.Enumerator">
            <summary>
            Enumerator
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ParameterList.Enumerator.Current">
            <summary>
            Gets the current value
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ParameterList.Enumerator.MoveNext">
            <summary>
            Moves to the next element in the collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.ParameterList.Enumerator.Dispose">
            <summary>
            Disposes the enumerator
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ParameterList.GetEnumerator">
            <summary>
            Gets the list enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.Parameter">
            <summary>
            A method parameter
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Parameter.HIDDEN_THIS_METHOD_SIG_INDEX">
            <summary>
            The hidden 'this' parameter's <see cref="P:dnlib.DotNet.Parameter.MethodSigIndex"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Parameter.RETURN_TYPE_METHOD_SIG_INDEX">
            <summary>
            The return type parameter's <see cref="P:dnlib.DotNet.Parameter.MethodSigIndex"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Parameter.Index">
            <summary>
            Gets the parameter index. If the method has a hidden 'this' parameter, that parameter
            has index 0 and the remaining parameters in the method signature start from index 1.
            The method return parameter has index <c>-1</c>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Parameter.MethodSigIndex">
            <summary>
            Gets the index of the parameter in the method signature. See also
            <see cref="F:dnlib.DotNet.Parameter.HIDDEN_THIS_METHOD_SIG_INDEX"/> and <see cref="F:dnlib.DotNet.Parameter.RETURN_TYPE_METHOD_SIG_INDEX"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Parameter.IsNormalMethodParameter">
            <summary>
            <c>true</c> if it's a normal visible method parameter, i.e., it's not the hidden
            'this' parameter and it's not the method return type parameter.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Parameter.IsHiddenThisParameter">
            <summary>
            <c>true</c> if it's the hidden 'this' parameter
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Parameter.IsReturnTypeParameter">
            <summary>
            <c>true</c> if it's the method return type parameter
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Parameter.Type">
            <summary>
            Gets the parameter type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Parameter.Method">
            <summary>
            Gets the owner method
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Parameter.ParamDef">
            <summary>
            Gets the <see cref="T:dnlib.DotNet.ParamDef"/> or <c>null</c> if not present
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Parameter.HasParamDef">
            <summary>
            <c>true</c> if it has a <see cref="T:dnlib.DotNet.ParamDef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Parameter.Name">
            <summary>
            Gets the name from <see cref="P:dnlib.DotNet.Parameter.ParamDef"/>. If <see cref="P:dnlib.DotNet.Parameter.ParamDef"/> is <c>null</c>,
            an empty string is returned.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Parameter.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="paramIndex">Parameter index</param>
        </member>
        <member name="M:dnlib.DotNet.Parameter.#ctor(System.Int32,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="paramIndex">Parameter index</param>
            <param name="type">Parameter type</param>
        </member>
        <member name="M:dnlib.DotNet.Parameter.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="paramIndex">Parameter index (0 is hidden this param if it exists)</param>
            <param name="methodSigIndex">Index in method signature</param>
        </member>
        <member name="M:dnlib.DotNet.Parameter.#ctor(System.Int32,System.Int32,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="paramIndex">Parameter index (0 is hidden this param if it exists)</param>
            <param name="methodSigIndex">Index in method signature</param>
            <param name="type">Parameter type</param>
        </member>
        <member name="M:dnlib.DotNet.Parameter.CreateParamDef">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.ParamDef"/> if it doesn't already exist
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Parameter.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids">
            <summary>
            Custom debug info guids
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.Dss.StreamIStream">
            <summary>
            Implements <see cref="T:System.Runtime.InteropServices.ComTypes.IStream"/> and uses a <see cref="T:System.IO.Stream"/> as the underlying
            stream.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Dss.StreamIStream.#ctor(System.IO.Stream)">
            <summary>
            Constructor
            </summary>
            <param name="stream">Source stream</param>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Dss.StreamIStream.#ctor(System.IO.Stream,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="stream">Source stream</param>
            <param name="name">Name of original file or <c>null</c> if unknown.</param>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Dss.StreamIStream.Clone(System.Runtime.InteropServices.ComTypes.IStream@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Dss.StreamIStream.Commit(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Dss.StreamIStream.CopyTo(System.Runtime.InteropServices.ComTypes.IStream,System.Int64,System.IntPtr,System.IntPtr)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Dss.StreamIStream.LockRegion(System.Int64,System.Int64,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Dss.StreamIStream.Read(System.Byte[],System.Int32,System.IntPtr)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Dss.StreamIStream.Revert">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Dss.StreamIStream.Seek(System.Int64,System.Int32,System.IntPtr)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Dss.StreamIStream.SetSize(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Dss.StreamIStream.Stat(System.Runtime.InteropServices.ComTypes.STATSTG@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Dss.StreamIStream.UnlockRegion(System.Int64,System.Int64,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Dss.StreamIStream.Write(System.Byte[],System.Int32,System.IntPtr)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Pdb.IMAGE_DEBUG_DIRECTORY">
            <summary>
            IMAGE_DEBUG_DIRECTORY
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.Managed.PdbAddress">
            <summary>
            An address in the image
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.Managed.PdbAddress.Section">
            <summary>
            Section
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.Managed.PdbAddress.Offset">
            <summary>
            Offset in <see cref="F:dnlib.DotNet.Pdb.Managed.PdbAddress.Section"/>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.#ctor(System.UInt16,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="section">Section</param>
            <param name="offset">Offset in <paramref name="section"/></param>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.#ctor(System.UInt16,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="section">Section</param>
            <param name="offset">Offset in <paramref name="section"/></param>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.op_LessThanOrEqual(dnlib.DotNet.Pdb.Managed.PdbAddress,dnlib.DotNet.Pdb.Managed.PdbAddress)">
            <summary>
            Returns <c>true</c> if <paramref name="a"/> is less than or equal to <paramref name="b"/>
            </summary>
            <param name="a">First <see cref="T:dnlib.DotNet.Pdb.Managed.PdbAddress"/></param>
            <param name="b">Second <see cref="T:dnlib.DotNet.Pdb.Managed.PdbAddress"/></param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.op_LessThan(dnlib.DotNet.Pdb.Managed.PdbAddress,dnlib.DotNet.Pdb.Managed.PdbAddress)">
            <summary>
            Returns <c>true</c> if <paramref name="a"/> is less than <paramref name="b"/>
            </summary>
            <param name="a">First <see cref="T:dnlib.DotNet.Pdb.Managed.PdbAddress"/></param>
            <param name="b">Second <see cref="T:dnlib.DotNet.Pdb.Managed.PdbAddress"/></param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.op_GreaterThanOrEqual(dnlib.DotNet.Pdb.Managed.PdbAddress,dnlib.DotNet.Pdb.Managed.PdbAddress)">
            <summary>
            Returns <c>true</c> if <paramref name="a"/> is greater than or equal to <paramref name="b"/>
            </summary>
            <param name="a">First <see cref="T:dnlib.DotNet.Pdb.Managed.PdbAddress"/></param>
            <param name="b">Second <see cref="T:dnlib.DotNet.Pdb.Managed.PdbAddress"/></param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.op_GreaterThan(dnlib.DotNet.Pdb.Managed.PdbAddress,dnlib.DotNet.Pdb.Managed.PdbAddress)">
            <summary>
            Returns <c>true</c> if <paramref name="a"/> is greater than <paramref name="b"/>
            </summary>
            <param name="a">First <see cref="T:dnlib.DotNet.Pdb.Managed.PdbAddress"/></param>
            <param name="b">Second <see cref="T:dnlib.DotNet.Pdb.Managed.PdbAddress"/></param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.op_Equality(dnlib.DotNet.Pdb.Managed.PdbAddress,dnlib.DotNet.Pdb.Managed.PdbAddress)">
            <summary>
            Returns <c>true</c> if <paramref name="a"/> is equal to <paramref name="b"/>
            </summary>
            <param name="a">First <see cref="T:dnlib.DotNet.Pdb.Managed.PdbAddress"/></param>
            <param name="b">Second <see cref="T:dnlib.DotNet.Pdb.Managed.PdbAddress"/></param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.op_Inequality(dnlib.DotNet.Pdb.Managed.PdbAddress,dnlib.DotNet.Pdb.Managed.PdbAddress)">
            <summary>
            Returns <c>true</c> if <paramref name="a"/> is not equal to <paramref name="b"/>
            </summary>
            <param name="a">First <see cref="T:dnlib.DotNet.Pdb.Managed.PdbAddress"/></param>
            <param name="b">Second <see cref="T:dnlib.DotNet.Pdb.Managed.PdbAddress"/></param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.CompareTo(dnlib.DotNet.Pdb.Managed.PdbAddress)">
            <summary>
            Compares this instance with <paramref name="other"/> and returns less than 0 if it's
            less than <paramref name="other"/>, 0 if it's equal to <paramref name="other"/> and
            greater than 0 if it's greater than <paramref name="other"/>
            </summary>
            <param name="other">Other instance</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.Equals(dnlib.DotNet.Pdb.Managed.PdbAddress)">
            <summary>
            Compares this to another instance
            </summary>
            <param name="other">The other one</param>
            <returns><c>true</c> if they're equal</returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.Equals(System.Object)">
            <summary>
            Compares this to another instance
            </summary>
            <param name="obj">The other one</param>
            <returns><c>true</c> if they're equal</returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.GetHashCode">
            <summary>
            Gets the hash code
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.ToString">
            <summary>
            ToString() override
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbAddress.ReadAddress(dnlib.IO.DataReader@)">
            <summary>
            Reads a 32-bit offset followed by a 16-bit section and creates a new <see cref="T:dnlib.DotNet.Pdb.Managed.PdbAddress"/>
            </summary>
            <param name="reader">Reader</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.Pdb.Managed.PdbException">
            <summary>
            Exception that is thrown when <see cref="T:dnlib.DotNet.Pdb.Managed.PdbReader"/> encounters an error.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Exception message</param>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbException.#ctor(System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="innerException">Inner exception</param>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.Managed.PdbReader">
            <summary>
            A managed PDB reader implementation for .NET modules.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.PdbReader.Read(dnlib.IO.DataReader)">
            <summary>
            Read the PDB in the specified stream.
            </summary>
            <param name="reader">PDB file data reader</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.Managed.SymbolReaderFactory">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.Pdb.Symbols.SymbolReader"/> instance
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Managed.SymbolReaderFactory.Create(dnlib.DotNet.Pdb.PdbReaderContext,dnlib.IO.DataReaderFactory)">
            <summary>
            Creates a new <see cref="T:dnlib.DotNet.Pdb.Symbols.SymbolReader"/> instance
            </summary>
            <param name="pdbContext">PDB context</param>
            <param name="pdbStream">PDB file stream which is now owned by this method</param>
            <returns>A new <see cref="T:dnlib.DotNet.Pdb.Symbols.SymbolReader"/> instance or <c>null</c>.</returns>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbConstant">
            <summary>
            A constant in a method scope, eg. "const int SomeConstant = 123;"
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbConstant.Name">
            <summary>
            Gets/sets the name
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbConstant.Type">
            <summary>
            Gets/sets the type of the constant
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbConstant.Value">
            <summary>
            Gets/sets the value of the constant
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbConstant.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbConstant.#ctor(System.String,dnlib.DotNet.TypeSig,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name of constant</param>
            <param name="type">Type of constant</param>
            <param name="value">Constant value</param>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbConstant.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbConstant.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbConstant.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbConstant.ToString">
            <summary>
            ToString()
            </summary>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind">
            <summary>
            Custom debug info kind
            </summary>
            <remarks>See <c>CustomDebugInfoKind</c> in Roslyn source code</remarks>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.UsingGroups">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbUsingGroupsCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.ForwardMethodInfo">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbForwardMethodInfoCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.ForwardModuleInfo">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbForwardModuleInfoCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbStateMachineHoistedLocalScopesCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.StateMachineTypeName">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbStateMachineTypeNameCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.DynamicLocals">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbDynamicLocalsCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbEditAndContinueLocalSlotMapCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.EditAndContinueLambdaMap">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbEditAndContinueLambdaMapCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.TupleElementNames">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbTupleElementNamesCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.TupleElementNames_PortablePdb">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PortablePdbTupleElementNamesCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.DefaultNamespace">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbDefaultNamespaceCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.DynamicLocalVariables">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbDynamicLocalVariablesCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.EmbeddedSource">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbEmbeddedSourceCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.SourceLink">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbSourceLinkCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.SourceServer">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbSourceServerCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.AsyncMethod">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbAsyncMethodCustomDebugInfo"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.IteratorMethod">
            <summary>
            <see cref="T:dnlib.DotNet.Pdb.PdbIteratorMethodCustomDebugInfo"/>
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbCustomDebugInfo">
            <summary>
            Base class of custom debug info added to the PDB file by the compiler
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbCustomDebugInfo.Kind">
            <summary>
            Gets the custom debug info kind
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbUnknownCustomDebugInfo">
            <summary>
            Unknown custom debug info. If you see an instance of this class, you're using an old dnlib version or
            dnlib hasn't been updated to support this new custom debug info kind.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbUnknownCustomDebugInfo.Kind">
            <summary>
            Gets the custom debug info kind
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbUnknownCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbUnknownCustomDebugInfo.Data">
            <summary>
            Gets the data
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbUnknownCustomDebugInfo.#ctor(dnlib.DotNet.Pdb.PdbCustomDebugInfoKind,System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="kind">Custom debug info kind</param>
            <param name="data">Raw custom debug info data</param>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbUnknownCustomDebugInfo.#ctor(System.Guid,System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="guid">Custom debug info guid</param>
            <param name="data">Raw custom debug info data</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbUsingGroupsCustomDebugInfo">
            <summary>
            Contains sizes of using groups
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbUsingGroupsCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.UsingGroups"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbUsingGroupsCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbUsingGroupsCustomDebugInfo.UsingCounts">
            <summary>
            Gets the using counts
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbUsingGroupsCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbUsingGroupsCustomDebugInfo.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="capacity">Initial capacity of <see cref="P:dnlib.DotNet.Pdb.PdbUsingGroupsCustomDebugInfo.UsingCounts"/></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbForwardMethodInfoCustomDebugInfo">
            <summary>
            Contains a reference to another method that contains the import strings
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbForwardMethodInfoCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.ForwardMethodInfo"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbForwardMethodInfoCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbForwardMethodInfoCustomDebugInfo.Method">
            <summary>
            Gets/sets the referenced method
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbForwardMethodInfoCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbForwardMethodInfoCustomDebugInfo.#ctor(dnlib.DotNet.IMethodDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="method">The referenced method</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbForwardModuleInfoCustomDebugInfo">
            <summary>
            Contains a reference to another method that contains the per-module debug info (assembly reference aliases)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbForwardModuleInfoCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.ForwardModuleInfo"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbForwardModuleInfoCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbForwardModuleInfoCustomDebugInfo.Method">
            <summary>
            Gets/sets the referenced method
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbForwardModuleInfoCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbForwardModuleInfoCustomDebugInfo.#ctor(dnlib.DotNet.IMethodDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="method">The referenced method</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.StateMachineHoistedLocalScope">
            <summary>
            State machine hosted local scope info
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.StateMachineHoistedLocalScope.IsSynthesizedLocal">
            <summary>
            true if it's a syntesized local (<see cref="F:dnlib.DotNet.Pdb.StateMachineHoistedLocalScope.Start"/> and <see cref="F:dnlib.DotNet.Pdb.StateMachineHoistedLocalScope.End"/> are both null)
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.StateMachineHoistedLocalScope.Start">
            <summary>
            The instruction of the first operation in the scope. Can be null if it's a synthesized local
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.StateMachineHoistedLocalScope.End">
            <summary>
            The instruction of the first operation outside of the scope or null if it ends at the last instruction in the body.
            Can also be null if it's a synthesized local (in which case <see cref="F:dnlib.DotNet.Pdb.StateMachineHoistedLocalScope.Start"/> is also null, see <see cref="P:dnlib.DotNet.Pdb.StateMachineHoistedLocalScope.IsSynthesizedLocal"/>)
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.StateMachineHoistedLocalScope.#ctor(dnlib.DotNet.Emit.Instruction,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Constructor
            </summary>
            <param name="start">Start of the scope</param>
            <param name="end">First instruction after the end of the scope</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbStateMachineHoistedLocalScopesCustomDebugInfo">
            <summary>
            Contains local scopes for state machine hoisted local variables.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbStateMachineHoistedLocalScopesCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbStateMachineHoistedLocalScopesCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbStateMachineHoistedLocalScopesCustomDebugInfo.Scopes">
            <summary>
            Gets the scopes
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbStateMachineHoistedLocalScopesCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbStateMachineHoistedLocalScopesCustomDebugInfo.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="capacity">Initial capacity of <see cref="P:dnlib.DotNet.Pdb.PdbStateMachineHoistedLocalScopesCustomDebugInfo.Scopes"/></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbStateMachineTypeNameCustomDebugInfo">
            <summary>
            Contains the state machine type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbStateMachineTypeNameCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.StateMachineTypeName"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbStateMachineTypeNameCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbStateMachineTypeNameCustomDebugInfo.Type">
            <summary>
            Gets/sets the state machine type
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbStateMachineTypeNameCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbStateMachineTypeNameCustomDebugInfo.#ctor(dnlib.DotNet.TypeDef)">
            <summary>
            Constructor
            </summary>
            <param name="type">State machine type</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbDynamicLocalsCustomDebugInfo">
            <summary>
            Contains dynamic flags for local variables and constants
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDynamicLocalsCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.DynamicLocals"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDynamicLocalsCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDynamicLocalsCustomDebugInfo.Locals">
            <summary>
            Gets the dynamic locals
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbDynamicLocalsCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbDynamicLocalsCustomDebugInfo.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="capacity">Initial capacity of <see cref="P:dnlib.DotNet.Pdb.PdbDynamicLocalsCustomDebugInfo.Locals"/></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbDynamicLocal">
            <summary>
            Dynamic local info
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDynamicLocal.Flags">
            <summary>
            Gets the dynamic flags
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDynamicLocal.Name">
            <summary>
            Gets/sets the name of the local. The name must have at most 64 characters and no char can be NUL (0x0000).
            If null is written, <see cref="P:dnlib.DotNet.Emit.Local.Name"/> is returned instead.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDynamicLocal.IsConstant">
            <summary>
            true if it's a constant and not a variable (<see cref="P:dnlib.DotNet.Pdb.PdbDynamicLocal.Local"/> is null)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDynamicLocal.IsVariable">
            <summary>
            true if it's a variable (<see cref="P:dnlib.DotNet.Pdb.PdbDynamicLocal.Local"/> is not null)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDynamicLocal.Local">
            <summary>
            Gets/sets the local. Could be null if there's no local (it's a 'const' local).
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbDynamicLocal.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbDynamicLocal.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="capacity">Initial capacity of <see cref="P:dnlib.DotNet.Pdb.PdbDynamicLocal.Flags"/></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbEditAndContinueLocalSlotMapCustomDebugInfo">
            <summary>
            Contains the EnC local variable slot map
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbEditAndContinueLocalSlotMapCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbEditAndContinueLocalSlotMapCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbEditAndContinueLocalSlotMapCustomDebugInfo.Data">
            <summary>
            Gets the data. Spec: https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#EditAndContinueLocalSlotMap
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbEditAndContinueLocalSlotMapCustomDebugInfo.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="data">Raw custom debug info data</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbEditAndContinueLambdaMapCustomDebugInfo">
            <summary>
            Contains the EnC lambda map
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbEditAndContinueLambdaMapCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.EditAndContinueLambdaMap"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbEditAndContinueLambdaMapCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbEditAndContinueLambdaMapCustomDebugInfo.Data">
            <summary>
            Gets the data. Spec: https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#EditAndContinueLambdaAndClosureMap
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbEditAndContinueLambdaMapCustomDebugInfo.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="data">Raw custom debug info data</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbTupleElementNamesCustomDebugInfo">
            <summary>
            Contains tuple element names for local variables and constants
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbTupleElementNamesCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.TupleElementNames"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbTupleElementNamesCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbTupleElementNamesCustomDebugInfo.Names">
            <summary>
            Gets the tuple element names
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbTupleElementNamesCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbTupleElementNamesCustomDebugInfo.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="capacity">Initial capacity of <see cref="P:dnlib.DotNet.Pdb.PdbTupleElementNamesCustomDebugInfo.Names"/></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbTupleElementNames">
            <summary>
            Tuple element name info
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbTupleElementNames.Name">
            <summary>
            Gets/sets the name of the local. If null is written, <see cref="P:dnlib.DotNet.Emit.Local.Name"/> is returned instead.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbTupleElementNames.Local">
            <summary>
            Gets/sets the local. It's null if it's a constant, and non-null if it's a variable
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbTupleElementNames.IsConstant">
            <summary>
            true if it's a constant. Constants have a scope (<see cref="P:dnlib.DotNet.Pdb.PdbTupleElementNames.ScopeStart"/> and <see cref="P:dnlib.DotNet.Pdb.PdbTupleElementNames.ScopeEnd"/>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbTupleElementNames.IsVariable">
            <summary>
            true if it's a variable. Variables don't have a scope (<see cref="P:dnlib.DotNet.Pdb.PdbTupleElementNames.ScopeStart"/> and <see cref="P:dnlib.DotNet.Pdb.PdbTupleElementNames.ScopeEnd"/>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbTupleElementNames.ScopeStart">
            <summary>
            Gets/sets the start of the scope or null. Only constants have a scope.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbTupleElementNames.ScopeEnd">
            <summary>
            Gets/sets the end of the scope or null if it has no scope or if the scope ends at the end of the body. Only constants have a scope.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbTupleElementNames.TupleElementNames">
            <summary>
            Gets the tuple element names
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbTupleElementNames.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbTupleElementNames.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="capacity">Initial capacity of <see cref="P:dnlib.DotNet.Pdb.PdbTupleElementNames.TupleElementNames"/></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PortablePdbTupleElementNamesCustomDebugInfo">
            <summary>
            Contains tuple element names for local variables and constants
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PortablePdbTupleElementNamesCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.TupleElementNames_PortablePdb"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PortablePdbTupleElementNamesCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PortablePdbTupleElementNamesCustomDebugInfo.Names">
            <summary>
            Gets the tuple element names
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PortablePdbTupleElementNamesCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PortablePdbTupleElementNamesCustomDebugInfo.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="capacity">Initial capacity of <see cref="P:dnlib.DotNet.Pdb.PortablePdbTupleElementNamesCustomDebugInfo.Names"/></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbAsyncMethodSteppingInformationCustomDebugInfo">
            <summary>
            Async method stepping info
            
            It's internal and translated to a <see cref="T:dnlib.DotNet.Pdb.PdbAsyncMethodCustomDebugInfo"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAsyncMethodSteppingInformationCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.Unknown"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAsyncMethodSteppingInformationCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAsyncMethodSteppingInformationCustomDebugInfo.CatchHandler">
            <summary>
            Gets the catch handler instruction or null
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAsyncMethodSteppingInformationCustomDebugInfo.AsyncStepInfos">
            <summary>
            Gets all async step infos
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbAsyncMethodSteppingInformationCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbDefaultNamespaceCustomDebugInfo">
            <summary>
            Default namespace
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDefaultNamespaceCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.DefaultNamespace"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDefaultNamespaceCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDefaultNamespaceCustomDebugInfo.Namespace">
            <summary>
            Gets the default namespace
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbDefaultNamespaceCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbDefaultNamespaceCustomDebugInfo.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="defaultNamespace">Default namespace</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbDynamicLocalVariablesCustomDebugInfo">
            <summary>
            Dynamic flags
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDynamicLocalVariablesCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.DynamicLocalVariables"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDynamicLocalVariablesCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDynamicLocalVariablesCustomDebugInfo.Flags">
            <summary>
            Gets/sets the dynamic flags
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbDynamicLocalVariablesCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbDynamicLocalVariablesCustomDebugInfo.#ctor(System.Boolean[])">
            <summary>
            Constructor
            </summary>
            <param name="flags">Dynamic flags</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbEmbeddedSourceCustomDebugInfo">
            <summary>
            Contains the source code
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbEmbeddedSourceCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.EmbeddedSource"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbEmbeddedSourceCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbEmbeddedSourceCustomDebugInfo.SourceCodeBlob">
            <summary>
            Gets the source code blob.
            
            It's not decompressed and converted to a string because the encoding isn't specified.
            
            https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#embedded-source-c-and-vb-compilers
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbEmbeddedSourceCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbEmbeddedSourceCustomDebugInfo.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="sourceCodeBlob">Source code blob</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbSourceLinkCustomDebugInfo">
            <summary>
            Contains the source link file
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbSourceLinkCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.SourceLink"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbSourceLinkCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbSourceLinkCustomDebugInfo.FileBlob">
            <summary>
            Gets the source link file contents
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbSourceLinkCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbSourceLinkCustomDebugInfo.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="fileBlob">Source link file contents</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbSourceServerCustomDebugInfo">
            <summary>
            Contains the source server file
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbSourceServerCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.SourceServer"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbSourceServerCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbSourceServerCustomDebugInfo.FileBlob">
            <summary>
            Gets the source server file contents
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbSourceServerCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbSourceServerCustomDebugInfo.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="fileBlob">Source server file contents</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbAsyncMethodCustomDebugInfo">
            <summary>
            Async method info
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAsyncMethodCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.AsyncMethod"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAsyncMethodCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAsyncMethodCustomDebugInfo.KickoffMethod">
            <summary>
            Gets/sets the starting method that initiates the async operation
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAsyncMethodCustomDebugInfo.CatchHandlerInstruction">
            <summary>
            Gets/sets the instruction for the compiler generated catch handler that wraps an async method.
            This can be null.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAsyncMethodCustomDebugInfo.StepInfos">
            <summary>
            Gets all step infos used by the debugger
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbAsyncMethodCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbAsyncMethodCustomDebugInfo.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="stepInfosCapacity">Default capacity for <see cref="P:dnlib.DotNet.Pdb.PdbAsyncMethodCustomDebugInfo.StepInfos"/></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbAsyncStepInfo">
            <summary>
            Async step info used by debuggers
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbAsyncStepInfo.YieldInstruction">
            <summary>
            The yield instruction
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbAsyncStepInfo.BreakpointMethod">
            <summary>
            Resume method
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbAsyncStepInfo.BreakpointInstruction">
            <summary>
            Resume instruction (where the debugger puts a breakpoint)
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbAsyncStepInfo.#ctor(dnlib.DotNet.Emit.Instruction,dnlib.DotNet.MethodDef,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Constructor
            </summary>
            <param name="yieldInstruction">The yield instruction</param>
            <param name="breakpointMethod">Resume method</param>
            <param name="breakpointInstruction">Resume instruction (where the debugger puts a breakpoint)</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbIteratorMethodCustomDebugInfo">
            <summary>
            Iterator method
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbIteratorMethodCustomDebugInfo.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbCustomDebugInfoKind.IteratorMethod"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbIteratorMethodCustomDebugInfo.Guid">
            <summary>
            Gets the custom debug info guid, see <see cref="T:dnlib.DotNet.Pdb.CustomDebugInfoGuids"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbIteratorMethodCustomDebugInfo.KickoffMethod">
            <summary>
            Gets the kickoff method
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbIteratorMethodCustomDebugInfo.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbIteratorMethodCustomDebugInfo.#ctor(dnlib.DotNet.MethodDef)">
            <summary>
            Constructor
            </summary>
            <param name="kickoffMethod">Kickoff method</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbDocument">
            <summary>
            A PDB document
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDocument.Url">
            <summary>
            Gets/sets the document URL
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDocument.Language">
            <summary>
            Gets/sets the language GUID. See <see cref="T:dnlib.DotNet.Pdb.PdbDocumentConstants"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDocument.LanguageVendor">
            <summary>
            Gets/sets the language vendor GUID. See <see cref="T:dnlib.DotNet.Pdb.PdbDocumentConstants"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDocument.DocumentType">
            <summary>
            Gets/sets the document type GUID. See <see cref="T:dnlib.DotNet.Pdb.PdbDocumentConstants"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDocument.CheckSumAlgorithmId">
            <summary>
            Gets/sets the checksum algorithm ID. See <see cref="T:dnlib.DotNet.Pdb.PdbDocumentConstants"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDocument.CheckSum">
            <summary>
            Gets/sets the checksum
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDocument.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDocument.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbDocument.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbDocument.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbDocument.#ctor(dnlib.DotNet.Pdb.Symbols.SymbolDocument)">
            <summary>
            Constructor
            </summary>
            <param name="symDoc">A <see cref="T:dnlib.DotNet.Pdb.Symbols.SymbolDocument"/> instance</param>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbDocument.#ctor(System.String,System.Guid,System.Guid,System.Guid,System.Guid,System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="url">Document URL</param>
            <param name="language">Language. See <see cref="T:dnlib.DotNet.Pdb.PdbDocumentConstants"/></param>
            <param name="languageVendor">Language vendor. See <see cref="T:dnlib.DotNet.Pdb.PdbDocumentConstants"/></param>
            <param name="documentType">Document type. See <see cref="T:dnlib.DotNet.Pdb.PdbDocumentConstants"/></param>
            <param name="checkSumAlgorithmId">Checksum algorithm ID. See <see cref="T:dnlib.DotNet.Pdb.PdbDocumentConstants"/></param>
            <param name="checkSum">Checksum</param>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbDocument.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbDocument.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbDocumentConstants">
            <summary>
            PDB document constants
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbFileKind">
            <summary>
            PDB file kind
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbFileKind.WindowsPDB">
            <summary>
            Windows PDB
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbFileKind.PortablePDB">
            <summary>
            Portable PDB
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbFileKind.EmbeddedPortablePDB">
            <summary>
            Embedded portable PDB
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbImportScope">
            <summary>
            Import scope
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbImportScope.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportScope.Parent">
            <summary>
            Gets/sets the parent import scope
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportScope.Imports">
            <summary>
            Gets all imports
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportScope.HasImports">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.Pdb.PdbImportScope.Imports"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportScope.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportScope.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportScope.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbImportDefinitionKind">
            <summary>
            Import kind
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbImport">
            <summary>
            PDB import base class
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImport.Kind">
            <summary>
            Gets the import kind
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbImportNamespace">
            <summary>
            Import namespace
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportNamespace.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbImportDefinitionKind.ImportNamespace"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportNamespace.TargetNamespace">
            <summary>
            Gets the target namespace
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbImportNamespace.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbImportNamespace.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="targetNamespace"></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbImportAssemblyNamespace">
            <summary>
            Import assembly, namespace
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportAssemblyNamespace.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbImportDefinitionKind.ImportAssemblyNamespace"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportAssemblyNamespace.TargetAssembly">
            <summary>
            Gets the target assembly
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportAssemblyNamespace.TargetNamespace">
            <summary>
            Gets the target namespace
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbImportAssemblyNamespace.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbImportAssemblyNamespace.#ctor(dnlib.DotNet.AssemblyRef,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="targetAssembly"></param>
            <param name="targetNamespace"></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbImportType">
            <summary>
            Import type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportType.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbImportDefinitionKind.ImportType"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportType.TargetType">
            <summary>
            Gets the target type
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbImportType.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbImportType.#ctor(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="targetType"></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbImportXmlNamespace">
            <summary>
            Import xml namespace
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportXmlNamespace.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbImportDefinitionKind.ImportXmlNamespace"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportXmlNamespace.Alias">
            <summary>
            Gets the alias
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportXmlNamespace.TargetNamespace">
            <summary>
            Gets the target namespace
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbImportXmlNamespace.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbImportXmlNamespace.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="alias"></param>
            <param name="targetNamespace"></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbImportAssemblyReferenceAlias">
            <summary>
            Import assembly reference alias
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportAssemblyReferenceAlias.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbImportDefinitionKind.ImportAssemblyReferenceAlias"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbImportAssemblyReferenceAlias.Alias">
            <summary>
            Gets the alias
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbImportAssemblyReferenceAlias.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbImportAssemblyReferenceAlias.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="alias"></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbAliasAssemblyReference">
            <summary>
            Alias assembly reference
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAliasAssemblyReference.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbImportDefinitionKind.AliasAssemblyReference"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAliasAssemblyReference.Alias">
            <summary>
            Gets the alias
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAliasAssemblyReference.TargetAssembly">
            <summary>
            Gets the target assembly
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbAliasAssemblyReference.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbAliasAssemblyReference.#ctor(System.String,dnlib.DotNet.AssemblyRef)">
            <summary>
            Constructor
            </summary>
            <param name="alias"></param>
            <param name="targetAssembly"></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbAliasNamespace">
            <summary>
            Alias namespace
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAliasNamespace.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbImportDefinitionKind.AliasNamespace"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAliasNamespace.Alias">
            <summary>
            Gets the alias
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAliasNamespace.TargetNamespace">
            <summary>
            Gets the target namespace
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbAliasNamespace.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbAliasNamespace.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="alias"></param>
            <param name="targetNamespace"></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbAliasAssemblyNamespace">
            <summary>
            Alias assembly namespace
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAliasAssemblyNamespace.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbImportDefinitionKind.AliasAssemblyNamespace"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAliasAssemblyNamespace.Alias">
            <summary>
            Gets the alias
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAliasAssemblyNamespace.TargetAssembly">
            <summary>
            Gets the target assembly
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAliasAssemblyNamespace.TargetNamespace">
            <summary>
            Gets the target namespace
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbAliasAssemblyNamespace.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbAliasAssemblyNamespace.#ctor(System.String,dnlib.DotNet.AssemblyRef,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="alias"></param>
            <param name="targetAssembly"></param>
            <param name="targetNamespace"></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbAliasType">
            <summary>
            Alias type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAliasType.Kind">
            <summary>
            Returns <see cref="F:dnlib.DotNet.Pdb.PdbImportDefinitionKind.AliasType"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAliasType.Alias">
            <summary>
            Gets the alias
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbAliasType.TargetType">
            <summary>
            Gets the target type
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbAliasType.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbAliasType.#ctor(System.String,dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="alias"></param>
            <param name="targetType"></param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbLocal">
            <summary>
            A local variable
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbLocal.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbLocal.#ctor(dnlib.DotNet.Emit.Local,System.String,dnlib.DotNet.Pdb.PdbLocalAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="local"></param>
            <param name="name"></param>
            <param name="attributes"></param>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbLocal.Local">
            <summary>
            Gets/sets the local
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbLocal.Name">
            <summary>
            Gets/sets the name
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbLocal.Attributes">
            <summary>
            Gets/sets the attributes
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbLocal.Index">
            <summary>
            Gets the index of the local
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbLocal.IsDebuggerHidden">
            <summary>
            true if it should be hidden in debugger variables windows. Not all compiler generated locals have this flag set.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbLocal.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbLocal.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbLocal.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbLocalAttributes">
            <summary>
            Local attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbLocalAttributes.None">
            <summary>
            No bit is set
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbLocalAttributes.DebuggerHidden">
            <summary>
            Local should be hidden in debugger variables windows. Not all compiler generated locals have this flag set.
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbMethod">
            <summary>
            A PDB method
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbMethod.Scope">
            <summary>
            Gets/sets the root scope. It contains all scopes of the method, using namespaces, variables and constants
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbMethod.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbReaderOptions">
            <summary>
            PDB reader options
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbReaderOptions.None">
            <summary>
            No bit is set
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbReaderOptions.MicrosoftComReader">
            <summary>
            Use the COM Windows PDB reader instead of the managed Windows PDB reader.
            
            This is NOT recommended since the COM reader can only be called on the same
            thread it was created on. It also requires a Windows OS.
            
            If this is not set, the managed PDB reader will be used.
            
            This option is only used if it's a Windows PDB file, not if it's a Portable PDB file.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbReaderOptions.NoDiaSymReader">
            <summary>
            Don't use Microsoft.DiaSymReader.Native. This is a NuGet package with an updated Windows PDB reader/writer implementation,
            and if it's available at runtime, dnlib will try to use it. If this option is set, dnlib won't use it.
            You have to add a reference to the NuGet package if you want to use it, dnlib has no reference to the NuGet package.
            
            Only used if <see cref="F:dnlib.DotNet.Pdb.PdbReaderOptions.MicrosoftComReader"/> is set and if it's a Windows PDB file
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.PdbReaderOptions.NoOldDiaSymReader">
            <summary>
            Don't use diasymreader.dll's PDB reader that is shipped with .NET Framework.
            
            Only used if <see cref="F:dnlib.DotNet.Pdb.PdbReaderOptions.MicrosoftComReader"/> is set and if it's a Windows PDB file
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbScope">
            <summary>
            A PDB scope
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbScope.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.Start">
            <summary>
            Gets/sets the first instruction
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.End">
            <summary>
            Gets/sets the last instruction. It's <c>null</c> if it ends at the end of the method.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.Scopes">
            <summary>
            Gets all child scopes
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.HasScopes">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.Pdb.PdbScope.Scopes"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.Variables">
            <summary>
            Gets all locals in this scope
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.HasVariables">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.Pdb.PdbScope.Variables"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.Namespaces">
            <summary>
            Gets all namespaces (Windows PDBs). Portable PDBs use <see cref="P:dnlib.DotNet.Pdb.PdbScope.ImportScope"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.HasNamespaces">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.Pdb.PdbScope.Namespaces"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.ImportScope">
            <summary>
            Gets/sets the import scope (Portable PDBs). Windows PDBs use <see cref="P:dnlib.DotNet.Pdb.PdbScope.Namespaces"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.Constants">
            <summary>
            Gets all constants
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.HasConstants">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.Pdb.PdbScope.Constants"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbScope.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.PdbState">
            <summary>
            PDB state for a <see cref="T:dnlib.DotNet.ModuleDef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbState.PdbFileKind">
            <summary>
            Gets/sets the PDB file kind. You can change it from portable PDB to embedded portable PDB
            and vice versa. Converting a Windows PDB to a portable PDB isn't supported.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbState.UserEntryPoint">
            <summary>
            Gets/sets the user entry point method.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbState.Documents">
            <summary>
            Gets all PDB documents
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.PdbState.HasDocuments">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.Pdb.PdbState.Documents"/> is not empty
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbState.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.Pdb.PdbFileKind)">
            <summary>
            Constructor
            </summary>
            <param name="module">Module</param>
            <param name="pdbFileKind">PDB file kind</param>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbState.#ctor(dnlib.DotNet.Pdb.Symbols.SymbolReader,dnlib.DotNet.ModuleDefMD)">
            <summary>
            Constructor
            </summary>
            <param name="reader">A <see cref="T:dnlib.DotNet.Pdb.Symbols.SymbolReader"/> instance</param>
            <param name="module">Owner module</param>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbState.Add(dnlib.DotNet.Pdb.PdbDocument)">
            <summary>
            Adds <paramref name="doc"/>
            </summary>
            <param name="doc">New document</param>
            <returns><paramref name="doc"/> if it wasn't inserted, or the already existing document
            if it was already inserted.</returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbState.Remove(dnlib.DotNet.Pdb.PdbDocument)">
            <summary>
            Removes <paramref name="doc"/>
            </summary>
            <param name="doc">Document</param>
            <returns><c>true</c> if it was removed, <c>false</c> if it wasn't inserted.</returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbState.GetExisting(dnlib.DotNet.Pdb.PdbDocument)">
            <summary>
            Returns an inserted <see cref="T:dnlib.DotNet.Pdb.PdbDocument"/> instance or <c>null</c> if it's not been
            inserted yet.
            </summary>
            <param name="doc">A PDB document</param>
            <returns>The existing <see cref="T:dnlib.DotNet.Pdb.PdbDocument"/> or <c>null</c> if it doesn't exist.</returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbState.RemoveAllDocuments">
            <summary>
            Removes all documents
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.PdbState.RemoveAllDocuments(System.Boolean)">
            <summary>
            Removes all documents and optionally returns them
            </summary>
            <param name="returnDocs"><c>true</c> if all the original <see cref="T:dnlib.DotNet.Pdb.PdbDocument"/>s
            should be returned.</param>
            <returns>All <see cref="T:dnlib.DotNet.Pdb.PdbDocument"/>s if <paramref name="returnDocs"/> is <c>true</c>
            or <c>null</c> if <paramref name="returnDocs"/> is <c>false</c>.</returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Portable.ImportScopeBlobReader.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.MD.BlobStream)">
            <summary>
            Constructor
            </summary>
            <param name="module">Module that resolves assembly and type references</param>
            <param name="blobStream">Portable PDB blob stream</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.SequencePoint">
            <summary>
            PDB sequence point
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.SequencePoint.Document">
            <summary>
            PDB document
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.SequencePoint.StartLine">
            <summary>
            Start line
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.SequencePoint.StartColumn">
            <summary>
            Start column
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.SequencePoint.EndLine">
            <summary>
            End line
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.SequencePoint.EndColumn">
            <summary>
            End column
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.SequencePoint.Clone">
            <summary>
            Clones this instance
            </summary>
            <returns>A new cloned instance</returns>
        </member>
        <member name="T:dnlib.DotNet.Pdb.Symbols.SymbolAsyncStepInfo">
            <summary>
            Async step info
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.Symbols.SymbolAsyncStepInfo.YieldOffset">
            <summary>
            Yield offset
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.Symbols.SymbolAsyncStepInfo.BreakpointOffset">
            <summary>
            Breakpoint offset
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.Symbols.SymbolAsyncStepInfo.BreakpointMethod">
            <summary>
            Breakpoint method token
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Symbols.SymbolAsyncStepInfo.#ctor(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="yieldOffset">Yield offset</param>
            <param name="breakpointOffset">Breakpoint offset</param>
            <param name="breakpointMethod">Breakpoint method token</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.Symbols.SymbolDocument">
            <summary>
            A document
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolDocument.URL">
            <summary>
            Gets the URL
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolDocument.Language">
            <summary>
            Gets the language
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolDocument.LanguageVendor">
            <summary>
            Gets the language vendor
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolDocument.DocumentType">
            <summary>
            Gets the document type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolDocument.CheckSumAlgorithmId">
            <summary>
            Gets the checksum algorithm id
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolDocument.CheckSum">
            <summary>
            Gets the checksum
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolDocument.CustomDebugInfos">
            <summary>
            Gets the custom debug infos
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.Symbols.SymbolMethod">
            <summary>
            A method
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolMethod.Token">
            <summary>
            Gets the method token
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolMethod.RootScope">
            <summary>
            Gets the root scope
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolMethod.SequencePoints">
            <summary>
            Gets all sequence points
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Symbols.SymbolMethod.GetCustomDebugInfos(dnlib.DotNet.MethodDef,dnlib.DotNet.Emit.CilBody,System.Collections.Generic.IList{dnlib.DotNet.Pdb.PdbCustomDebugInfo})">
            <summary>
            Reads custom debug info
            </summary>
            <param name="method">Method</param>
            <param name="body">Method body</param>
            <param name="result">Updated with custom debug info</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.Symbols.SymbolNamespace">
            <summary>
            A namespace
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolNamespace.Name">
            <summary>
            Gets the name
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.Symbols.SymbolReader">
            <summary>
            Reads symbols from a PDB file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Symbols.SymbolReader.Initialize(dnlib.DotNet.ModuleDef)">
            <summary>
            Called by the owner module before any other methods and properties are called
            </summary>
            <param name="module">Owner module</param>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolReader.PdbFileKind">
            <summary>
            Gets the PDB file kind
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolReader.UserEntryPoint">
            <summary>
            Gets the user entry point token or 0 if none
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolReader.Documents">
            <summary>
            Gets all documents
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Symbols.SymbolReader.GetMethod(dnlib.DotNet.MethodDef,System.Int32)">
            <summary>
            Gets a method or returns null if the method doesn't exist in the PDB file
            </summary>
            <param name="method">Method</param>
            <param name="version">Edit and continue version. The first version is 1</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Symbols.SymbolReader.GetCustomDebugInfos(System.Int32,dnlib.DotNet.GenericParamContext,System.Collections.Generic.IList{dnlib.DotNet.Pdb.PdbCustomDebugInfo})">
            <summary>
            Reads custom debug info
            </summary>
            <param name="token">Token of a <see cref="T:dnlib.DotNet.IHasCustomDebugInformation"/> instance</param>
            <param name="gpContext">Generic parameter context</param>
            <param name="result">Updated with custom debug info</param>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Symbols.SymbolReader.Dispose">
            <summary>
            Cleans up resources
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.Symbols.SymbolScope">
            <summary>
            A scope
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolScope.Method">
            <summary>
            Gets the method
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolScope.Parent">
            <summary>
            Gets the parent scope
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolScope.StartOffset">
            <summary>
            Gets the start offset of the scope in the method
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolScope.EndOffset">
            <summary>
            Gets the end offset of the scope in the method
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolScope.Children">
            <summary>
            Gets all child scopes
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolScope.Locals">
            <summary>
            Gets all locals defined in this scope
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolScope.Namespaces">
            <summary>
            Gets all namespaces in this scope
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolScope.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolScope.ImportScope">
            <summary>
            Gets the import scope or null if none
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.Symbols.SymbolScope.GetConstants(dnlib.DotNet.ModuleDef,dnlib.DotNet.GenericParamContext)">
            <summary>
            Gets all the constants
            </summary>
            <param name="module">Owner module if a signature must be read from the #Blob</param>
            <param name="gpContext">Generic parameter context</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.Pdb.Symbols.SymbolSequencePoint">
            <summary>
            Sequence point
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.Symbols.SymbolSequencePoint.Offset">
            <summary>
            IL offset
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.Symbols.SymbolSequencePoint.Document">
            <summary>
            Document
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.Symbols.SymbolSequencePoint.Line">
            <summary>
            Start line
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.Symbols.SymbolSequencePoint.Column">
            <summary>
            Start column
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.Symbols.SymbolSequencePoint.EndLine">
            <summary>
            End line
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Pdb.Symbols.SymbolSequencePoint.EndColumn">
            <summary>
            End column
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.Symbols.SymbolVariable">
            <summary>
            A variable
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolVariable.Name">
            <summary>
            Gets the name
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolVariable.Attributes">
            <summary>
            Gets the attributes
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolVariable.Index">
            <summary>
            Gets the index of the variable
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Pdb.Symbols.SymbolVariable.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Pdb.WindowsPdb.PdbCustomDebugInfoReader">
            <summary>
            Reads custom debug infos produced by the C# and Visual Basic compilers. They're stored in PDB files
            as PDB method custom attributes with the name "MD2".
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.WindowsPdb.PdbCustomDebugInfoReader.Read(dnlib.DotNet.MethodDef,dnlib.DotNet.Emit.CilBody,System.Collections.Generic.IList{dnlib.DotNet.Pdb.PdbCustomDebugInfo},System.Byte[])">
            <summary>
            Reads custom debug info
            </summary>
            <param name="method">Method</param>
            <param name="body">The method's body. Needs to be provided by the caller since we're called from
            PDB-init code when the Body property hasn't been initialized yet</param>
            <param name="result">Place all custom debug info in this list</param>
            <param name="data">Custom debug info from the PDB file</param>
        </member>
        <member name="T:dnlib.DotNet.Pdb.WindowsPdb.PdbCustomDebugInfoWriter">
            <summary>
            Writes custom debug infos produced by the C# and Visual Basic compilers. They're stored in PDB files
            as PDB method custom attributes with the name "MD2".
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Pdb.WindowsPdb.PdbCustomDebugInfoWriter.Write(dnlib.DotNet.Writer.Metadata,dnlib.DotNet.MethodDef,dnlib.DotNet.Pdb.WindowsPdb.PdbCustomDebugInfoWriterContext,System.Collections.Generic.IList{dnlib.DotNet.Pdb.PdbCustomDebugInfo})">
            <summary>
            Returns the raw custom debug info or null if there was an error
            </summary>
            <param name="metadata">Metadata</param>
            <param name="context">Writer context</param>
            <param name="method">Method</param>
            <param name="customDebugInfos">Custom debug infos to write</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Pdb.WindowsPdb.WindowsPdbWriter.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.PInvokeAttributes">
            <summary>
            P/Invoke attributes, see CorHdr.h/CorPinvokeMap
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.NoMangle">
            <summary>Pinvoke is to use the member name as specified.</summary>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.CharSetMask">
            <summary>Use this mask to retrieve the CharSet information.</summary>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.CharSetNotSpec">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.CharSetAnsi">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.CharSetUnicode">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.CharSetAuto">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.BestFitUseAssem">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.BestFitEnabled">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.BestFitDisabled">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.BestFitMask">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.ThrowOnUnmappableCharUseAssem">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.ThrowOnUnmappableCharEnabled">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.ThrowOnUnmappableCharDisabled">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.ThrowOnUnmappableCharMask">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.SupportsLastError">
            <summary>Information about target function. Not relevant for fields.</summary>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.CallConvMask">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.CallConvWinapi">
            <summary>Pinvoke will use native callconv appropriate to target windows platform.</summary>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.CallConvCdecl">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.CallConvStdcall">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.CallConvStdCall">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.CallConvThiscall">
            <summary>In M9, pinvoke will raise exception.</summary>
        </member>
        <member name="F:dnlib.DotNet.PInvokeAttributes.CallConvFastcall">
            <summary/>
        </member>
        <member name="T:dnlib.DotNet.PropertyAttributes">
            <summary>
            Property attributes, see CorHdr.h/CorPropertyAttr
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyAttributes.SpecialName">
            <summary>property is special.  Name describes how.</summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyAttributes.RTSpecialName">
            <summary>Runtime(metadata internal APIs) should check name encoding.</summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyAttributes.HasDefault">
            <summary>Property has default</summary>
        </member>
        <member name="T:dnlib.DotNet.PropertyDef">
            <summary>
            A high-level representation of a row in the Property table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyDef.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.HasConstantTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.HasSemanticTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.Attributes">
            <summary>
            From column Property.PropFlags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyDef.attributes">
            <summary>Attributes</summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.Name">
            <summary>
            From column Property.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyDef.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.Type">
            <summary>
            From column Property.Type
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyDef.type">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.Constant">
            <inheritdoc/>
        </member>
        <member name="F:dnlib.DotNet.PropertyDef.constant">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PropertyDef.constant_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.PropertyDef.GetConstant_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.PropertyDef.constant"/></summary>
        </member>
        <member name="M:dnlib.DotNet.PropertyDef.ResetConstant">
            <summary>Reset <see cref="P:dnlib.DotNet.PropertyDef.Constant"/></summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyDef.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.PropertyDef.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.PropertyDef.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyDef.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.PropertyDef.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.PropertyDef.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.GetMethod">
            <summary>
            Gets/sets the first getter method. Writing <c>null</c> will clear all get methods.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.SetMethod">
            <summary>
            Gets/sets the first setter method. Writing <c>null</c> will clear all set methods.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.GetMethods">
            <summary>
            Gets all getter methods
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.SetMethods">
            <summary>
            Gets all setter methods
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.OtherMethods">
            <summary>
            Gets the other methods
            </summary>
        </member>
        <member name="M:dnlib.DotNet.PropertyDef.InitializePropertyMethods_NoLock">
            <summary>
            Initializes <see cref="F:dnlib.DotNet.PropertyDef.otherMethods"/>, <see cref="F:dnlib.DotNet.PropertyDef.getMethods"/>,
            and <see cref="F:dnlib.DotNet.PropertyDef.setMethods"/>.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyDef.getMethods">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PropertyDef.setMethods">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.PropertyDef.otherMethods">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.PropertyDef.ResetMethods">
            <summary>Reset <see cref="P:dnlib.DotNet.PropertyDef.GetMethods"/>, <see cref="P:dnlib.DotNet.PropertyDef.SetMethods"/>, <see cref="P:dnlib.DotNet.PropertyDef.OtherMethods"/></summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.IsEmpty">
            <summary>
            <c>true</c> if there are no methods attached to this property
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.HasOtherMethods">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.PropertyDef.OtherMethods"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.HasConstant">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.PropertyDef.Constant"/> is not <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.ElementType">
            <summary>
            Gets the constant element type or <see cref="F:dnlib.DotNet.ElementType.End"/> if there's no constant
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.PropertySig">
            <summary>
            Gets/sets the property sig
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.DeclaringType">
            <summary>
            Gets/sets the declaring type (owner type)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.dnlib#DotNet#IMemberRef#DeclaringType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.DeclaringType2">
            <summary>
            Called by <see cref="P:dnlib.DotNet.PropertyDef.DeclaringType"/> and should normally not be called by any user
            code. Use <see cref="P:dnlib.DotNet.PropertyDef.DeclaringType"/> instead. Only call this if you must set the
            declaring type without inserting it in the declaring type's method list.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyDef.declaringType2">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.FullName">
            <summary>
            Gets the full name of the property
            </summary>
        </member>
        <member name="M:dnlib.DotNet.PropertyDef.ModifyAttributes(System.Boolean,dnlib.DotNet.PropertyAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.PropertyDef.attributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.IsSpecialName">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.PropertyAttributes.SpecialName"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.IsRuntimeSpecialName">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.PropertyAttributes.RTSpecialName"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDef.HasDefault">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.PropertyAttributes.HasDefault"/> bit
            </summary>
        </member>
        <member name="M:dnlib.DotNet.PropertyDef.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.PropertyDefUser">
            <summary>
            A Property row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.PropertyDefUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.PropertyDefUser.#ctor(dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:dnlib.DotNet.PropertyDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.PropertySig)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
            <param name="sig">Property signature</param>
        </member>
        <member name="M:dnlib.DotNet.PropertyDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.PropertySig,dnlib.DotNet.PropertyAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
            <param name="sig">Property signature</param>
            <param name="flags">Flags</param>
        </member>
        <member name="T:dnlib.DotNet.PropertyDefMD">
            <summary>
            Created from a row in the Property table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyDefMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.PropertyDefMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.PropertyDefMD.GetConstant_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.PropertyDefMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.PropertyDefMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.PropertyDefMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>Property</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.PropertyDefMD.InitializePropertyMethods_NoLock">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.PublicKey">
            <summary>
            Represents a public key
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PublicKey.Token">
            <summary>
            Gets the <see cref="T:dnlib.DotNet.PublicKeyToken"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PublicKey.Data">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.PublicKey.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.PublicKey.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="data">Public key data</param>
        </member>
        <member name="M:dnlib.DotNet.PublicKey.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="hexString">Public key data as a hex string or the string <c>"null"</c>
            to set public key data to <c>null</c></param>
        </member>
        <member name="M:dnlib.DotNet.PublicKey.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.PublicKey.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.PublicKeyBase">
            <summary>
            Public key / public key token base class
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PublicKeyBase.data">
            <summary>
            The key data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PublicKeyBase.IsNullOrEmpty">
            <summary>
            Returns <c>true</c> if <see cref="P:dnlib.DotNet.PublicKeyBase.Data"/> is <c>null</c> or empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PublicKeyBase.IsNull">
            <summary>
            Returns <c>true</c> if <see cref="P:dnlib.DotNet.PublicKeyBase.Data"/> is <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PublicKeyBase.Data">
            <summary>
            Gets/sets key data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PublicKeyBase.Token">
            <summary>
            Gets the <see cref="T:dnlib.DotNet.PublicKeyToken"/>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="data">Key data</param>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="hexString">Key data as a hex string or the string <c>"null"</c>
            to set key data to <c>null</c></param>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.IsNullOrEmpty2(dnlib.DotNet.PublicKeyBase)">
            <summary>
            Checks whether a public key or token is null or empty
            </summary>
            <param name="a">Public key or token instance</param>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.ToPublicKeyToken(dnlib.DotNet.PublicKeyBase)">
            <summary>
            Returns a <see cref="T:dnlib.DotNet.PublicKeyToken"/>
            </summary>
            <param name="pkb">A <see cref="T:dnlib.DotNet.PublicKey"/> or a <see cref="T:dnlib.DotNet.PublicKeyToken"/> instance</param>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.TokenCompareTo(dnlib.DotNet.PublicKeyBase,dnlib.DotNet.PublicKeyBase)">
            <summary>
            Compares two <see cref="T:dnlib.DotNet.PublicKeyBase"/>s as <see cref="T:dnlib.DotNet.PublicKeyToken"/>s
            </summary>
            <param name="a">First</param>
            <param name="b">Second</param>
            <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.TokenEquals(dnlib.DotNet.PublicKeyBase,dnlib.DotNet.PublicKeyBase)">
            <summary>
            Checks whether two public key tokens are equal
            </summary>
            <param name="a">First</param>
            <param name="b">Second</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.TokenCompareTo(dnlib.DotNet.PublicKeyToken,dnlib.DotNet.PublicKeyToken)">
            <summary>
            Compares two <see cref="T:dnlib.DotNet.PublicKeyToken"/>s
            </summary>
            <param name="a">First</param>
            <param name="b">Second</param>
            <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.TokenEquals(dnlib.DotNet.PublicKeyToken,dnlib.DotNet.PublicKeyToken)">
            <summary>
            Checks whether two public key tokens are equal
            </summary>
            <param name="a">First</param>
            <param name="b">Second</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.GetHashCodeToken(dnlib.DotNet.PublicKeyBase)">
            <summary>
            Gets the public key token hash code
            </summary>
            <param name="a">Public key or token</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.GetHashCode(dnlib.DotNet.PublicKeyToken)">
            <summary>
            Gets the public key token hash code
            </summary>
            <param name="a">Public key token</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.CreatePublicKey(System.Byte[])">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.PublicKey"/>
            </summary>
            <param name="data">Public key data or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.PublicKey"/> instance or <c>null</c> if <paramref name="data"/>
            was <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.CreatePublicKeyToken(System.Byte[])">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.PublicKeyToken"/>
            </summary>
            <param name="data">Public key token data or <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.PublicKeyToken"/> instance or <c>null</c> if <paramref name="data"/>
            was <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.GetRawData(dnlib.DotNet.PublicKeyBase)">
            <summary>
            Gets the raw public key / public key token byte array
            </summary>
            <param name="pkb">The instance or <c>null</c></param>
            <returns>Raw public key / public key token data or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.PublicKeyToken">
            <summary>
            Represents a public key token
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PublicKeyToken.Token">
            <summary>
            Gets the <see cref="T:dnlib.DotNet.PublicKeyToken"/>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyToken.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyToken.#ctor(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyToken.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyToken.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.PublicKeyToken.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.RecursionCounter">
            <summary>
            Recursion counter
            </summary>
        </member>
        <member name="F:dnlib.DotNet.RecursionCounter.MAX_RECURSION_COUNT">
            <summary>
            Max recursion count. If this is reached, we won't continue, and will use a default value.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.RecursionCounter.Counter">
            <summary>
            Gets the recursion counter
            </summary>
        </member>
        <member name="M:dnlib.DotNet.RecursionCounter.Increment">
            <summary>
            Increments <see cref="F:dnlib.DotNet.RecursionCounter.counter"/> if it's not too high. <c>ALL</c> instance methods
            that can be called recursively must call this method and <see cref="M:dnlib.DotNet.RecursionCounter.Decrement"/>
            (if this method returns <c>true</c>)
            </summary>
            <returns><c>true</c> if it was incremented and caller can continue, <c>false</c> if
            it was <c>not</c> incremented and the caller must return to its caller.</returns>
        </member>
        <member name="M:dnlib.DotNet.RecursionCounter.Decrement">
            <summary>
            Must be called before returning to caller if <see cref="M:dnlib.DotNet.RecursionCounter.Increment"/>
            returned <c>true</c>.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.RecursionCounter.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.ReflectionExtensions">
            <summary>
            Extension methods for reflection types, methods, fields
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ReflectionExtensions.IsSZArray(System.Type)">
            <summary>
            Checks whether it's a <see cref="F:dnlib.DotNet.ElementType.SZArray"/>
            </summary>
            <param name="self">The type</param>
        </member>
        <member name="M:dnlib.DotNet.ReflectionExtensions.GetElementType2(System.Type)">
            <summary>
            Gets a <see cref="T:System.Type"/>'s <see cref="T:dnlib.DotNet.ElementType"/>
            </summary>
            <param name="a">The type</param>
            <returns>The type's element type</returns>
        </member>
        <member name="M:dnlib.DotNet.ReflectionExtensions.IsGenericButNotGenericMethodDefinition(System.Reflection.MethodBase)">
            <summary>
            Returns <c>true</c> if <paramref name="mb"/> is a generic method, but
            not a generic method definition, i.e., a MethodSpec.
            </summary>
            <param name="mb">The method</param>
        </member>
        <member name="M:dnlib.DotNet.ReflectionExtensions.MustTreatTypeAsGenericInstType(System.Type,System.Type)">
            <summary>
            Checks whether a parameter/prop/event type should be treated as if it is really a
            generic instance type and not a generic type definition. In the .NET metadata (method
            sig), the parameter is a generic instance type, but the CLR treats it as if it's just
            a generic type def. This seems to happen only if the parameter type is exactly the same
            type as the declaring type, eg. a method similar to: <c>MyType&lt;!0&gt; MyType::SomeMethod()</c>.
            </summary>
            <param name="declaringType">Declaring type of method/event/property</param>
            <param name="t">Parameter/property/event type</param>
        </member>
        <member name="M:dnlib.DotNet.ReflectionExtensions.IsTypeDef(System.Type)">
            <summary>
            Checks whether <paramref name="type"/> is a type definition and not a type spec
            (eg. pointer or generic type instantiation)
            </summary>
            <param name="type">this</param>
        </member>
        <member name="T:dnlib.DotNet.ResolveException">
            <summary>
            Resolve exception base class
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ResolveException.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ResolveException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Exception message</param>
        </member>
        <member name="M:dnlib.DotNet.ResolveException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Exception message</param>
            <param name="innerException">Inner exception or <c>null</c> if none</param>
        </member>
        <member name="M:dnlib.DotNet.ResolveException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:dnlib.DotNet.AssemblyResolveException">
            <summary>
            Thrown if an assembly couldn't be resolved
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolveException.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolveException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Exception message</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolveException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Exception message</param>
            <param name="innerException">Inner exception or <c>null</c> if none</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyResolveException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:dnlib.DotNet.TypeResolveException">
            <summary>
            Thrown if a type couldn't be resolved
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeResolveException.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeResolveException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Exception message</param>
        </member>
        <member name="M:dnlib.DotNet.TypeResolveException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Exception message</param>
            <param name="innerException">Inner exception or <c>null</c> if none</param>
        </member>
        <member name="M:dnlib.DotNet.TypeResolveException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:dnlib.DotNet.MemberRefResolveException">
            <summary>
            Thrown if a method/field couldn't be resolved
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MemberRefResolveException.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MemberRefResolveException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Exception message</param>
        </member>
        <member name="M:dnlib.DotNet.MemberRefResolveException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Exception message</param>
            <param name="innerException">Inner exception or <c>null</c> if none</param>
        </member>
        <member name="M:dnlib.DotNet.MemberRefResolveException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:dnlib.DotNet.Resolver">
            <summary>
            Resolves types, methods, fields
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resolver.ProjectWinMDRefs">
            <summary>
            <c>true</c> to project WinMD types to CLR types, eg. <c>Windows.UI.Xaml.Interop.TypeName</c>
            gets converted to <c>System.Type</c> before trying to resolve the type. This is enabled
            by default.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Resolver.#ctor(dnlib.DotNet.IAssemblyResolver)">
            <summary>
            Constructor
            </summary>
            <param name="assemblyResolver">The assembly resolver</param>
        </member>
        <member name="M:dnlib.DotNet.Resolver.Resolve(dnlib.DotNet.TypeRef,dnlib.DotNet.ModuleDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Resolver.Resolve(dnlib.DotNet.MemberRef)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.ResourceType">
            <summary>
            Type of resource
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ResourceType.Embedded">
            <summary>
            It's a <see cref="T:dnlib.DotNet.EmbeddedResource"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ResourceType.AssemblyLinked">
            <summary>
            It's a <see cref="T:dnlib.DotNet.AssemblyLinkedResource"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ResourceType.Linked">
            <summary>
            It's a <see cref="T:dnlib.DotNet.LinkedResource"/>
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Resource">
            <summary>
            Resource base class
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resource.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Resource.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Resource.Offset">
            <summary>
            Gets/sets the offset of the resource
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resource.Name">
            <summary>
            Gets/sets the name
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resource.Attributes">
            <summary>
            Gets/sets the flags
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resource.ResourceType">
            <summary>
            Gets the type of resource
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resource.Visibility">
            <summary>
            Gets/sets the visibility
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resource.IsPublic">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.ManifestResourceAttributes.Public"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resource.IsPrivate">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.ManifestResourceAttributes.Private"/> is set
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Resource.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.ManifestResourceAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
            <param name="flags">flags</param>
        </member>
        <member name="T:dnlib.DotNet.EmbeddedResource">
            <summary>
            A resource that is embedded in a .NET module. This is the most common type of resource.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.EmbeddedResource.Length">
            <summary>
            Gets the length of the data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.EmbeddedResource.ResourceType">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.EmbeddedResource.#ctor(dnlib.DotNet.UTF8String,System.Byte[],dnlib.DotNet.ManifestResourceAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name of resource</param>
            <param name="data">Resource data</param>
            <param name="flags">Resource flags</param>
        </member>
        <member name="M:dnlib.DotNet.EmbeddedResource.#ctor(dnlib.DotNet.UTF8String,dnlib.IO.DataReaderFactory,System.UInt32,System.UInt32,dnlib.DotNet.ManifestResourceAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name of resource</param>
            <param name="dataReaderFactory">Data reader factory</param>
            <param name="offset">Offset of resource data</param>
            <param name="length">Length of resource data</param>
            <param name="flags">Resource flags</param>
        </member>
        <member name="M:dnlib.DotNet.EmbeddedResource.CreateReader">
            <summary>
            Gets a data reader that can access the resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.EmbeddedResource.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.AssemblyLinkedResource">
            <summary>
            A reference to a resource in another assembly
            </summary>
        </member>
        <member name="P:dnlib.DotNet.AssemblyLinkedResource.ResourceType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.AssemblyLinkedResource.Assembly">
            <summary>
            Gets/sets the assembly reference
            </summary>
        </member>
        <member name="M:dnlib.DotNet.AssemblyLinkedResource.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.AssemblyRef,dnlib.DotNet.ManifestResourceAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name of resource</param>
            <param name="asmRef">Assembly reference</param>
            <param name="flags">Resource flags</param>
        </member>
        <member name="M:dnlib.DotNet.AssemblyLinkedResource.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.LinkedResource">
            <summary>
            A resource that is stored in a file on disk
            </summary>
        </member>
        <member name="P:dnlib.DotNet.LinkedResource.ResourceType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.LinkedResource.File">
            <summary>
            Gets/sets the file
            </summary>
        </member>
        <member name="P:dnlib.DotNet.LinkedResource.Hash">
            <summary>
            Gets/sets the hash
            </summary>
        </member>
        <member name="P:dnlib.DotNet.LinkedResource.FileName">
            <summary>
            Gets/sets the file name
            </summary>
        </member>
        <member name="M:dnlib.DotNet.LinkedResource.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.FileDef,dnlib.DotNet.ManifestResourceAttributes)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name of resource</param>
            <param name="file">The file</param>
            <param name="flags">Resource flags</param>
        </member>
        <member name="M:dnlib.DotNet.LinkedResource.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.ResourceCollection">
            <summary>
            A collection of <see cref="T:dnlib.DotNet.Resource"/>s
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ResourceCollection.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ResourceCollection.#ctor(dnlib.Utils.IListListener{dnlib.DotNet.Resource})">
            <summary>
            Constructor
            </summary>
            <param name="listener">List listener</param>
        </member>
        <member name="M:dnlib.DotNet.ResourceCollection.#ctor(System.Int32,System.Object,System.Func{System.Object,System.Int32,dnlib.DotNet.Resource})">
            <summary>
            Constructor
            </summary>
            <param name="length">Initial length of the list</param>
            <param name="context">Context passed to <paramref name="readOriginalValue"/></param>
            <param name="readOriginalValue">Delegate instance that returns original values</param>
        </member>
        <member name="M:dnlib.DotNet.ResourceCollection.IndexOf(dnlib.DotNet.UTF8String)">
            <summary>
            Finds the index of a resource
            </summary>
            <param name="name">Name of resource</param>
            <returns>The index of the <see cref="T:dnlib.DotNet.Resource"/> or <c>-1</c> if none was found</returns>
        </member>
        <member name="M:dnlib.DotNet.ResourceCollection.IndexOfEmbeddedResource(dnlib.DotNet.UTF8String)">
            <summary>
            Finds the index of an embedded resource
            </summary>
            <param name="name">Name of resource</param>
            <returns>The index of the <see cref="T:dnlib.DotNet.EmbeddedResource"/> or <c>-1</c> if none was found</returns>
        </member>
        <member name="M:dnlib.DotNet.ResourceCollection.IndexOfAssemblyLinkedResource(dnlib.DotNet.UTF8String)">
            <summary>
            Finds the index of an assembly linked resource
            </summary>
            <param name="name">Name of resource</param>
            <returns>The index of the <see cref="T:dnlib.DotNet.AssemblyLinkedResource"/> or <c>-1</c> if none was found</returns>
        </member>
        <member name="M:dnlib.DotNet.ResourceCollection.IndexOfLinkedResource(dnlib.DotNet.UTF8String)">
            <summary>
            Finds the index of a linked resource
            </summary>
            <param name="name">Name of resource</param>
            <returns>The index of the <see cref="T:dnlib.DotNet.LinkedResource"/> or <c>-1</c> if none was found</returns>
        </member>
        <member name="M:dnlib.DotNet.ResourceCollection.Find(dnlib.DotNet.UTF8String)">
            <summary>
            Finds a resource
            </summary>
            <param name="name">Name of resource</param>
            <returns>The <see cref="T:dnlib.DotNet.Resource"/> or <c>null</c> if none was found</returns>
        </member>
        <member name="M:dnlib.DotNet.ResourceCollection.FindEmbeddedResource(dnlib.DotNet.UTF8String)">
            <summary>
            Finds an embedded resource
            </summary>
            <param name="name">Name of resource</param>
            <returns>The <see cref="T:dnlib.DotNet.EmbeddedResource"/> or <c>null</c> if none was found</returns>
        </member>
        <member name="M:dnlib.DotNet.ResourceCollection.FindAssemblyLinkedResource(dnlib.DotNet.UTF8String)">
            <summary>
            Finds an assembly linked resource
            </summary>
            <param name="name">Name of resource</param>
            <returns>The <see cref="T:dnlib.DotNet.AssemblyLinkedResource"/> or <c>null</c> if none was found</returns>
        </member>
        <member name="M:dnlib.DotNet.ResourceCollection.FindLinkedResource(dnlib.DotNet.UTF8String)">
            <summary>
            Finds a linked resource
            </summary>
            <param name="name">Name of resource</param>
            <returns>The <see cref="T:dnlib.DotNet.LinkedResource"/> or <c>null</c> if none was found</returns>
        </member>
        <member name="T:dnlib.DotNet.Resources.BuiltInResourceData">
            <summary>
            Built-in resource data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.BuiltInResourceData.Data">
            <summary>
            Gets the data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.BuiltInResourceData.Code">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Resources.BuiltInResourceData.StartOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Resources.BuiltInResourceData.EndOffset">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Resources.BuiltInResourceData.#ctor(dnlib.DotNet.Resources.ResourceTypeCode,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="code">Type of data</param>
            <param name="data">Data</param>
        </member>
        <member name="M:dnlib.DotNet.Resources.BuiltInResourceData.WriteData(System.IO.BinaryWriter,System.Runtime.Serialization.IFormatter)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Resources.BuiltInResourceData.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Resources.IResourceData">
            <summary>
            Implemented by all resource data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.IResourceData.Code">
            <summary>
            Gets the type of data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.IResourceData.StartOffset">
            <summary>
            Start offset of the section in the file
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.IResourceData.EndOffset">
            <summary>
            End offset of the section in the file. This is one byte after the last
            valid offset in the section.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Resources.IResourceData.WriteData(System.IO.BinaryWriter,System.Runtime.Serialization.IFormatter)">
            <summary>
            Writes the data
            </summary>
            <param name="writer">Writer</param>
            <param name="formatter">Formatter if needed by implementer</param>
        </member>
        <member name="T:dnlib.DotNet.Resources.ResourceDataFactory">
            <summary>
            Creates resource data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.ResourceDataFactory.Module">
            <summary>
            Gets the owner module
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.#ctor(dnlib.DotNet.ModuleDef)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
        </member>
        <member name="P:dnlib.DotNet.Resources.ResourceDataFactory.Count">
            <summary>
            Gets number of user data types
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.CreateNull">
            <summary>
            Create null data
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.String)">
            <summary>
            Creates <see cref="T:System.String"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.Boolean)">
            <summary>
            Creates <see cref="T:System.Boolean"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.Char)">
            <summary>
            Creates <see cref="T:System.Char"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.Byte)">
            <summary>
            Creates <see cref="T:System.Byte"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.SByte)">
            <summary>
            Creates <see cref="T:System.SByte"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.Int16)">
            <summary>
            Creates <see cref="T:System.Int16"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.UInt16)">
            <summary>
            Creates <see cref="T:System.UInt16"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.Int32)">
            <summary>
            Creates <see cref="T:System.Int32"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.UInt32)">
            <summary>
            Creates <see cref="T:System.UInt32"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.Int64)">
            <summary>
            Creates <see cref="T:System.Int64"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.UInt64)">
            <summary>
            Creates <see cref="T:System.UInt64"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.Single)">
            <summary>
            Creates <see cref="T:System.Single"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.Double)">
            <summary>
            Creates <see cref="T:System.Double"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.Decimal)">
            <summary>
            Creates <see cref="T:System.Decimal"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.DateTime)">
            <summary>
            Creates <see cref="T:System.DateTime"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.TimeSpan)">
            <summary>
            Creates <see cref="T:System.TimeSpan"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.Create(System.Byte[])">
            <summary>
            Creates <see cref="T:System.Byte"/> array data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.CreateStream(System.Byte[])">
            <summary>
            Creates <see cref="T:System.IO.Stream"/> data
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.CreateSerialized(System.Byte[],dnlib.DotNet.Resources.UserResourceType)">
            <summary>
            Creates serialized data
            </summary>
            <param name="value">Serialized data</param>
            <param name="type">Type of serialized data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.CreateSerialized(System.Byte[])">
            <summary>
            Creates serialized data
            </summary>
            <param name="value">Serialized data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.CreateUserResourceType(System.String)">
            <summary>
            Creates a user type. If the type already exists, the existing value is returned.
            </summary>
            <param name="fullName">Full name of type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.CreateUserResourceType(System.String,System.Boolean)">
            <summary>
            Creates a user type. If the type already exists, the existing value is returned.
            </summary>
            <param name="fullName">Full name of type</param>
            <param name="useFullName">Use <paramref name="fullName"/> without converting it to a
            type in an existing assembly reference</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.GetAssemblyFullName(System.String)">
            <summary>
            Converts an assembly simple name (eg. mscorlib) to the full name of the assembly,
            which includes the version, public key token, etc. Returns <c>null</c> if it's
            unknown.
            </summary>
            <param name="simpleName">Simple name of assembly</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceDataFactory.GetSortedTypes">
            <summary>
            Gets all types sorted by <see cref="T:dnlib.DotNet.Resources.UserResourceType"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.Resources.ResourceElement">
            <summary>
            Resource element
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.ResourceElement.Name">
            <summary>
            Name of resource
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.ResourceElement.ResourceData">
            <summary>
            Data of resource
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceElement.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Resources.ResourceElementSet">
            <summary>
            Resource element set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.ResourceElementSet.Count">
            <summary>
            Gets the number of elements in the set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.ResourceElementSet.ResourceElements">
            <summary>
            Gets all resource elements
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceElementSet.Add(dnlib.DotNet.Resources.ResourceElement)">
            <summary>
            Adds a new resource to the set, overwriting any existing resource
            </summary>
            <param name="elem"></param>
        </member>
        <member name="T:dnlib.DotNet.Resources.ResourceReaderException">
            <summary>
            Thrown by <see cref="T:dnlib.DotNet.Resources.ResourceReader"/>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceReaderException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceReaderException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="msg">Message</param>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceReaderException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:dnlib.DotNet.Resources.CreateResourceDataDelegate">
            <summary>
            Gets called to create a <see cref="T:dnlib.DotNet.Resources.IResourceData"/> from serialized data. Returns <c>null</c>
            if a default <see cref="T:dnlib.DotNet.Resources.IResourceData"/> instance should be created.
            </summary>
            <param name="resourceDataFactory">ResourceDataFactory</param>
            <param name="type">Serialized type</param>
            <param name="serializedData">Serialized data</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.Resources.ResourceReader">
            <summary>
            Reads .NET resources
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceReader.CouldBeResourcesFile(dnlib.IO.DataReader)">
            <summary>
            Returns true if it's possibly resources file data
            </summary>
            <param name="reader">Reader</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceReader.Read(dnlib.DotNet.ModuleDef,dnlib.IO.DataReader)">
            <summary>
            Reads a .NET resource
            </summary>
            <param name="module">Owner module</param>
            <param name="reader">Data of resource</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceReader.Read(dnlib.DotNet.ModuleDef,dnlib.IO.DataReader,dnlib.DotNet.Resources.CreateResourceDataDelegate)">
            <summary>
            Reads a .NET resource
            </summary>
            <param name="module">Owner module</param>
            <param name="reader">Data of resource</param>
            <param name="createResourceDataDelegate">Call back that gets called to create a <see cref="T:dnlib.DotNet.Resources.IResourceData"/> instance. Can be null.</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.Resources.ResourceTypeCode">
            <summary>
            Type of resource
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.Null">
            <summary>
            null
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.String">
            <summary>
            <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.Boolean">
            <summary>
            <see cref="T:System.Boolean"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.Char">
            <summary>
            <see cref="T:System.Char"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.Byte">
            <summary>
            <see cref="T:System.Byte"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.SByte">
            <summary>
            <see cref="T:System.SByte"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.Int16">
            <summary>
            <see cref="T:System.Int16"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.UInt16">
            <summary>
            <see cref="T:System.UInt16"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.Int32">
            <summary>
            <see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.UInt32">
            <summary>
            <see cref="T:System.UInt32"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.Int64">
            <summary>
            <see cref="T:System.Int64"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.UInt64">
            <summary>
            <see cref="T:System.UInt64"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.Single">
            <summary>
            <see cref="T:System.Single"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.Double">
            <summary>
            <see cref="T:System.Double"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.Decimal">
            <summary>
            <see cref="T:System.Decimal"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.DateTime">
            <summary>
            <see cref="F:dnlib.DotNet.Resources.ResourceTypeCode.DateTime"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.TimeSpan">
            <summary>
            <see cref="F:dnlib.DotNet.Resources.ResourceTypeCode.TimeSpan"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.ByteArray">
            <summary>
            <see cref="T:System.Byte"/> array
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.Stream">
            <summary>
            <see cref="F:dnlib.DotNet.Resources.ResourceTypeCode.Stream"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Resources.ResourceTypeCode.UserTypes">
            <summary>
            Start of user types
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Resources.ResourceWriter">
            <summary>
            Writes .NET resources
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Resources.ResourceWriter.Write(dnlib.DotNet.ModuleDef,System.IO.Stream,dnlib.DotNet.Resources.ResourceElementSet)">
            <summary>
            Write .NET resources
            </summary>
            <param name="module">Owner module</param>
            <param name="stream">Output stream</param>
            <param name="resources">.NET resources</param>
        </member>
        <member name="T:dnlib.DotNet.Resources.UserResourceData">
            <summary>
            Base class of all user data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.UserResourceData.TypeName">
            <summary>
            Full name including assembly of type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.UserResourceData.Code">
            <summary>
            User type code
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.UserResourceData.StartOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Resources.UserResourceData.EndOffset">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Resources.UserResourceData.#ctor(dnlib.DotNet.Resources.UserResourceType)">
            <summary>
            Constructor
            </summary>
            <param name="type">User resource type</param>
        </member>
        <member name="M:dnlib.DotNet.Resources.UserResourceData.WriteData(System.IO.BinaryWriter,System.Runtime.Serialization.IFormatter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Resources.BinaryResourceData">
            <summary>
            Binary data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.BinaryResourceData.Data">
            <summary>
            Gets the raw data
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Resources.BinaryResourceData.#ctor(dnlib.DotNet.Resources.UserResourceType,System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="type">User resource type</param>
            <param name="data">Raw serialized data</param>
        </member>
        <member name="M:dnlib.DotNet.Resources.BinaryResourceData.WriteData(System.IO.BinaryWriter,System.Runtime.Serialization.IFormatter)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Resources.BinaryResourceData.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Resources.UserResourceType">
            <summary>
            User resource type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.UserResourceType.Name">
            <summary>
            Full name including assembly of type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Resources.UserResourceType.Code">
            <summary>
            User type code
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Resources.UserResourceType.#ctor(System.String,dnlib.DotNet.Resources.ResourceTypeCode)">
            <summary>
            Constructor
            </summary>
            <param name="name">Full name including assembly of type</param>
            <param name="code">User type code</param>
        </member>
        <member name="M:dnlib.DotNet.Resources.UserResourceType.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.SecurityAction">
            <summary>
            Security action. See CorHdr.h/CorDeclSecurity
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.ActionMask">
            <summary>Mask allows growth of enum.</summary>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.ActionNil">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.Request">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.Demand">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.Assert">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.Deny">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.PermitOnly">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.LinktimeCheck">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.LinkDemand">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.InheritanceCheck">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.InheritDemand">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.RequestMinimum">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.RequestOptional">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.RequestRefuse">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.PrejitGrant">
            <summary>Persisted grant set at prejit time</summary>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.PreJitGrant">
            <summary>Persisted grant set at prejit time</summary>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.PrejitDenied">
            <summary>Persisted denied set at prejit time</summary>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.PreJitDeny">
            <summary>Persisted denied set at prejit time</summary>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.NonCasDemand">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.NonCasLinkDemand">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.NonCasInheritance">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SecurityAction.MaximumValue">
            <summary>Maximum legal value</summary>
        </member>
        <member name="T:dnlib.DotNet.SecurityAttribute">
            <summary>
            A <c>DeclSecurity</c> security attribute
            </summary>
        </member>
        <member name="P:dnlib.DotNet.SecurityAttribute.AttributeType">
            <summary>
            Gets/sets the attribute type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.SecurityAttribute.TypeFullName">
            <summary>
            Gets the full name of the attribute type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.SecurityAttribute.NamedArguments">
            <summary>
            Gets all named arguments (field and property values)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.SecurityAttribute.HasNamedArguments">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.SecurityAttribute.NamedArguments"/> is not empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.SecurityAttribute.Fields">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.CANamedArgument"/>s that are field arguments
            </summary>
        </member>
        <member name="P:dnlib.DotNet.SecurityAttribute.Properties">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.CANamedArgument"/>s that are property arguments
            </summary>
        </member>
        <member name="M:dnlib.DotNet.SecurityAttribute.CreateFromXml(dnlib.DotNet.ModuleDef,System.String)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.SecurityAttribute"/> from an XML string.
            </summary>
            <param name="module">Owner module</param>
            <param name="xml">XML</param>
            <returns>A new <see cref="T:dnlib.DotNet.SecurityAttribute"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.SecurityAttribute.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.SecurityAttribute.#ctor(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="attrType">Attribute type</param>
        </member>
        <member name="M:dnlib.DotNet.SecurityAttribute.#ctor(dnlib.DotNet.ITypeDefOrRef,System.Collections.Generic.IList{dnlib.DotNet.CANamedArgument})">
            <summary>
            Constructor
            </summary>
            <param name="attrType">Attribute type</param>
            <param name="namedArguments">Named arguments that will be owned by this instance</param>
        </member>
        <member name="M:dnlib.DotNet.SecurityAttribute.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.SerializationType">
            <summary>
            See CorSerializationType/CorHdr.h
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.Undefined">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.Boolean">
            <summary>System.Boolean</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.Char">
            <summary>System.Char</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.I1">
            <summary>System.SByte</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.U1">
            <summary>System.Byte</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.I2">
            <summary>System.Int16</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.U2">
            <summary>System.UInt16</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.I4">
            <summary>System.Int32</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.U4">
            <summary>System.UInt32</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.I8">
            <summary>System.Int64</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.U8">
            <summary>System.UInt64</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.R4">
            <summary>System.Single</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.R8">
            <summary>System.Double</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.String">
            <summary>System.String</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.SZArray">
            <summary>Single-dimension, zero lower bound array ([])</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.Type">
            <summary>System.Type</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.TaggedObject">
            <summary>Boxed value type</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.Field">
            <summary>A field</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.Property">
            <summary>A property</summary>
        </member>
        <member name="F:dnlib.DotNet.SerializationType.Enum">
            <summary>An enum</summary>
        </member>
        <member name="T:dnlib.DotNet.TypeEqualityComparer">
            <summary>
            Compares types
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeEqualityComparer.Instance">
            <summary>
            Default instance
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeEqualityComparer.CaseInsensitive">
            <summary>
            Case insensitive names
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.#ctor(dnlib.DotNet.SigComparerOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Comparison options</param>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.Equals(dnlib.DotNet.IType,dnlib.DotNet.IType)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.GetHashCode(dnlib.DotNet.IType)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.Equals(dnlib.DotNet.ITypeDefOrRef,dnlib.DotNet.ITypeDefOrRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.GetHashCode(dnlib.DotNet.ITypeDefOrRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.Equals(dnlib.DotNet.TypeRef,dnlib.DotNet.TypeRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.GetHashCode(dnlib.DotNet.TypeRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.Equals(dnlib.DotNet.TypeDef,dnlib.DotNet.TypeDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.GetHashCode(dnlib.DotNet.TypeDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.Equals(dnlib.DotNet.TypeSpec,dnlib.DotNet.TypeSpec)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.GetHashCode(dnlib.DotNet.TypeSpec)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.Equals(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.GetHashCode(dnlib.DotNet.TypeSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.Equals(dnlib.DotNet.ExportedType,dnlib.DotNet.ExportedType)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeEqualityComparer.GetHashCode(dnlib.DotNet.ExportedType)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.FieldEqualityComparer">
            <summary>
            Compares fields
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldEqualityComparer.CompareDeclaringTypes">
            <summary>
            Compares the declaring types
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldEqualityComparer.DontCompareDeclaringTypes">
            <summary>
            Doesn't compare the declaring types
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldEqualityComparer.CaseInsensitiveCompareDeclaringTypes">
            <summary>
            Compares the declaring types, case insensitive names
            </summary>
        </member>
        <member name="F:dnlib.DotNet.FieldEqualityComparer.CaseInsensitiveDontCompareDeclaringTypes">
            <summary>
            Doesn't compare the declaring types, case insensitive names
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FieldEqualityComparer.#ctor(dnlib.DotNet.SigComparerOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Comparison options</param>
        </member>
        <member name="M:dnlib.DotNet.FieldEqualityComparer.Equals(dnlib.DotNet.IField,dnlib.DotNet.IField)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldEqualityComparer.GetHashCode(dnlib.DotNet.IField)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldEqualityComparer.Equals(dnlib.DotNet.FieldDef,dnlib.DotNet.FieldDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldEqualityComparer.GetHashCode(dnlib.DotNet.FieldDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldEqualityComparer.Equals(dnlib.DotNet.MemberRef,dnlib.DotNet.MemberRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.FieldEqualityComparer.GetHashCode(dnlib.DotNet.MemberRef)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.MethodEqualityComparer">
            <summary>
            Compares methods
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodEqualityComparer.CompareDeclaringTypes">
            <summary>
            Compares the declaring types
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodEqualityComparer.DontCompareDeclaringTypes">
            <summary>
            Doesn't compare the declaring types
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodEqualityComparer.CaseInsensitiveCompareDeclaringTypes">
            <summary>
            Compares the declaring types, case insensitive names
            </summary>
        </member>
        <member name="F:dnlib.DotNet.MethodEqualityComparer.CaseInsensitiveDontCompareDeclaringTypes">
            <summary>
            Doesn't compare the declaring types, case insensitive names
            </summary>
        </member>
        <member name="M:dnlib.DotNet.MethodEqualityComparer.#ctor(dnlib.DotNet.SigComparerOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Comparison options</param>
        </member>
        <member name="M:dnlib.DotNet.MethodEqualityComparer.Equals(dnlib.DotNet.IMethod,dnlib.DotNet.IMethod)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodEqualityComparer.GetHashCode(dnlib.DotNet.IMethod)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodEqualityComparer.Equals(dnlib.DotNet.IMethodDefOrRef,dnlib.DotNet.IMethodDefOrRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodEqualityComparer.GetHashCode(dnlib.DotNet.IMethodDefOrRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodEqualityComparer.Equals(dnlib.DotNet.MethodDef,dnlib.DotNet.MethodDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodEqualityComparer.GetHashCode(dnlib.DotNet.MethodDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodEqualityComparer.Equals(dnlib.DotNet.MemberRef,dnlib.DotNet.MemberRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodEqualityComparer.GetHashCode(dnlib.DotNet.MemberRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodEqualityComparer.Equals(dnlib.DotNet.MethodSpec,dnlib.DotNet.MethodSpec)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.MethodEqualityComparer.GetHashCode(dnlib.DotNet.MethodSpec)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.PropertyEqualityComparer">
            <summary>
            Compares properties
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyEqualityComparer.CompareDeclaringTypes">
            <summary>
            Compares the declaring types
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyEqualityComparer.DontCompareDeclaringTypes">
            <summary>
            Doesn't compare the declaring types
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyEqualityComparer.CaseInsensitiveCompareDeclaringTypes">
            <summary>
            Compares the declaring types, case insensitive names
            </summary>
        </member>
        <member name="F:dnlib.DotNet.PropertyEqualityComparer.CaseInsensitiveDontCompareDeclaringTypes">
            <summary>
            Doesn't compare the declaring types, case insensitive names
            </summary>
        </member>
        <member name="M:dnlib.DotNet.PropertyEqualityComparer.#ctor(dnlib.DotNet.SigComparerOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Comparison options</param>
        </member>
        <member name="M:dnlib.DotNet.PropertyEqualityComparer.Equals(dnlib.DotNet.PropertyDef,dnlib.DotNet.PropertyDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.PropertyEqualityComparer.GetHashCode(dnlib.DotNet.PropertyDef)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.EventEqualityComparer">
            <summary>
            Compares events
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventEqualityComparer.CompareDeclaringTypes">
            <summary>
            Compares the declaring types
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventEqualityComparer.DontCompareDeclaringTypes">
            <summary>
            Doesn't compare the declaring types
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventEqualityComparer.CaseInsensitiveCompareDeclaringTypes">
            <summary>
            Compares the declaring types, case insensitive names
            </summary>
        </member>
        <member name="F:dnlib.DotNet.EventEqualityComparer.CaseInsensitiveDontCompareDeclaringTypes">
            <summary>
            Doesn't compare the declaring types, case insensitive names
            </summary>
        </member>
        <member name="M:dnlib.DotNet.EventEqualityComparer.#ctor(dnlib.DotNet.SigComparerOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Comparison options</param>
        </member>
        <member name="M:dnlib.DotNet.EventEqualityComparer.Equals(dnlib.DotNet.EventDef,dnlib.DotNet.EventDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.EventEqualityComparer.GetHashCode(dnlib.DotNet.EventDef)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.SignatureEqualityComparer">
            <summary>
            Compares calling convention signatures
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SignatureEqualityComparer.Instance">
            <summary>
            Default instance
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SignatureEqualityComparer.CaseInsensitive">
            <summary>
            Case insensitive names
            </summary>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.#ctor(dnlib.DotNet.SigComparerOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Comparison options</param>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.Equals(dnlib.DotNet.CallingConventionSig,dnlib.DotNet.CallingConventionSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.GetHashCode(dnlib.DotNet.CallingConventionSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.Equals(dnlib.DotNet.MethodBaseSig,dnlib.DotNet.MethodBaseSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.GetHashCode(dnlib.DotNet.MethodBaseSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.Equals(dnlib.DotNet.MethodSig,dnlib.DotNet.MethodSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.GetHashCode(dnlib.DotNet.MethodSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.Equals(dnlib.DotNet.PropertySig,dnlib.DotNet.PropertySig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.GetHashCode(dnlib.DotNet.PropertySig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.Equals(dnlib.DotNet.FieldSig,dnlib.DotNet.FieldSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.GetHashCode(dnlib.DotNet.FieldSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.Equals(dnlib.DotNet.LocalSig,dnlib.DotNet.LocalSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.GetHashCode(dnlib.DotNet.LocalSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.Equals(dnlib.DotNet.GenericInstMethodSig,dnlib.DotNet.GenericInstMethodSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SignatureEqualityComparer.GetHashCode(dnlib.DotNet.GenericInstMethodSig)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.SigComparerOptions">
            <summary>
            Decides how to compare types, sigs, etc
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.DontCompareTypeScope">
            <summary>
            Don't compare a type's (assembly/module) scope
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CompareMethodFieldDeclaringType">
            <summary>
            Compares a method/field's declaring type.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.ComparePropertyDeclaringType">
            <summary>
            Compares a property's declaring type
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CompareEventDeclaringType">
            <summary>
            Compares an event's declaring type
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CompareDeclaringTypes">
            <summary>
            Compares method / field / property / event declaring types
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CompareSentinelParams">
            <summary>
            Compares parameters after a sentinel in method sigs. Should not be enabled when
            comparing <see cref="T:dnlib.DotNet.MethodSig"/>s against <see cref="T:System.Reflection.MethodInfo"/>s since it's
            not possible to get those sentinel params from a <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CompareAssemblyPublicKeyToken">
            <summary>
            Compares assembly public key token
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CompareAssemblyVersion">
            <summary>
            Compares assembly version
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CompareAssemblyLocale">
            <summary>
            Compares assembly locale
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.TypeRefCanReferenceGlobalType">
            <summary>
            If set, a <see cref="T:dnlib.DotNet.TypeRef"/> and an <see cref="T:dnlib.DotNet.ExportedType"/> can reference the
            global <c>&lt;Module&gt;</c> type.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.DontCompareReturnType">
            <summary>
            Don't compare a method/property's return type
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CaseInsensitiveTypeNamespaces">
            <summary>
            Type namespaces are case insensitive
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CaseInsensitiveTypeNames">
            <summary>
            Type names (not namespaces) are case insensitive
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CaseInsensitiveTypes">
            <summary>
            Type names and namespaces are case insensitive
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CaseInsensitiveMethodFieldNames">
            <summary>
            Method and field names are case insensitive
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CaseInsensitivePropertyNames">
            <summary>
            Property names are case insensitive
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CaseInsensitiveEventNames">
            <summary>
            Event names are case insensitive
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.CaseInsensitiveAll">
            <summary>
            Type namespaces, type names, method names, field names, property names
            and event names are all case insensitive
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.PrivateScopeFieldIsComparable">
            <summary>
            A field that is <see cref="F:dnlib.DotNet.FieldAttributes.PrivateScope"/> can compare equal to
            a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.PrivateScopeMethodIsComparable">
            <summary>
            A method that is <see cref="F:dnlib.DotNet.MethodAttributes.PrivateScope"/> can compare equal to
            a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.PrivateScopeIsComparable">
            <summary>
            A field that is <see cref="F:dnlib.DotNet.FieldAttributes.PrivateScope"/> and a method that is
            <see cref="F:dnlib.DotNet.MethodAttributes.PrivateScope"/> can compare equal to a <see cref="T:dnlib.DotNet.MemberRef"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.RawSignatureCompare">
            <summary>
            Raw (bit by bit) comparison of signatures. This matches what the CLR does when it
            compares signatures. This means that metadata tokens will be compared.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.IgnoreModifiers">
            <summary>
            Ignore required and optional modifiers when comparing <see cref="T:dnlib.DotNet.TypeSig"/>s.
            They're already ignored when comparing eg. a <see cref="T:dnlib.DotNet.TypeSig"/> with a
            <see cref="T:dnlib.DotNet.TypeRef"/>.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.MscorlibIsNotSpecial">
            <summary>
            By default, all module and assembly compares when they're both the system library
            (eg. mscorlib or System.Runtime.dll) return true, even if they're really different,
            eg. mscorlib (.NET 2.0) vs mscorlib (Windows CE). If this flag is set, the system
            library is compared just like any other module/assembly.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.DontProjectWinMDRefs">
            <summary>
            Don't project CLR compatible WinMD references back to the original CLR type/method before comparing
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.DontCheckTypeEquivalence">
            <summary>
            Don't check type equivalence when comparing types. Starting with .NET 4.0, two different
            types can be considered equivalent if eg. a TypeIdentifierAttribute is used.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SigComparerOptions.IgnoreMultiDimensionalArrayLowerBoundsAndSizes">
            <summary>
            When comparing types, don't compare a multi-dimensional array's lower bounds and sizes
            </summary>
        </member>
        <member name="T:dnlib.DotNet.SigComparer">
            <summary>
            Compares types, signatures, methods, fields, properties, events
            </summary>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.#ctor(dnlib.DotNet.SigComparerOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Comparison options</param>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.#ctor(dnlib.DotNet.SigComparerOptions,dnlib.DotNet.ModuleDef)">
            <summary>
            Constructor
            </summary>
            <param name="options">Comparison options</param>
            <param name="sourceModule">The module which the comparison take place in.</param>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode_FnPtr_SystemIntPtr">
            <summary>
            <see cref="F:dnlib.DotNet.ElementType.FnPtr"/> is mapped to <see cref="T:System.IntPtr"/>, so use
            the same hash code for both
            </summary>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.IMemberRef,dnlib.DotNet.IMemberRef)">
            <summary>
            Compare members
            </summary>
            <param name="a">Member #1</param>
            <param name="b">Member #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.IMemberRef)">
            <summary>
            Gets the hash code of a member
            </summary>
            <param name="a">The member</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.ITypeDefOrRef,dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Gets the hash code of a type
            </summary>
            <param name="a">The type</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.IType,dnlib.DotNet.IType)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.IType)">
            <summary>
            Gets the hash code of a type
            </summary>
            <param name="a">The type</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeRef,dnlib.DotNet.TypeDef)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeDef,dnlib.DotNet.TypeRef)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.ExportedType,dnlib.DotNet.TypeDef)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeDef,dnlib.DotNet.ExportedType)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSpec,dnlib.DotNet.TypeDef)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeDef,dnlib.DotNet.TypeSpec)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeDef)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeDef,dnlib.DotNet.TypeSig)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSpec,dnlib.DotNet.TypeRef)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeRef,dnlib.DotNet.TypeSpec)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.ExportedType,dnlib.DotNet.TypeRef)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeRef,dnlib.DotNet.ExportedType)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeRef)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeRef,dnlib.DotNet.TypeSig)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSpec)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSpec,dnlib.DotNet.TypeSig)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.ExportedType,dnlib.DotNet.TypeSpec)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSpec,dnlib.DotNet.ExportedType)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.ExportedType,dnlib.DotNet.TypeSig)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSig,dnlib.DotNet.ExportedType)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeRef,dnlib.DotNet.TypeRef)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.TypeRef)">
            <summary>
            Gets the hash code of a type
            </summary>
            <param name="a">The type</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.ExportedType,dnlib.DotNet.ExportedType)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.ExportedType)">
            <summary>
            Gets the hash code of a type
            </summary>
            <param name="a">The type</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeDef,dnlib.DotNet.TypeDef)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.TypeDef)">
            <summary>
            Gets the hash code of a type
            </summary>
            <param name="a">The type</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSpec,dnlib.DotNet.TypeSpec)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.TypeSpec)">
            <summary>
            Gets the hash code of a type
            </summary>
            <param name="a">The type</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.EqualsResolutionScope(dnlib.DotNet.TypeRef,dnlib.DotNet.TypeRef)">
            <summary>
            Compares resolution scopes
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.EqualsImplementation(dnlib.DotNet.ExportedType,dnlib.DotNet.ExportedType)">
            <summary>
            Compares implementation
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.EqualsScope(dnlib.DotNet.TypeRef,dnlib.DotNet.ExportedType)">
            <summary>
            Compares resolution scope and implementation
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.FileDef,dnlib.DotNet.FileDef)">
            <summary>
            Compares files
            </summary>
            <param name="a">File #1</param>
            <param name="b">File #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.IModule,dnlib.DotNet.FileDef)">
            <summary>
            Compares a module with a file
            </summary>
            <param name="a">Module</param>
            <param name="b">File</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.IModule,dnlib.DotNet.IModule)">
            <summary>
            Compares modules
            </summary>
            <param name="a">Module #1</param>
            <param name="b">Module #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.ModuleDef,dnlib.DotNet.ModuleDef)">
            <summary>
            Compares modules
            </summary>
            <param name="a">Module #1</param>
            <param name="b">Module #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.IAssembly,dnlib.DotNet.IAssembly)">
            <summary>
            Compares assemblies
            </summary>
            <param name="a">Assembly #1</param>
            <param name="b">Assembly #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.TypeSig)">
            <summary>
            Gets the hash code of a type
            </summary>
            <param name="a">The type</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Collections.Generic.IList{dnlib.DotNet.TypeSig})">
            <summary>
            Compares type lists
            </summary>
            <param name="a">Type list #1</param>
            <param name="b">Type list #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(System.Collections.Generic.IList{dnlib.DotNet.TypeSig})">
            <summary>
            Gets the hash code of a type list
            </summary>
            <param name="a">The type list</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.CallingConventionSig,dnlib.DotNet.CallingConventionSig)">
            <summary>
            Compares signatures
            </summary>
            <param name="a">Sig #1</param>
            <param name="b">Sig #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.CallingConventionSig)">
            <summary>
            Gets the hash code of a sig
            </summary>
            <param name="a">The sig</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.MethodBaseSig,dnlib.DotNet.MethodBaseSig)">
            <summary>
            Compares method/property sigs
            </summary>
            <param name="a">Method/property #1</param>
            <param name="b">Method/property #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.MethodBaseSig)">
            <summary>
            Gets the hash code of a method/property sig
            </summary>
            <param name="a">The method/property sig</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.FieldSig,dnlib.DotNet.FieldSig)">
            <summary>
            Compares field sigs
            </summary>
            <param name="a">Field sig #1</param>
            <param name="b">Field sig #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.FieldSig)">
            <summary>
            Gets the hash code of a field sig
            </summary>
            <param name="a">The field sig</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.LocalSig,dnlib.DotNet.LocalSig)">
            <summary>
            Compares local sigs
            </summary>
            <param name="a">Local sig #1</param>
            <param name="b">Local sig #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.LocalSig)">
            <summary>
            Gets the hash code of a local sig
            </summary>
            <param name="a">The local sig</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.GenericInstMethodSig,dnlib.DotNet.GenericInstMethodSig)">
            <summary>
            Compares generic method instance sigs
            </summary>
            <param name="a">Generic inst method #1</param>
            <param name="b">Generic inst method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.GenericInstMethodSig)">
            <summary>
            Gets the hash code of a generic instance method sig
            </summary>
            <param name="a">The generic inst method sig</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.IMethod,dnlib.DotNet.IMethod)">
            <summary>
            Compares methods
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.IMethod)">
            <summary>
            Gets the hash code of a method
            </summary>
            <param name="a">The method</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.MemberRef,dnlib.DotNet.MethodDef)">
            <summary>
            Compares methods
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.MethodDef,dnlib.DotNet.MemberRef)">
            <summary>
            Compares methods
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.MethodDef,dnlib.DotNet.MethodDef)">
            <summary>
            Compares methods
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.MethodDef)">
            <summary>
            Gets the hash code of a method
            </summary>
            <param name="a">The method</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.MemberRef,dnlib.DotNet.MemberRef)">
            <summary>
            Compares <c>MemberRef</c>s
            </summary>
            <param name="a"><c>MemberRef</c> #1</param>
            <param name="b"><c>MemberRef</c> #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.MemberRef)">
            <summary>
            Gets the hash code of a <c>MemberRef</c>
            </summary>
            <param name="a">The <c>MemberRef</c></param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.MethodSpec,dnlib.DotNet.MethodSpec)">
            <summary>
            Compares <c>MethodSpec</c>s
            </summary>
            <param name="a"><c>MethodSpec</c> #1</param>
            <param name="b"><c>MethodSpec</c> #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.MethodSpec)">
            <summary>
            Gets the hash code of a <c>MethodSpec</c>
            </summary>
            <param name="a">The <c>MethodSpec</c></param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.IMemberRefParent,dnlib.DotNet.IMemberRefParent)">
            <summary>
            Compares <c>MemberRefParent</c>s
            </summary>
            <param name="a"><c>MemberRefParent</c> #1</param>
            <param name="b"><c>MemberRefParent</c> #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.IMemberRefParent)">
            <summary>
            Gets the hash code of a <c>MemberRefParent</c>
            </summary>
            <param name="a">The <c>MemberRefParent</c></param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.IField,dnlib.DotNet.IField)">
            <summary>
            Compares fields
            </summary>
            <param name="a">Field #1</param>
            <param name="b">Field #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.IField)">
            <summary>
            Gets the hash code of a field
            </summary>
            <param name="a">The field</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.MemberRef,dnlib.DotNet.FieldDef)">
            <summary>
            Compares fields
            </summary>
            <param name="a">Field #1</param>
            <param name="b">Field #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.FieldDef,dnlib.DotNet.MemberRef)">
            <summary>
            Compares fields
            </summary>
            <param name="a">Field #1</param>
            <param name="b">Field #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.FieldDef,dnlib.DotNet.FieldDef)">
            <summary>
            Compares fields
            </summary>
            <param name="a">Field #1</param>
            <param name="b">Field #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.FieldDef)">
            <summary>
            Gets the hash code of a field
            </summary>
            <param name="a">The field</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.PropertyDef,dnlib.DotNet.PropertyDef)">
            <summary>
            Compares properties
            </summary>
            <param name="a">Property #1</param>
            <param name="b">Property #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.PropertyDef)">
            <summary>
            Gets the hash code of a property
            </summary>
            <param name="a">The property</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.EventDef,dnlib.DotNet.EventDef)">
            <summary>
            Compares events
            </summary>
            <param name="a">Event #1</param>
            <param name="b">Event #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(dnlib.DotNet.EventDef)">
            <summary>
            Gets the hash code of an event
            </summary>
            <param name="a">The event</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Type,dnlib.DotNet.IType)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.IType,System.Type)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Type,dnlib.DotNet.TypeDef)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeDef,System.Type)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Type,dnlib.DotNet.TypeRef)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeRef,System.Type)">
            <summary>
            Compares types
            </summary>
            <param name="b">Type #1</param>
            <param name="a">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Type,dnlib.DotNet.TypeSpec)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSpec,System.Type)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Type,dnlib.DotNet.TypeSig)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSig,System.Type)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.IsFnPtrElementType(System.Type)">
            <summary>
            Checks whether it's FnPtr&amp;, FnPtr*, FnPtr[], or FnPtr[...]
            </summary>
            <param name="a">The type</param>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSig,System.Type,System.Boolean)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <param name="treatAsGenericInst"><c>true</c> if we should treat <paramref name="b"/>
            as a generic instance type</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Type,dnlib.DotNet.ExportedType)">
            <summary>
            Compares types
            </summary>
            <param name="a">Type #1</param>
            <param name="b">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.ExportedType,System.Type)">
            <summary>
            Compares types
            </summary>
            <param name="b">Type #1</param>
            <param name="a">Type #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(System.Type)">
            <summary>
            Gets the hash code of a type
            </summary>
            <param name="a">The type</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(System.Type,System.Boolean)">
            <summary>
            Gets the hash code of a type
            </summary>
            <param name="a">The type</param>
            <param name="treatAsGenericInst"><c>true</c> if we should treat <paramref name="a"/>
            as a generic instance type</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(System.Collections.Generic.IList{System.Type})">
            <summary>
            Gets the hash code of a type list
            </summary>
            <param name="a">The type list</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode_ElementType_MVar(System.Int32)">
            <summary>
            Gets the hash code of a list with only generic method parameters (<see cref="F:dnlib.DotNet.ElementType.MVar"/>)
            </summary>
            <param name="numGenericParams">Number of generic method parameters</param>
            <returns>Hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode_TypeDef(System.Type)">
            <summary>
            Gets the hash code of a TypeDef type
            </summary>
            <param name="a">The type</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Collections.Generic.IList{System.Type})">
            <summary>
            Compares type lists
            </summary>
            <param name="a">Type list #1</param>
            <param name="b">Type list #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.ModuleDef,System.Reflection.Module)">
            <summary>
            Compares modules
            </summary>
            <param name="a">Module #1</param>
            <param name="b">Module #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.FileDef,System.Reflection.Module)">
            <summary>
            Compares a file and a module
            </summary>
            <param name="a">File</param>
            <param name="b">Module</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.IModule,System.Reflection.Module)">
            <summary>
            Compares modules
            </summary>
            <param name="a">Module #1</param>
            <param name="b">Module #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.IAssembly,System.Reflection.Assembly)">
            <summary>
            Compares assemblies
            </summary>
            <param name="a">Assembly #1</param>
            <param name="b">Assembly #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.DeclaringTypeEquals(dnlib.DotNet.IMethod,System.Reflection.MethodBase)">
            <summary>
            Compares method declaring types
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Reflection.MethodBase,dnlib.DotNet.IMethod)">
            <summary>
            Compares methods
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.IMethod,System.Reflection.MethodBase)">
            <summary>
            Compares methods
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Reflection.MethodBase,dnlib.DotNet.MethodDef)">
            <summary>
            Compares methods
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.MethodDef,System.Reflection.MethodBase)">
            <summary>
            Compares methods
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Reflection.MethodBase,dnlib.DotNet.MethodSig)">
            <summary>
            Compares method sigs
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.MethodSig,System.Reflection.MethodBase)">
            <summary>
            Compares method sigs
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Reflection.MethodBase,dnlib.DotNet.MemberRef)">
            <summary>
            Compares methods
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.MemberRef,System.Reflection.MethodBase)">
            <summary>
            Compares methods
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GenericMethodArgsEquals(System.Int32,System.Collections.Generic.IList{System.Type})">
            <summary>
            Compares generic method args, making sure <paramref name="methodGenArgs"/> only
            contains <see cref="F:dnlib.DotNet.ElementType.MVar"/>s.
            </summary>
            <param name="numMethodArgs">Number of generic method args in method #1</param>
            <param name="methodGenArgs">Generic method args in method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Reflection.MethodBase,dnlib.DotNet.MethodSpec)">
            <summary>
            Compares methods
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.MethodSpec,System.Reflection.MethodBase)">
            <summary>
            Compares methods
            </summary>
            <param name="a">Method #1</param>
            <param name="b">Method #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(System.Reflection.MethodBase)">
            <summary>
            Gets the hash code of a <c>MethodBase</c>
            </summary>
            <param name="a">The <c>MethodBase</c></param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(System.Collections.Generic.IList{System.Reflection.ParameterInfo},System.Type)">
            <summary>
            Gets the hash code of a parameter list
            </summary>
            <param name="a">The type list</param>
            <param name="declaringType">Declaring type of method that owns parameter <paramref name="a"/></param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.CallingConvention,System.Reflection.MethodBase)">
            <summary>
            Compares calling conventions
            </summary>
            <param name="a">Calling convention</param>
            <param name="b">Method</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.ReturnTypeEquals(dnlib.DotNet.TypeSig,System.Reflection.MethodBase)">
            <summary>
            Compares return types
            </summary>
            <param name="a">Return type #1</param>
            <param name="b">MethodBase</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.Collections.Generic.IList{System.Reflection.ParameterInfo},System.Type)">
            <summary>
            Compares parameter lists
            </summary>
            <param name="a">Type list #1</param>
            <param name="b">Type list #2</param>
            <param name="declaringType">Declaring type of method that owns parameter <paramref name="b"/></param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.TypeSig,System.Reflection.ParameterInfo,System.Type)">
            <summary>
            Compares parameter types
            </summary>
            <param name="a">Parameter type #1</param>
            <param name="b">Parameter #2</param>
            <param name="declaringType">Declaring type of method that owns parameter <paramref name="b"/></param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Reflection.FieldInfo,dnlib.DotNet.IField)">
            <summary>
            Compares fields
            </summary>
            <param name="a">Field #1</param>
            <param name="b">Field #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.IField,System.Reflection.FieldInfo)">
            <summary>
            Compares fields
            </summary>
            <param name="a">Field #1</param>
            <param name="b">Field #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Reflection.FieldInfo,dnlib.DotNet.FieldDef)">
            <summary>
            Compares fields
            </summary>
            <param name="a">Field #1</param>
            <param name="b">Field #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.FieldDef,System.Reflection.FieldInfo)">
            <summary>
            Compares fields
            </summary>
            <param name="a">Field #1</param>
            <param name="b">Field #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(System.Reflection.FieldInfo,dnlib.DotNet.MemberRef)">
            <summary>
            Compares fields
            </summary>
            <param name="a">Field #1</param>
            <param name="b">Field #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.MemberRef,System.Reflection.FieldInfo)">
            <summary>
            Compares fields
            </summary>
            <param name="a">Field #1</param>
            <param name="b">Field #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(System.Reflection.FieldInfo)">
            <summary>
            Gets the hash code of a field
            </summary>
            <param name="a">The field</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.PropertyDef,System.Reflection.PropertyInfo)">
            <summary>
            Compares properties
            </summary>
            <param name="a">Property #1</param>
            <param name="b">Property #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(System.Reflection.PropertyInfo)">
            <summary>
            Gets the hash code of a property
            </summary>
            <param name="a">The property</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.Equals(dnlib.DotNet.EventDef,System.Reflection.EventInfo)">
            <summary>
            Compares events
            </summary>
            <param name="a">Event #1</param>
            <param name="b">Event #2</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.GetHashCode(System.Reflection.EventInfo)">
            <summary>
            Gets the hash code of an event
            </summary>
            <param name="a">The event</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.SigComparer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.ISignatureReaderHelper">
            <summary>
            Helps <see cref="T:dnlib.DotNet.SignatureReader"/> resolve types
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ISignatureReaderHelper.ResolveTypeDefOrRef(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Resolves a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="codedToken">A <c>TypeDefOrRef</c> coded token</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/>
            is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.ISignatureReaderHelper.ConvertRTInternalAddress(System.IntPtr)">
            <summary>
            Converts the address of a <see cref="T:System.Type"/> to a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <seealso cref="T:dnlib.DotNet.Emit.MethodTableToTypeConverter"/>
            <param name="address">Address of <see cref="T:System.Type"/>. This is also known as the
            method table and has the same value as <see cref="P:System.RuntimeTypeHandle.Value"/></param>
            <returns>A <see cref="T:dnlib.DotNet.TypeSig"/> or <c>null</c> if not supported</returns>
        </member>
        <member name="T:dnlib.DotNet.SignatureReader">
            <summary>
            Reads signatures from the #Blob stream
            </summary>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadSig(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Reads a signature from the #Blob stream
            </summary>
            <param name="readerModule">Reader module</param>
            <param name="sig">#Blob stream offset of signature</param>
            <returns>A new <see cref="T:dnlib.DotNet.CallingConventionSig"/> instance or <c>null</c> if
            <paramref name="sig"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadSig(dnlib.DotNet.ModuleDefMD,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a signature from the #Blob stream
            </summary>
            <param name="readerModule">Reader module</param>
            <param name="sig">#Blob stream offset of signature</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.CallingConventionSig"/> instance or <c>null</c> if
            <paramref name="sig"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadSig(dnlib.DotNet.ModuleDefMD,System.Byte[])">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.CallingConventionSig"/> signature
            </summary>
            <param name="module">The module where the signature is located in</param>
            <param name="signature">The signature data</param>
            <returns>A new <see cref="T:dnlib.DotNet.CallingConventionSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadSig(dnlib.DotNet.ModuleDefMD,System.Byte[],dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.CallingConventionSig"/> signature
            </summary>
            <param name="module">The module where the signature is located in</param>
            <param name="signature">The signature data</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.CallingConventionSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadSig(dnlib.DotNet.ModuleDefMD,dnlib.IO.DataReader)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.CallingConventionSig"/> signature
            </summary>
            <param name="module">The module where the signature is located in</param>
            <param name="signature">The signature reader</param>
            <returns>A new <see cref="T:dnlib.DotNet.CallingConventionSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadSig(dnlib.DotNet.ModuleDefMD,dnlib.IO.DataReader,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.CallingConventionSig"/> signature
            </summary>
            <param name="module">The module where the signature is located in</param>
            <param name="signature">The signature reader</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.CallingConventionSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadSig(dnlib.DotNet.ISignatureReaderHelper,dnlib.DotNet.ICorLibTypes,System.Byte[])">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.CallingConventionSig"/> signature
            </summary>
            <param name="helper">Token resolver</param>
            <param name="corLibTypes">A <see cref="T:dnlib.DotNet.ICorLibTypes"/> instance</param>
            <param name="signature">The signature data</param>
            <returns>A new <see cref="T:dnlib.DotNet.CallingConventionSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadSig(dnlib.DotNet.ISignatureReaderHelper,dnlib.DotNet.ICorLibTypes,System.Byte[],dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.CallingConventionSig"/> signature
            </summary>
            <param name="helper">Token resolver</param>
            <param name="corLibTypes">A <see cref="T:dnlib.DotNet.ICorLibTypes"/> instance</param>
            <param name="signature">The signature data</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.CallingConventionSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadSig(dnlib.DotNet.ISignatureReaderHelper,dnlib.DotNet.ICorLibTypes,dnlib.IO.DataReader)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.CallingConventionSig"/> signature
            </summary>
            <param name="helper">Token resolver</param>
            <param name="corLibTypes">A <see cref="T:dnlib.DotNet.ICorLibTypes"/> instance</param>
            <param name="signature">The signature reader</param>
            <returns>A new <see cref="T:dnlib.DotNet.CallingConventionSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadSig(dnlib.DotNet.ISignatureReaderHelper,dnlib.DotNet.ICorLibTypes,dnlib.IO.DataReader,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.CallingConventionSig"/> signature
            </summary>
            <param name="helper">Token resolver</param>
            <param name="corLibTypes">A <see cref="T:dnlib.DotNet.ICorLibTypes"/> instance</param>
            <param name="signature">The signature reader</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.CallingConventionSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Reads a type signature from the #Blob stream
            </summary>
            <param name="readerModule">Reader module</param>
            <param name="sig">#Blob stream offset of signature</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="sig"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ModuleDefMD,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a type signature from the #Blob stream
            </summary>
            <param name="readerModule">Reader module</param>
            <param name="sig">#Blob stream offset of signature</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="sig"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ModuleDefMD,System.UInt32,System.Byte[]@)">
            <summary>
            Reads a type signature from the #Blob stream
            </summary>
            <param name="readerModule">Reader module</param>
            <param name="sig">#Blob stream offset of signature</param>
            <param name="extraData">If there's any extra data after the signature, it's saved
            here, else this will be <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="sig"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ModuleDefMD,System.UInt32,dnlib.DotNet.GenericParamContext,System.Byte[]@)">
            <summary>
            Reads a type signature from the #Blob stream
            </summary>
            <param name="readerModule">Reader module</param>
            <param name="sig">#Blob stream offset of signature</param>
            <param name="gpContext">Generic parameter context</param>
            <param name="extraData">If there's any extra data after the signature, it's saved
            here, else this will be <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="sig"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ModuleDefMD,System.Byte[])">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.TypeSig"/> signature
            </summary>
            <param name="module">The module where the signature is located in</param>
            <param name="signature">The signature data</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ModuleDefMD,System.Byte[],dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.TypeSig"/> signature
            </summary>
            <param name="module">The module where the signature is located in</param>
            <param name="signature">The signature data</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ModuleDefMD,dnlib.IO.DataReader)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.TypeSig"/> signature
            </summary>
            <param name="module">The module where the signature is located in</param>
            <param name="signature">The signature reader</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ModuleDefMD,dnlib.IO.DataReader,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.TypeSig"/> signature
            </summary>
            <param name="module">The module where the signature is located in</param>
            <param name="signature">The signature reader</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ISignatureReaderHelper,dnlib.DotNet.ICorLibTypes,System.Byte[])">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.TypeSig"/> signature
            </summary>
            <param name="helper">Token resolver</param>
            <param name="corLibTypes">A <see cref="T:dnlib.DotNet.ICorLibTypes"/> instance</param>
            <param name="signature">The signature data</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ISignatureReaderHelper,dnlib.DotNet.ICorLibTypes,System.Byte[],dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.TypeSig"/> signature
            </summary>
            <param name="helper">Token resolver</param>
            <param name="corLibTypes">A <see cref="T:dnlib.DotNet.ICorLibTypes"/> instance</param>
            <param name="signature">The signature data</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ISignatureReaderHelper,dnlib.DotNet.ICorLibTypes,dnlib.IO.DataReader)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.TypeSig"/> signature
            </summary>
            <param name="helper">Token resolver</param>
            <param name="corLibTypes">A <see cref="T:dnlib.DotNet.ICorLibTypes"/> instance</param>
            <param name="signature">The signature reader</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ISignatureReaderHelper,dnlib.DotNet.ICorLibTypes,dnlib.IO.DataReader,dnlib.DotNet.GenericParamContext)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.TypeSig"/> signature
            </summary>
            <param name="helper">Token resolver</param>
            <param name="corLibTypes">A <see cref="T:dnlib.DotNet.ICorLibTypes"/> instance</param>
            <param name="signature">The signature reader</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ISignatureReaderHelper,dnlib.DotNet.ICorLibTypes,System.Byte[],dnlib.DotNet.GenericParamContext,System.Byte[]@)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.TypeSig"/> signature
            </summary>
            <param name="helper">Token resolver</param>
            <param name="corLibTypes">A <see cref="T:dnlib.DotNet.ICorLibTypes"/> instance</param>
            <param name="signature">The signature data</param>
            <param name="gpContext">Generic parameter context</param>
            <param name="extraData">If there's any extra data after the signature, it's saved
            here, else this will be <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeSig(dnlib.DotNet.ISignatureReaderHelper,dnlib.DotNet.ICorLibTypes,dnlib.IO.DataReader,dnlib.DotNet.GenericParamContext,System.Byte[]@)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.TypeSig"/> signature
            </summary>
            <param name="helper">Token resolver</param>
            <param name="corLibTypes">A <see cref="T:dnlib.DotNet.ICorLibTypes"/> instance</param>
            <param name="signature">The signature reader</param>
            <param name="gpContext">Generic parameter context</param>
            <param name="extraData">If there's any extra data after the signature, it's saved
            here, else this will be <c>null</c></param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if
            <paramref name="signature"/> is invalid.</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">Reader module</param>
            <param name="sig">#Blob stream offset of signature</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.#ctor(dnlib.DotNet.ISignatureReaderHelper,dnlib.DotNet.ICorLibTypes,dnlib.IO.DataReader@,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="helper">Token resolver</param>
            <param name="corLibTypes">A <see cref="T:dnlib.DotNet.ICorLibTypes"/> instance</param>
            <param name="reader">The signature data</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadSig">
            <summary>
            Reads the signature
            </summary>
            <returns>A new <see cref="T:dnlib.DotNet.CallingConventionSig"/> instance or <c>null</c> if invalid signature</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadField(dnlib.DotNet.CallingConvention)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.FieldSig"/>
            </summary>
            <param name="callingConvention">First byte of signature</param>
            <returns>A new <see cref="T:dnlib.DotNet.FieldSig"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadMethod(dnlib.DotNet.CallingConvention)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.MethodSig"/>
            </summary>
            <param name="callingConvention">First byte of signature</param>
            <returns>A new <see cref="T:dnlib.DotNet.MethodSig"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadProperty(dnlib.DotNet.CallingConvention)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.PropertySig"/>
            </summary>
            <param name="callingConvention">First byte of signature</param>
            <returns>A new <see cref="T:dnlib.DotNet.PropertySig"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadLocalSig(dnlib.DotNet.CallingConvention)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.LocalSig"/>
            </summary>
            <param name="callingConvention">First byte of signature</param>
            <returns>A new <see cref="T:dnlib.DotNet.LocalSig"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadGenericInstMethod(dnlib.DotNet.CallingConvention)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.GenericInstMethodSig"/>
            </summary>
            <param name="callingConvention">First byte of signature</param>
            <returns>A new <see cref="T:dnlib.DotNet.GenericInstMethodSig"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadType">
            <summary>
            Reads the next type
            </summary>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if invalid element type</returns>
        </member>
        <member name="M:dnlib.DotNet.SignatureReader.ReadTypeDefOrRef">
            <summary>
            Reads a <c>TypeDefOrRef</c>
            </summary>
            <returns>A <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> instance</returns>
        </member>
        <member name="T:dnlib.DotNet.StandAloneSig">
            <summary>
            A high-level representation of a row in the StandAloneSig table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.StandAloneSig.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StandAloneSig.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.StandAloneSig.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.StandAloneSig.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.StandAloneSig.Signature">
            <summary>
            From column StandAloneSig.Signature
            </summary>
        </member>
        <member name="F:dnlib.DotNet.StandAloneSig.signature">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.StandAloneSig.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.StandAloneSig.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.StandAloneSig.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.StandAloneSig.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.StandAloneSig.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.StandAloneSig.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.StandAloneSig.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.StandAloneSig.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.StandAloneSig.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.StandAloneSig.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.StandAloneSig.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.StandAloneSig.MethodSig">
            <summary>
            Gets/sets the method sig
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StandAloneSig.LocalSig">
            <summary>
            Gets/sets the locals sig
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StandAloneSig.ContainsGenericParameter">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.StandAloneSigUser">
            <summary>
            A StandAloneSig row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.StandAloneSigUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.StandAloneSigUser.#ctor(dnlib.DotNet.LocalSig)">
            <summary>
            Constructor
            </summary>
            <param name="localSig">A locals sig</param>
        </member>
        <member name="M:dnlib.DotNet.StandAloneSigUser.#ctor(dnlib.DotNet.MethodSig)">
            <summary>
            Constructor
            </summary>
            <param name="methodSig">A method sig</param>
        </member>
        <member name="T:dnlib.DotNet.StandAloneSigMD">
            <summary>
            Created from a row in the StandAloneSig table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.StandAloneSigMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.StandAloneSigMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.StandAloneSigMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.StandAloneSigMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.StandAloneSigMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>StandAloneSig</c> row</param>
            <param name="rid">Row ID</param>
            <param name="gpContext">Generic parameter context</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.InvalidKeyException">
            <summary>
            Thrown if the strong name key or public key is invalid
            </summary>
        </member>
        <member name="M:dnlib.DotNet.InvalidKeyException.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.InvalidKeyException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Error message</param>
        </member>
        <member name="M:dnlib.DotNet.InvalidKeyException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Error message</param>
            <param name="innerException">Other exception</param>
        </member>
        <member name="M:dnlib.DotNet.InvalidKeyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:dnlib.DotNet.SignatureAlgorithm">
            <summary>
            Type of signature algorithm. See WinCrypt.h in the Windows SDK
            </summary>
        </member>
        <member name="F:dnlib.DotNet.SignatureAlgorithm.CALG_RSA_SIGN">
            <summary>
            RSA signature algorithm
            </summary>
        </member>
        <member name="T:dnlib.DotNet.StrongNamePublicKey">
            <summary>
            A public key
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNamePublicKey.SignatureAlgorithm">
            <summary>
            Gets/sets the signature algorithm
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNamePublicKey.HashAlgorithm">
            <summary>
            Gets/sets the hash algorithm
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNamePublicKey.Modulus">
            <summary>
            Gets/sets the modulus
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNamePublicKey.PublicExponent">
            <summary>
            Gets/sets the public exponent
            </summary>
        </member>
        <member name="M:dnlib.DotNet.StrongNamePublicKey.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.StrongNamePublicKey.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="modulus">Modulus</param>
            <param name="publicExponent">Public exponent</param>
        </member>
        <member name="M:dnlib.DotNet.StrongNamePublicKey.#ctor(System.Byte[],System.Byte[],dnlib.DotNet.AssemblyHashAlgorithm)">
            <summary>
            Constructor
            </summary>
            <param name="modulus">Modulus</param>
            <param name="publicExponent">Public exponent</param>
            <param name="hashAlgorithm">Hash algorithm</param>
        </member>
        <member name="M:dnlib.DotNet.StrongNamePublicKey.#ctor(System.Byte[],System.Byte[],dnlib.DotNet.AssemblyHashAlgorithm,dnlib.DotNet.SignatureAlgorithm)">
            <summary>
            Constructor
            </summary>
            <param name="modulus">Modulus</param>
            <param name="publicExponent">Public exponent</param>
            <param name="hashAlgorithm">Hash algorithm</param>
            <param name="signatureAlgorithm">Signature algorithm</param>
        </member>
        <member name="M:dnlib.DotNet.StrongNamePublicKey.#ctor(dnlib.DotNet.PublicKey)">
            <summary>
            Constructor
            </summary>
            <param name="pk">Public key</param>
        </member>
        <member name="M:dnlib.DotNet.StrongNamePublicKey.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="pk">Public key data</param>
            <exception cref="T:dnlib.DotNet.InvalidKeyException">Strong name key is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.StrongNamePublicKey.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="filename">Public key file</param>
            <exception cref="T:dnlib.DotNet.InvalidKeyException">Strong name key is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.StrongNamePublicKey.#ctor(System.IO.Stream)">
            <summary>
            Constructor
            </summary>
            <param name="stream">Public key stream</param>
            <exception cref="T:dnlib.DotNet.InvalidKeyException">Strong name key is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.StrongNamePublicKey.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="reader">Public key reader</param>
            <exception cref="T:dnlib.DotNet.InvalidKeyException">Strong name key is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.StrongNamePublicKey.CreatePublicKey">
            <summary>
            Creates a public key blob
            </summary>
        </member>
        <member name="M:dnlib.DotNet.StrongNamePublicKey.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.StrongNameKey">
            <summary>
            Stores a strong name key pair
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNameKey.PublicKey">
            <summary>
            Gets the public key
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNameKey.SignatureSize">
            <summary>
            Gets the strong name signature size in bytes
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNameKey.HashAlgorithm">
            <summary>
            Gets the public key hash algorithm. It's usually <see cref="F:dnlib.DotNet.AssemblyHashAlgorithm.SHA1"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNameKey.PublicExponent">
            <summary>
            Gets the public exponent
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNameKey.Modulus">
            <summary>
            Gets the modulus
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNameKey.Prime1">
            <summary>
            Gets prime1
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNameKey.Prime2">
            <summary>
            Gets prime2
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNameKey.Exponent1">
            <summary>
            Gets exponent1
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNameKey.Exponent2">
            <summary>
            Gets exponent2
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNameKey.Coefficient">
            <summary>
            Gets the coefficient
            </summary>
        </member>
        <member name="P:dnlib.DotNet.StrongNameKey.PrivateExponent">
            <summary>
            Gets the private exponent
            </summary>
        </member>
        <member name="M:dnlib.DotNet.StrongNameKey.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="keyData">Strong name key data</param>
            <exception cref="T:dnlib.DotNet.InvalidKeyException">Strong name key is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.StrongNameKey.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="filename">Strong name key file</param>
            <exception cref="T:dnlib.DotNet.InvalidKeyException">Strong name key is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.StrongNameKey.#ctor(System.IO.Stream)">
            <summary>
            Constructor
            </summary>
            <param name="stream">Strong name key stream</param>
            <exception cref="T:dnlib.DotNet.InvalidKeyException">Strong name key is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.StrongNameKey.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="reader">Strong name key reader</param>
            <exception cref="T:dnlib.DotNet.InvalidKeyException">Strong name key is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.StrongNameKey.WithHashAlgorithm(dnlib.DotNet.AssemblyHashAlgorithm)">
            <summary>
            Creates a strong name key with a new hash algorithm
            </summary>
            <param name="hashAlgorithm">Algorithm</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.StrongNameKey.CreateRSA">
            <summary>
            Creates an <see cref="T:System.Security.Cryptography.RSA"/> instance
            </summary>
        </member>
        <member name="M:dnlib.DotNet.StrongNameKey.CreateStrongName">
            <summary>
            Creates a strong name blob
            </summary>
        </member>
        <member name="M:dnlib.DotNet.StrongNameKey.CreateCounterSignatureAsString(dnlib.DotNet.StrongNamePublicKey,dnlib.DotNet.StrongNameKey,dnlib.DotNet.StrongNamePublicKey)">
            <summary>
            Creates a counter signature, just like
            <c>sn -a IdentityPubKey.snk IdentityKey.snk SignaturePubKey.snk</c> can do.
            The public key <c>sn</c> prints is <paramref name="signaturePubKey"/>'s value.
            </summary>
            <param name="identityPubKey">Identity public key</param>
            <param name="identityKey">Identity strong name key pair</param>
            <param name="signaturePubKey">Signature public key</param>
            <returns>The counter signature as a hex string</returns>
        </member>
        <member name="M:dnlib.DotNet.StrongNameKey.CreateCounterSignature(dnlib.DotNet.StrongNamePublicKey,dnlib.DotNet.StrongNameKey,dnlib.DotNet.StrongNamePublicKey)">
            <summary>
            Creates a counter signature, just like
            <c>sn -a IdentityPubKey.snk IdentityKey.snk SignaturePubKey.snk</c> can do.
            The public key <c>sn</c> prints is <paramref name="signaturePubKey"/>'s value.
            </summary>
            <param name="identityPubKey">Identity public key</param>
            <param name="identityKey">Identity strong name key pair</param>
            <param name="signaturePubKey">Signature public key</param>
            <returns>The counter signature</returns>
        </member>
        <member name="T:dnlib.DotNet.StrongNameSigner">
            <summary>
            Strong name signs an assembly. It supports normal strong name signing and the new
            (.NET 4.5) enhanced strong name signing.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.StrongNameSigner.#ctor(System.IO.Stream)">
            <summary>
            Constructor
            </summary>
            <param name="stream">.NET PE file stream</param>
        </member>
        <member name="M:dnlib.DotNet.StrongNameSigner.#ctor(System.IO.Stream,System.Int64)">
            <summary>
            Constructor
            </summary>
            <param name="stream">.NET PE file stream</param>
            <param name="baseOffset">Offset in <paramref name="stream"/> of the first byte of
            the PE file.</param>
        </member>
        <member name="M:dnlib.DotNet.StrongNameSigner.WriteSignature(dnlib.DotNet.StrongNameKey,System.Int64)">
            <summary>
            Calculates the strong name signature and writes it to the stream. The signature
            is also returned.
            </summary>
            <param name="snk">Strong name key used for signing</param>
            <param name="snSigOffset">Offset (relative to the start of the PE file) of the strong
            name signature.</param>
            <returns>The strong name signature</returns>
        </member>
        <member name="M:dnlib.DotNet.StrongNameSigner.CalculateSignature(dnlib.DotNet.StrongNameKey,System.Int64)">
            <summary>
            Calculates and returns the strong name signature
            </summary>
            <param name="snk">Strong name key used for signing</param>
            <param name="snSigOffset">Offset (relative to start of PE file) of the strong
            name signature.</param>
            <returns>The strong name signature</returns>
        </member>
        <member name="M:dnlib.DotNet.StrongNameSigner.StrongNameHashData(dnlib.DotNet.AssemblyHashAlgorithm,System.Int64,System.UInt32)">
            <summary>
            Strong name hashes the .NET file
            </summary>
            <param name="hashAlg">Hash algorithm</param>
            <param name="snSigOffset">Strong name sig offset (relative to start of .NET PE file)</param>
            <param name="snSigSize">Size of strong name signature</param>
            <returns>The strong name hash of the .NET file</returns>
        </member>
        <member name="M:dnlib.DotNet.StrongNameSigner.GetStrongNameSignature(dnlib.DotNet.StrongNameKey,dnlib.DotNet.AssemblyHashAlgorithm,System.Byte[])">
            <summary>
            Returns the strong name signature
            </summary>
            <param name="snk">Strong name key</param>
            <param name="hashAlg">Hash algorithm</param>
            <param name="hash">Strong name hash of the .NET PE file</param>
            <returns>Strong name signature</returns>
        </member>
        <member name="T:dnlib.DotNet.TIAHelper">
            <summary>
            <c>System.Runtime.InteropServices.TypeIdentifierAttribute</c> helper code used by <see cref="T:dnlib.DotNet.SigComparer"/>
            </summary>
        </member>
        <member name="T:dnlib.DotNet.TypeAttributes">
            <summary>
            TypeDef and ExportedType flags. See CorHdr.h/CorTypeAttr
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.VisibilityMask">
            <summary>Use this mask to retrieve the type visibility information.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.NotPublic">
            <summary>Class is not public scope.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.Public">
            <summary>Class is public scope.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.NestedPublic">
            <summary>Class is nested with public visibility.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.NestedPrivate">
            <summary>Class is nested with private visibility.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.NestedFamily">
            <summary>Class is nested with family visibility.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.NestedAssembly">
            <summary>Class is nested with assembly visibility.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.NestedFamANDAssem">
            <summary>Class is nested with family and assembly visibility.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.NestedFamORAssem">
            <summary>Class is nested with family or assembly visibility.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.LayoutMask">
            <summary>Use this mask to retrieve class layout information</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.AutoLayout">
            <summary>Class fields are auto-laid out</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.SequentialLayout">
            <summary>Class fields are laid out sequentially</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.ExplicitLayout">
            <summary>Layout is supplied explicitly</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.ClassSemanticsMask">
            <summary>Use this mask to retrieve class semantics information.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.ClassSemanticMask">
            <summary>Use this mask to retrieve class semantics information.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.Class">
            <summary>Type is a class.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.Interface">
            <summary>Type is an interface.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.Abstract">
            <summary>Class is abstract</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.Sealed">
            <summary>Class is concrete and may not be extended</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.SpecialName">
            <summary>Class name is special.  Name describes how.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.Import">
            <summary>Class / interface is imported</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.Serializable">
            <summary>The class is Serializable.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.WindowsRuntime">
            <summary>The type is a Windows Runtime type</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.StringFormatMask">
            <summary>Use StringFormatMask to retrieve string information for native interop</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.AnsiClass">
            <summary>LPTSTR is interpreted as ANSI in this class</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.UnicodeClass">
            <summary>LPTSTR is interpreted as UNICODE</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.AutoClass">
            <summary>LPTSTR is interpreted automatically</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.CustomFormatClass">
            <summary>A non-standard encoding specified by CustomFormatMask</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.CustomFormatMask">
            <summary>Use this mask to retrieve non-standard encoding information for native interop. The meaning of the values of these 2 bits is unspecified.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.BeforeFieldInit">
            <summary>Initialize the class any time before first static field access.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.Forwarder">
            <summary>This ExportedType is a type forwarder.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.ReservedMask">
            <summary>Flags reserved for runtime use.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.RTSpecialName">
            <summary>Runtime should check name encoding.</summary>
        </member>
        <member name="F:dnlib.DotNet.TypeAttributes.HasSecurity">
            <summary>Class has security associate with it.</summary>
        </member>
        <member name="T:dnlib.DotNet.TypeDef">
            <summary>
            A high-level representation of a row in the TypeDef table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.TypeDefOrRefTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasDeclSecurityTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.MemberRefParentTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.TypeOrMethodDefTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.dnlib#DotNet#IGenericParameterProvider#NumberOfGenericParameters">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.dnlib#DotNet#IType#TypeName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.ReflectionName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.dnlib#DotNet#IType#Namespace">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.ReflectionNamespace">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.FullName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.ReflectionFullName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.AssemblyQualifiedName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.DefinitionAssembly">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Scope">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.ScopeType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.ContainsGenericParameter">
            <summary>
            Always returns <c>false</c> since a <see cref="T:dnlib.DotNet.TypeDef"/> does not contain any
            <see cref="T:dnlib.DotNet.GenericVar"/> or <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Module2">
            <summary>
            Gets/sets the owner module
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.module2">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.module2_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.GetModule2_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.TypeDef.module2"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Attributes">
            <summary>
            From column TypeDef.Flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.attributes">
            <summary>Attributes</summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Name">
            <summary>
            From column TypeDef.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Namespace">
            <summary>
            From column TypeDef.Namespace
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.namespace">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.BaseType">
            <summary>
            From column TypeDef.Extends
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.baseType">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.baseType_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.GetBaseType_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.TypeDef.baseType"/></summary>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.ResetBaseType">
            <summary>Reset <see cref="P:dnlib.DotNet.TypeDef.BaseType"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Fields">
            <summary>
            From column TypeDef.FieldList
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.fields">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.InitializeFields">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeDef.fields"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Methods">
            <summary>
            From column TypeDef.MethodList
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.methods">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.InitializeMethods">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeDef.methods"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.GenericParameters">
            <inheritdoc/>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.genericParameters">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.InitializeGenericParameters">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeDef.genericParameters"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Interfaces">
            <summary>
            Gets the interfaces
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.interfaces">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.InitializeInterfaces">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeDef.interfaces"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.DeclSecurities">
            <inheritdoc/>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.declSecurities">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.InitializeDeclSecurities">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeDef.declSecurities"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.ClassLayout">
            <summary>
            Gets/sets the class layout
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.classLayout">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.classLayout_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.GetClassLayout_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.TypeDef.classLayout"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasDeclSecurities">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.DeclaringType">
            <summary>
            Gets/sets the enclosing type. It's <c>null</c> if this isn't a nested class.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.dnlib#DotNet#IMemberRef#DeclaringType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.DeclaringType2">
            <summary>
            Called by <see cref="P:dnlib.DotNet.TypeDef.DeclaringType"/> and should normally not be called by any user
            code. Use <see cref="P:dnlib.DotNet.TypeDef.DeclaringType"/> instead. Only call this if you must set the
            declaring type without inserting it in the declaring type's method list.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.declaringType2">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.declaringType2_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.GetDeclaringType2_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.TypeDef.declaringType2"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.NestedTypes">
            <summary>
            Gets all the nested types
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.nestedTypes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.InitializeNestedTypes">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeDef.nestedTypes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Events">
            <summary>
            Gets all events
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.events">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.InitializeEvents">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeDef.events"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Properties">
            <summary>
            Gets all properties
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.properties">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.InitializeProperties">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeDef.properties"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeDef.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDef.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeDef.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasFields">
            <summary>
            <c>true</c> if there's at least one <see cref="T:dnlib.DotNet.FieldDef"/> in <see cref="P:dnlib.DotNet.TypeDef.Fields"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasMethods">
            <summary>
            <c>true</c> if there's at least one <see cref="T:dnlib.DotNet.MethodDef"/> in <see cref="P:dnlib.DotNet.TypeDef.Methods"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasGenericParameters">
            <summary>
            <c>true</c> if there's at least one <see cref="T:dnlib.DotNet.GenericParam"/> in <see cref="P:dnlib.DotNet.TypeDef.GenericParameters"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasEvents">
            <summary>
            <c>true</c> if there's at least one <see cref="T:dnlib.DotNet.EventDef"/> in <see cref="P:dnlib.DotNet.TypeDef.Events"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasProperties">
            <summary>
            <c>true</c> if there's at least one <see cref="T:dnlib.DotNet.PropertyDef"/> in <see cref="P:dnlib.DotNet.TypeDef.Properties"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasNestedTypes">
            <summary>
            <c>true</c> if there's at least one <see cref="T:dnlib.DotNet.TypeDef"/> in <see cref="P:dnlib.DotNet.TypeDef.NestedTypes"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasInterfaces">
            <summary>
            <c>true</c> if there's at least one <see cref="T:dnlib.DotNet.InterfaceImpl"/> in <see cref="P:dnlib.DotNet.TypeDef.Interfaces"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasClassLayout">
            <summary>
            <c>true</c> if <see cref="P:dnlib.DotNet.TypeDef.ClassLayout"/> is not <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.PackingSize">
            <summary>
            Gets/sets the packing size. If you write to this property but <see cref="P:dnlib.DotNet.TypeDef.ClassLayout"/>
            is <c>null</c>, it will be created. The value <see cref="F:System.UInt16.MaxValue"/> is returned
            if <see cref="P:dnlib.DotNet.TypeDef.ClassLayout"/> is <c>null</c>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.ClassSize">
            <summary>
            Gets/sets the class size. If you write to this property but <see cref="P:dnlib.DotNet.TypeDef.ClassLayout"/>
            is <c>null</c>, it will be created. The value <see cref="F:System.UInt32.MaxValue"/> is returned
            if <see cref="P:dnlib.DotNet.TypeDef.ClassLayout"/> is <c>null</c>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsValueType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsEnum">
            <summary>
            <c>true</c> if it's an enum
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsDelegate">
            <summary>
            <c>true</c> if it's a delegate (it derives from <see cref="T:System.MulticastDelegate"/>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsNested">
            <summary>
            <c>true</c> if this is a nested type (it has a declaring type)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsPrimitive">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.ModifyAttributes(dnlib.DotNet.TypeAttributes,dnlib.DotNet.TypeAttributes)">
            <summary>
            Modify <see cref="F:dnlib.DotNet.TypeDef.attributes"/> property: <see cref="F:dnlib.DotNet.TypeDef.attributes"/> =
            (<see cref="F:dnlib.DotNet.TypeDef.attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
            </summary>
            <param name="andMask">Value to <c>AND</c></param>
            <param name="orMask">Value to OR</param>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.ModifyAttributes(System.Boolean,dnlib.DotNet.TypeAttributes)">
            <summary>
            Set or clear flags in <see cref="F:dnlib.DotNet.TypeDef.attributes"/>
            </summary>
            <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
            be cleared</param>
            <param name="flags">Flags to set or clear</param>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Visibility">
            <summary>
            Gets/sets the visibility
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsNotPublic">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NotPublic"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsPublic">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.Public"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsNestedPublic">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NestedPublic"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsNestedPrivate">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NestedPrivate"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsNestedFamily">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NestedFamily"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsNestedAssembly">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NestedAssembly"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsNestedFamilyAndAssembly">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NestedFamANDAssem"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsNestedFamilyOrAssembly">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.NestedFamORAssem"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.Layout">
            <summary>
            Gets/sets the layout
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsAutoLayout">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.AutoLayout"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsSequentialLayout">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.SequentialLayout"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsExplicitLayout">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.ExplicitLayout"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsInterface">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Interface"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsClass">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Class"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsAbstract">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Abstract"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsSealed">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Sealed"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsSpecialName">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.SpecialName"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsImport">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Import"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsSerializable">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Serializable"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsWindowsRuntime">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.WindowsRuntime"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.StringFormat">
            <summary>
            Gets/sets the string format
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsAnsiClass">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.AnsiClass"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsUnicodeClass">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.UnicodeClass"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsAutoClass">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.AutoClass"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsCustomFormatClass">
            <summary>
            <c>true</c> if <see cref="F:dnlib.DotNet.TypeAttributes.CustomFormatClass"/> is set
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsBeforeFieldInit">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.BeforeFieldInit"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsForwarder">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.Forwarder"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsRuntimeSpecialName">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.RTSpecialName"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.HasSecurity">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.TypeAttributes.HasSecurity"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDef.IsGlobalModuleType">
            <summary>
            <c>true</c> if this is the global (aka. &lt;Module&gt;) type
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.GetTypes">
            <summary>
            Gets a list of all nested types and all their nested types
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.GetEnumUnderlyingType">
            <summary>
            Gets an enum's underlying type or <c>null</c> if none. Should only be called
            if this is an enum.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.Resolve(dnlib.DotNet.MemberRef)">
            <summary>
            Resolves a method or a field. <see cref="P:dnlib.DotNet.MemberRef.Class"/> (owner type) is ignored when
            resolving the method/field. Private scope methods/fields are not returned.
            </summary>
            <param name="memberRef">A method/field reference</param>
            <returns>A <see cref="T:dnlib.DotNet.MethodDef"/> or a <see cref="T:dnlib.DotNet.FieldDef"/> instance or <c>null</c>
            if it couldn't be resolved.</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.Resolve(dnlib.DotNet.MemberRef,dnlib.DotNet.SigComparerOptions)">
            <summary>
            Resolves a method or a field. <see cref="P:dnlib.DotNet.MemberRef.Class"/> (owner type) is ignored when
            resolving the method/field.
            </summary>
            <param name="memberRef">A method/field reference</param>
            <param name="options">Method/field signature comparison options</param>
            <returns>A <see cref="T:dnlib.DotNet.MethodDef"/> or a <see cref="T:dnlib.DotNet.FieldDef"/> instance or <c>null</c>
            if it couldn't be resolved.</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindMethod(dnlib.DotNet.UTF8String,dnlib.DotNet.MethodSig)">
            <summary>
            Finds a method. Private scope methods are not returned.
            </summary>
            <param name="name">Method name</param>
            <param name="sig">Method signature</param>
            <returns>The first method that matches or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindMethod(dnlib.DotNet.UTF8String,dnlib.DotNet.MethodSig,dnlib.DotNet.SigComparerOptions)">
            <summary>
            Finds a method
            </summary>
            <param name="name">Method name</param>
            <param name="sig">Method signature</param>
            <param name="options">Method signature comparison options</param>
            <returns>The first method that matches or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindMethod(dnlib.DotNet.UTF8String,dnlib.DotNet.MethodSig,dnlib.DotNet.SigComparerOptions,dnlib.DotNet.ModuleDef)">
            <summary>
            Finds a method
            </summary>
            <param name="name">Method name</param>
            <param name="sig">Method signature</param>
            <param name="options">Method signature comparison options</param>
            <param name="sourceModule">The module that needs to find the method or <c>null</c></param>
            <returns>The first method that matches or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindMethod(dnlib.DotNet.UTF8String)">
            <summary>
            Finds a method by name
            </summary>
            <param name="name">Name of method</param>
            <returns>The <see cref="T:dnlib.DotNet.MethodDef"/> or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindMethods(dnlib.DotNet.UTF8String)">
            <summary>
            Finds all methods by name
            </summary>
            <param name="name">Name of method</param>
            <returns>All methods with that name</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindStaticConstructor">
            <summary>
            Finds the class constructor (aka type initializer). It's the method named .cctor
            </summary>
            <returns>The class constructor or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindOrCreateStaticConstructor">
            <summary>
            Finds the class constructor (aka type initializer). It's the method named .cctor.
            If it doesn't exist, it is created, inserted into <see cref="P:dnlib.DotNet.TypeDef.Methods"/> and returned.
            The created .cctor will have just one RET instruction.
            </summary>
            <returns>The class constructor</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindInstanceConstructors">
            <summary>
            Finds all instance constructors (not class constructors)
            </summary>
            <returns>All instance constructors</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindConstructors">
            <summary>
            Finds all static and instance constructors
            </summary>
            <returns>All static and instance constructors</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindDefaultConstructor">
            <summary>
            Finds the default instance constructor (the one with no arguments)
            </summary>
            <returns>The default instance constructor or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindField(dnlib.DotNet.UTF8String,dnlib.DotNet.FieldSig)">
            <summary>
            Finds a field. Private scope fields are not returned.
            </summary>
            <param name="name">Field name</param>
            <param name="sig">Field signature</param>
            <returns>The first field that matches or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindField(dnlib.DotNet.UTF8String,dnlib.DotNet.FieldSig,dnlib.DotNet.SigComparerOptions)">
            <summary>
            Finds a field
            </summary>
            <param name="name">Field name</param>
            <param name="sig">Field signature</param>
            <param name="options">Field signature comparison options</param>
            <returns>The first field that matches or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindField(dnlib.DotNet.UTF8String,dnlib.DotNet.FieldSig,dnlib.DotNet.SigComparerOptions,dnlib.DotNet.ModuleDef)">
            <summary>
            Finds a field
            </summary>
            <param name="name">Field name</param>
            <param name="sig">Field signature</param>
            <param name="options">Field signature comparison options</param>
            <param name="sourceModule">The module that needs to find the field or <c>null</c></param>
            <returns>The first field that matches or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindField(dnlib.DotNet.UTF8String)">
            <summary>
            Finds a field by name
            </summary>
            <param name="name">Name of field</param>
            <returns>The <see cref="T:dnlib.DotNet.FieldDef"/> or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindFields(dnlib.DotNet.UTF8String)">
            <summary>
            Finds all fields by name
            </summary>
            <param name="name">Name of field</param>
            <returns>All fields with that name</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindEvent(dnlib.DotNet.UTF8String,dnlib.DotNet.IType)">
            <summary>
            Finds an event
            </summary>
            <param name="name">Name of event</param>
            <param name="type">Type of event</param>
            <returns>A <see cref="T:dnlib.DotNet.EventDef"/> or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindEvent(dnlib.DotNet.UTF8String,dnlib.DotNet.IType,dnlib.DotNet.SigComparerOptions)">
            <summary>
            Finds an event
            </summary>
            <param name="name">Name of event</param>
            <param name="type">Type of event</param>
            <param name="options">Event type comparison options</param>
            <returns>A <see cref="T:dnlib.DotNet.EventDef"/> or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindEvent(dnlib.DotNet.UTF8String,dnlib.DotNet.IType,dnlib.DotNet.SigComparerOptions,dnlib.DotNet.ModuleDef)">
            <summary>
            Finds an event
            </summary>
            <param name="name">Name of event</param>
            <param name="type">Type of event</param>
            <param name="options">Event type comparison options</param>
            <param name="sourceModule">The module that needs to find the event or <c>null</c></param>
            <returns>A <see cref="T:dnlib.DotNet.EventDef"/> or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindEvent(dnlib.DotNet.UTF8String)">
            <summary>
            Finds an event by name
            </summary>
            <param name="name">Name of event</param>
            <returns>The <see cref="T:dnlib.DotNet.EventDef"/> or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindEvents(dnlib.DotNet.UTF8String)">
            <summary>
            Finds all events by name
            </summary>
            <param name="name">Name of event</param>
            <returns>All events with that name</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindProperty(dnlib.DotNet.UTF8String,dnlib.DotNet.CallingConventionSig)">
            <summary>
            Finds a property
            </summary>
            <param name="name">Name of property</param>
            <param name="propSig">Property signature</param>
            <returns>A <see cref="T:dnlib.DotNet.PropertyDef"/> or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindProperty(dnlib.DotNet.UTF8String,dnlib.DotNet.CallingConventionSig,dnlib.DotNet.SigComparerOptions)">
            <summary>
            Finds a property
            </summary>
            <param name="name">Name of property</param>
            <param name="propSig">Property signature</param>
            <param name="options">Property signature comparison options</param>
            <returns>A <see cref="T:dnlib.DotNet.PropertyDef"/> or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindProperty(dnlib.DotNet.UTF8String,dnlib.DotNet.CallingConventionSig,dnlib.DotNet.SigComparerOptions,dnlib.DotNet.ModuleDef)">
            <summary>
            Finds a property
            </summary>
            <param name="name">Name of property</param>
            <param name="propSig">Property signature</param>
            <param name="options">Property signature comparison options</param>
            <param name="sourceModule">The module that needs to find the property or <c>null</c></param>
            <returns>A <see cref="T:dnlib.DotNet.PropertyDef"/> or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindProperty(dnlib.DotNet.UTF8String)">
            <summary>
            Finds a prop by name
            </summary>
            <param name="name">Name of prop</param>
            <returns>The <see cref="T:dnlib.DotNet.PropertyDef"/> or <c>null</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindProperties(dnlib.DotNet.UTF8String)">
            <summary>
            Finds all props by name
            </summary>
            <param name="name">Name of prop</param>
            <returns>All props with that name</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindMethodCheckBaseType(dnlib.DotNet.UTF8String,dnlib.DotNet.MethodSig)">
            <summary>
            Finds a method by checking this type or any of its base types
            </summary>
            <param name="name">Method name</param>
            <param name="sig">Method signature</param>
            <returns>The method or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindMethodCheckBaseType(dnlib.DotNet.UTF8String,dnlib.DotNet.MethodSig,dnlib.DotNet.SigComparerOptions)">
            <summary>
            Finds a method by checking this type or any of its base types
            </summary>
            <param name="name">Method name</param>
            <param name="sig">Method signature</param>
            <param name="options">Method signature comparison options</param>
            <returns>The method or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindMethodCheckBaseType(dnlib.DotNet.UTF8String,dnlib.DotNet.MethodSig,dnlib.DotNet.SigComparerOptions,dnlib.DotNet.ModuleDef)">
            <summary>
            Finds a method by checking this type or any of its base types
            </summary>
            <param name="name">Method name</param>
            <param name="sig">Method signature</param>
            <param name="options">Method signature comparison options</param>
            <param name="sourceModule">The module that needs to find the method or <c>null</c></param>
            <returns>The method or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindMethodCheckBaseType(dnlib.DotNet.UTF8String)">
            <summary>
            Finds a method by checking this type or any of its base types
            </summary>
            <param name="name">Method name</param>
            <returns>The method or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindFieldCheckBaseType(dnlib.DotNet.UTF8String,dnlib.DotNet.FieldSig)">
            <summary>
            Finds a field by checking this type or any of its base types
            </summary>
            <param name="name">Field name</param>
            <param name="sig">Field signature</param>
            <returns>The field or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindFieldCheckBaseType(dnlib.DotNet.UTF8String,dnlib.DotNet.FieldSig,dnlib.DotNet.SigComparerOptions)">
            <summary>
            Finds a field by checking this type or any of its base types
            </summary>
            <param name="name">Field name</param>
            <param name="sig">Field signature</param>
            <param name="options">Field signature comparison options</param>
            <returns>The field or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindFieldCheckBaseType(dnlib.DotNet.UTF8String,dnlib.DotNet.FieldSig,dnlib.DotNet.SigComparerOptions,dnlib.DotNet.ModuleDef)">
            <summary>
            Finds a field by checking this type or any of its base types
            </summary>
            <param name="name">Field name</param>
            <param name="sig">Field signature</param>
            <param name="options">Field signature comparison options</param>
            <param name="sourceModule">The module that needs to find the field or <c>null</c></param>
            <returns>The field or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindFieldCheckBaseType(dnlib.DotNet.UTF8String)">
            <summary>
            Finds a field by checking this type or any of its base types
            </summary>
            <param name="name">Field name</param>
            <returns>The field or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindEventCheckBaseType(dnlib.DotNet.UTF8String,dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Finds an event by checking this type or any of its base types
            </summary>
            <param name="name">Event name</param>
            <param name="eventType">Event type</param>
            <returns>The event or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindEventCheckBaseType(dnlib.DotNet.UTF8String)">
            <summary>
            Finds an event by checking this type or any of its base types
            </summary>
            <param name="name">Event name</param>
            <returns>The event or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindPropertyCheckBaseType(dnlib.DotNet.UTF8String,dnlib.DotNet.PropertySig)">
            <summary>
            Finds a property by checking this type or any of its base types
            </summary>
            <param name="name">Property name</param>
            <param name="sig">Property signature</param>
            <returns>The property or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindPropertyCheckBaseType(dnlib.DotNet.UTF8String,dnlib.DotNet.PropertySig,dnlib.DotNet.SigComparerOptions)">
            <summary>
            Finds a property by checking this type or any of its base types
            </summary>
            <param name="name">Property name</param>
            <param name="sig">Property signature</param>
            <param name="options">Property signature comparison options</param>
            <returns>The property or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindPropertyCheckBaseType(dnlib.DotNet.UTF8String,dnlib.DotNet.PropertySig,dnlib.DotNet.SigComparerOptions,dnlib.DotNet.ModuleDef)">
            <summary>
            Finds a property by checking this type or any of its base types
            </summary>
            <param name="name">Property name</param>
            <param name="sig">Property signature</param>
            <param name="options">Property signature comparison options</param>
            <param name="sourceModule">The module that needs to find the property or <c>null</c></param>
            <returns>The property or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindPropertyCheckBaseType(dnlib.DotNet.UTF8String)">
            <summary>
            Finds a property by checking this type or any of its base types
            </summary>
            <param name="name">Property name</param>
            <returns>The property or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.Remove(dnlib.DotNet.MethodDef)">
            <summary>
            Removes a method from this type. It also removes it from any properties and events.
            </summary>
            <param name="method">The method to remove</param>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.Remove(dnlib.DotNet.MethodDef,System.Boolean)">
            <summary>
            Removes a method from this type. It also removes it from any properties and events.
            </summary>
            <param name="method">The method to remove</param>
            <param name="removeEmptyPropertiesEvents"><c>true</c> if we should remove all
            empty properties and events.</param>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#FieldDef}#OnLazyAdd(System.Int32,dnlib.DotNet.FieldDef@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#FieldDef}#OnAdd(System.Int32,dnlib.DotNet.FieldDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#FieldDef}#OnRemove(System.Int32,dnlib.DotNet.FieldDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#FieldDef}#OnResize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#FieldDef}#OnClear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#MethodDef}#OnLazyAdd(System.Int32,dnlib.DotNet.MethodDef@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#MethodDef}#OnAdd(System.Int32,dnlib.DotNet.MethodDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#MethodDef}#OnRemove(System.Int32,dnlib.DotNet.MethodDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#MethodDef}#OnResize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#MethodDef}#OnClear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#TypeDef}#OnLazyAdd(System.Int32,dnlib.DotNet.TypeDef@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#TypeDef}#OnAdd(System.Int32,dnlib.DotNet.TypeDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#TypeDef}#OnRemove(System.Int32,dnlib.DotNet.TypeDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#TypeDef}#OnResize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#TypeDef}#OnClear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#EventDef}#OnLazyAdd(System.Int32,dnlib.DotNet.EventDef@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#EventDef}#OnAdd(System.Int32,dnlib.DotNet.EventDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#EventDef}#OnRemove(System.Int32,dnlib.DotNet.EventDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#EventDef}#OnResize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#EventDef}#OnClear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#PropertyDef}#OnLazyAdd(System.Int32,dnlib.DotNet.PropertyDef@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#PropertyDef}#OnAdd(System.Int32,dnlib.DotNet.PropertyDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#PropertyDef}#OnRemove(System.Int32,dnlib.DotNet.PropertyDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#PropertyDef}#OnResize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#PropertyDef}#OnClear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#GenericParam}#OnLazyAdd(System.Int32,dnlib.DotNet.GenericParam@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#GenericParam}#OnAdd(System.Int32,dnlib.DotNet.GenericParam)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#GenericParam}#OnRemove(System.Int32,dnlib.DotNet.GenericParam)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#GenericParam}#OnResize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.dnlib#Utils#IListListener{dnlib#DotNet#GenericParam}#OnClear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.GetFields(dnlib.DotNet.UTF8String)">
            <summary>
            Gets all fields named <paramref name="name"/>
            </summary>
            <param name="name">Field name</param>
            <returns>A list of 0 or more fields with name <paramref name="name"/></returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.GetField(dnlib.DotNet.UTF8String)">
            <summary>
            Gets the first field named <paramref name="name"/>
            </summary>
            <param name="name">Field name</param>
            <returns>The field or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.FindMethodImplMethod(dnlib.DotNet.IMethodDefOrRef)">
            <summary>
            FInd a method implementation method
            </summary>
            <param name="mdr">Method</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDef.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.TypeDefUser">
            <summary>
            A TypeDef row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeDefUser.#ctor(dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:dnlib.DotNet.TypeDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="namespace">Namespace</param>
            <param name="name">Name</param>
        </member>
        <member name="M:dnlib.DotNet.TypeDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
            <param name="baseType">Base class or <c>null</c> if it's an interface</param>
        </member>
        <member name="M:dnlib.DotNet.TypeDefUser.#ctor(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String,dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="namespace">Namespace</param>
            <param name="name">Name</param>
            <param name="baseType">Base class or <c>null</c> if it's an interface</param>
        </member>
        <member name="T:dnlib.DotNet.TypeDefMD">
            <summary>
            Created from a row in the TypeDef table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeDefMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDefMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.GetBaseType_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.InitializeFields">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.InitializeMethods">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.InitializeGenericParameters">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.InitializeInterfaces">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.InitializeDeclSecurities">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.GetClassLayout_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.GetDeclaringType2_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.InitializeEvents">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.InitializeProperties">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.InitializeNestedTypes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.GetModule2_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>TypeDef</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.GetMethodOverrides(dnlib.DotNet.MethodDefMD,dnlib.DotNet.GenericParamContext)">
            <summary>
            Gets all methods <paramref name="method"/> overrides
            </summary>
            <param name="method">The method</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A list (possibly empty) of all methods <paramref name="method"/> overrides</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.InitializeMethodSemanticsAttributes">
            <summary>
            Initializes all <see cref="F:dnlib.DotNet.MethodDef.semAttrs"/>. Only those <see cref="T:dnlib.DotNet.MethodDef"/>s
            that are property or event handlers get updated.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.InitializeProperty(dnlib.DotNet.PropertyDefMD,System.Collections.Generic.IList{dnlib.DotNet.MethodDef}@,System.Collections.Generic.IList{dnlib.DotNet.MethodDef}@,System.Collections.Generic.IList{dnlib.DotNet.MethodDef}@)">
            <summary>
            Initializes a property's special methods
            </summary>
            <param name="prop">The property</param>
            <param name="getMethods">Updated with a list of all get methods</param>
            <param name="setMethods">Updated with a list of all set methods</param>
            <param name="otherMethods">Updated with a list of all other methods</param>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.InitializeEvent(dnlib.DotNet.EventDefMD,dnlib.DotNet.MethodDef@,dnlib.DotNet.MethodDef@,dnlib.DotNet.MethodDef@,System.Collections.Generic.IList{dnlib.DotNet.MethodDef}@)">
            <summary>
            Initializes an event's special methods
            </summary>
            <param name="evt">The event</param>
            <param name="addMethod">Updated with the addOn method or <c>null</c> if none</param>
            <param name="invokeMethod">Updated with the fire method or <c>null</c> if none</param>
            <param name="removeMethod">Updated with the removeOn method or <c>null</c> if none</param>
            <param name="otherMethods">Updated with a list of all other methods</param>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.OnLazyAdd2(System.Int32,dnlib.DotNet.FieldDef@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.OnLazyAdd2(System.Int32,dnlib.DotNet.MethodDef@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.OnLazyAdd2(System.Int32,dnlib.DotNet.EventDef@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.OnLazyAdd2(System.Int32,dnlib.DotNet.PropertyDef@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefMD.OnLazyAdd2(System.Int32,dnlib.DotNet.GenericParam@)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.TypeDefFinder">
            <summary>
            Finds <see cref="T:dnlib.DotNet.TypeDef"/>s
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDefFinder.IsCacheEnabled">
            <summary>
            <c>true</c> if the <see cref="T:dnlib.DotNet.TypeDef"/> cache is enabled. <c>false</c> if the cache
            is disabled and a slower <c>O(n)</c> lookup is performed.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeDefFinder.#ctor(System.Collections.Generic.IEnumerable{dnlib.DotNet.TypeDef})">
            <summary>
            Constructor
            </summary>
            <param name="rootTypes">All root types. All their nested types are also included.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="rootTypes"/> is <c>null</c></exception>
        </member>
        <member name="M:dnlib.DotNet.TypeDefFinder.#ctor(System.Collections.Generic.IEnumerable{dnlib.DotNet.TypeDef},System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="rootTypes">All root types</param>
            <param name="includeNestedTypes"><c>true</c> if all nested types that are reachable
            from <paramref name="rootTypes"/> should also be included.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="rootTypes"/> is <c>null</c></exception>
        </member>
        <member name="M:dnlib.DotNet.TypeDefFinder.ResetCache">
            <summary>
            Resets the cache (clears all cached elements). Use this method if the cache is
            enabled but some of the types have been modified (eg. removed, added, renamed).
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeDefFinder.Find(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefFinder.Find(dnlib.DotNet.TypeRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeDefFinder.GetNextTypeDef">
            <summary>
            Gets the next <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if there are no more left
            </summary>
            <returns>The next <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDefFinder.GetNextTypeDefCache">
            <summary>
            Gets the next <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if there are no more left.
            The cache is updated with the returned <see cref="T:dnlib.DotNet.TypeDef"/> before the method
            returns.
            </summary>
            <returns>The next <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if none</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeDefFinder.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.TypeHelper">
            <summary>
            Various helper methods for <see cref="T:dnlib.DotNet.IType"/> classes to prevent infinite recursion
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeHelper.ContainsGenericParameter(dnlib.DotNet.CallingConventionSig)">
            <summary>
            Checks whether <paramref name="callConv"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
            <param name="callConv">Calling convention signature</param>
            <returns><c>true</c> if <paramref name="callConv"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/>
            or a <see cref="T:dnlib.DotNet.GenericMVar"/>.</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeHelper.ContainsGenericParameter(dnlib.DotNet.FieldSig)">
            <summary>
            Checks whether <paramref name="fieldSig"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
            <param name="fieldSig">Field signature</param>
            <returns><c>true</c> if <paramref name="fieldSig"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/>
            or a <see cref="T:dnlib.DotNet.GenericMVar"/>.</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeHelper.ContainsGenericParameter(dnlib.DotNet.MethodBaseSig)">
            <summary>
            Checks whether <paramref name="methodSig"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
            <param name="methodSig">Method or property signature</param>
            <returns><c>true</c> if <paramref name="methodSig"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/>
            or a <see cref="T:dnlib.DotNet.GenericMVar"/>.</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeHelper.ContainsGenericParameter(dnlib.DotNet.LocalSig)">
            <summary>
            Checks whether <paramref name="localSig"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
            <param name="localSig">Local signature</param>
            <returns><c>true</c> if <paramref name="localSig"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/>
            or a <see cref="T:dnlib.DotNet.GenericMVar"/>.</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeHelper.ContainsGenericParameter(dnlib.DotNet.GenericInstMethodSig)">
            <summary>
            Checks whether <paramref name="gim"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
            <param name="gim">Generic method signature</param>
            <returns><c>true</c> if <paramref name="gim"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/>
            or a <see cref="T:dnlib.DotNet.GenericMVar"/>.</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeHelper.ContainsGenericParameter(dnlib.DotNet.IType)">
            <summary>
            Checks whether <paramref name="type"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
            <param name="type">Type</param>
            <returns><c>true</c> if <paramref name="type"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeHelper.ContainsGenericParameter(dnlib.DotNet.TypeDef)">
            <summary>
            Checks whether <paramref name="type"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
            <param name="type">Type</param>
            <returns><c>true</c> if <paramref name="type"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeHelper.ContainsGenericParameter(dnlib.DotNet.TypeRef)">
            <summary>
            Checks whether <paramref name="type"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
            <param name="type">Type</param>
            <returns><c>true</c> if <paramref name="type"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeHelper.ContainsGenericParameter(dnlib.DotNet.TypeSpec)">
            <summary>
            Checks whether <paramref name="type"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
            <param name="type">Type</param>
            <returns><c>true</c> if <paramref name="type"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeHelper.ContainsGenericParameter(dnlib.DotNet.TypeSig)">
            <summary>
            Checks whether <paramref name="type"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
            <param name="type">Type</param>
            <returns><c>true</c> if <paramref name="type"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeHelper.ContainsGenericParameter(dnlib.DotNet.ExportedType)">
            <summary>
            Checks whether <paramref name="type"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
            <param name="type">Type</param>
            <returns><c>true</c> if <paramref name="type"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.</returns>
        </member>
        <member name="T:dnlib.DotNet.TypeNameParserException">
            <summary>
            Thrown by <see cref="T:dnlib.DotNet.TypeNameParser"/> when it fails to parse a type name
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParserException.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParserException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Exception message</param>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParserException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Exception message</param>
            <param name="innerException">Inner exception or <c>null</c> if none</param>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParserException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:dnlib.DotNet.IAssemblyRefFinder">
            <summary>
            Helps <see cref="T:dnlib.DotNet.TypeNameParser"/> create types
            </summary>
        </member>
        <member name="M:dnlib.DotNet.IAssemblyRefFinder.FindAssemblyRef(dnlib.DotNet.TypeRef)">
            <summary>
            Finds a <see cref="T:dnlib.DotNet.TypeRef"/>'s <see cref="T:dnlib.DotNet.AssemblyRef"/> when the original assembly
            info is missing from the full type name.
            </summary>
            <param name="nonNestedTypeRef">A non-nested <see cref="T:dnlib.DotNet.TypeRef"/></param>
            <returns><paramref name="nonNestedTypeRef"/>'s <see cref="T:dnlib.DotNet.AssemblyRef"/> or <c>null</c></returns>
        </member>
        <member name="T:dnlib.DotNet.TypeNameParser">
            <summary>
            Parses a type name and creates an <see cref="T:dnlib.DotNet.IType"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeNameParser.ownerModule">
            <summary>Owner module</summary>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.ParseReflectionThrow(dnlib.DotNet.ModuleDef,System.String,dnlib.DotNet.IAssemblyRefFinder)">
            <summary>
            Parses a Reflection type name and creates a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="ownerModule">Module that will own the returned <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> or <c>null</c></param>
            <param name="typeFullName">Full name of type</param>
            <param name="typeNameParserHelper">Helper class</param>
            <returns>A new <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> instance</returns>
            <exception cref="T:dnlib.DotNet.TypeNameParserException">If parsing failed</exception>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.ParseReflectionThrow(dnlib.DotNet.ModuleDef,System.String,dnlib.DotNet.IAssemblyRefFinder,dnlib.DotNet.GenericParamContext)">
            <summary>
            Parses a Reflection type name and creates a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="ownerModule">Module that will own the returned <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> or <c>null</c></param>
            <param name="typeFullName">Full name of type</param>
            <param name="typeNameParserHelper">Helper class</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> instance</returns>
            <exception cref="T:dnlib.DotNet.TypeNameParserException">If parsing failed</exception>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.ParseReflection(dnlib.DotNet.ModuleDef,System.String,dnlib.DotNet.IAssemblyRefFinder)">
            <summary>
            Parses a Reflection type name and creates a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="ownerModule">Module that will own the returned <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> or <c>null</c></param>
            <param name="typeFullName">Full name of type</param>
            <param name="typeNameParserHelper">Helper class</param>
            <returns>A new <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> instance or <c>null</c> if parsing failed</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.ParseReflection(dnlib.DotNet.ModuleDef,System.String,dnlib.DotNet.IAssemblyRefFinder,dnlib.DotNet.GenericParamContext)">
            <summary>
            Parses a Reflection type name and creates a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="ownerModule">Module that will own the returned <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> or <c>null</c></param>
            <param name="typeFullName">Full name of type</param>
            <param name="typeNameParserHelper">Helper class</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.ITypeDefOrRef"/> instance or <c>null</c> if parsing failed</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.ParseAsTypeSigReflectionThrow(dnlib.DotNet.ModuleDef,System.String,dnlib.DotNet.IAssemblyRefFinder)">
            <summary>
            Parses a Reflection type name and creates a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="ownerModule">Module that will own the returned <see cref="T:dnlib.DotNet.TypeSig"/> or <c>null</c></param>
            <param name="typeFullName">Full name of type</param>
            <param name="typeNameParserHelper">Helper class</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance</returns>
            <exception cref="T:dnlib.DotNet.TypeNameParserException">If parsing failed</exception>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.ParseAsTypeSigReflectionThrow(dnlib.DotNet.ModuleDef,System.String,dnlib.DotNet.IAssemblyRefFinder,dnlib.DotNet.GenericParamContext)">
            <summary>
            Parses a Reflection type name and creates a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="ownerModule">Module that will own the returned <see cref="T:dnlib.DotNet.TypeSig"/> or <c>null</c></param>
            <param name="typeFullName">Full name of type</param>
            <param name="typeNameParserHelper">Helper class</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance</returns>
            <exception cref="T:dnlib.DotNet.TypeNameParserException">If parsing failed</exception>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.ParseAsTypeSigReflection(dnlib.DotNet.ModuleDef,System.String,dnlib.DotNet.IAssemblyRefFinder)">
            <summary>
            Parses a Reflection type name and creates a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="ownerModule">Module that will own the returned <see cref="T:dnlib.DotNet.TypeSig"/> or <c>null</c></param>
            <param name="typeFullName">Full name of type</param>
            <param name="typeNameParserHelper">Helper class</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if parsing failed</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.ParseAsTypeSigReflection(dnlib.DotNet.ModuleDef,System.String,dnlib.DotNet.IAssemblyRefFinder,dnlib.DotNet.GenericParamContext)">
            <summary>
            Parses a Reflection type name and creates a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <param name="ownerModule">Module that will own the returned <see cref="T:dnlib.DotNet.TypeSig"/> or <c>null</c></param>
            <param name="typeFullName">Full name of type</param>
            <param name="typeNameParserHelper">Helper class</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance or <c>null</c> if parsing failed</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.#ctor(dnlib.DotNet.ModuleDef,System.String,dnlib.DotNet.IAssemblyRefFinder)">
            <summary>
            Constructor
            </summary>
            <param name="ownerModule">Module that will own the returned <see cref="T:dnlib.DotNet.IType"/> or <c>null</c></param>
            <param name="typeFullName">Full name of type</param>
            <param name="typeNameParserHelper">Helper class</param>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.#ctor(dnlib.DotNet.ModuleDef,System.String,dnlib.DotNet.IAssemblyRefFinder,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="ownerModule">Module that will own the returned <see cref="T:dnlib.DotNet.IType"/> or <c>null</c></param>
            <param name="typeFullName">Full name of type</param>
            <param name="typeNameParserHelper">Helper class</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.Parse">
            <summary>
            Parses a type name and creates a <see cref="T:dnlib.DotNet.IType"/>
            </summary>
            <returns>A new <see cref="T:dnlib.DotNet.IType"/> instance</returns>
            <exception cref="T:dnlib.DotNet.TypeNameParserException">If parsing failed</exception>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.ParseAsTypeSig">
            <summary>
            Parses a type name and creates a <see cref="T:dnlib.DotNet.TypeSig"/>
            </summary>
            <returns>A new <see cref="T:dnlib.DotNet.TypeSig"/> instance</returns>
            <exception cref="T:dnlib.DotNet.TypeNameParserException">If parsing failed</exception>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.RecursionIncrement">
            <summary>
            Increment recursion counter
            </summary>
            <exception cref="T:dnlib.DotNet.TypeNameParserException">If this method has been called too many times</exception>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.RecursionDecrement">
            <summary>
            Decrement recursion counter
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.Dispose(System.Boolean)">
            <summary>
            Dispose method
            </summary>
            <param name="disposing"><c>true</c> if called by <see cref="M:dnlib.DotNet.TypeNameParser.Dispose"/></param>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.ReadTypeRefAndNestedNoAssembly(System.Char)">
            <summary>
            Reads a <see cref="T:dnlib.DotNet.TypeRef"/> including any possible nested <see cref="T:dnlib.DotNet.TypeRef"/>s.
            </summary>
            <param name="nestedChar">Character separating nested types</param>
            <returns>A new <see cref="T:dnlib.DotNet.TypeRef"/> instance, which could be nested.</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.ReadTypeRefNoAssembly">
            <summary>
            Reads a namespace and name and creates a TypeRef. Does not read any nested types.
            </summary>
            <returns>A new <see cref="T:dnlib.DotNet.TypeRef"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.PeekChar">
            <summary>
            Peeks the next char. -1 if no more chars.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.ReadChar">
            <summary>
            Gets the next char or -1 if no more chars
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeNameParser.GetIdChar(System.Boolean)">
            <summary>
            Gets the next ID char or <c>-1</c> if no more ID chars
            </summary>
            <param name="ignoreWhiteSpace"><c>true</c> if white space should be ignored</param>
        </member>
        <member name="T:dnlib.DotNet.ReflectionTypeNameParser">
            <summary>
            Parses reflection type names. Grammar http://msdn.microsoft.com/en-us/library/yfsftwz6.aspx
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ReflectionTypeNameParser.#ctor(dnlib.DotNet.ModuleDef,System.String,dnlib.DotNet.IAssemblyRefFinder)">
            <summary>
            Constructor
            </summary>
            <param name="ownerModule">Module that will own the returned <see cref="T:dnlib.DotNet.IType"/> or <c>null</c></param>
            <param name="typeFullName">Full name of type</param>
            <param name="typeNameParserHelper">Helper class</param>
        </member>
        <member name="M:dnlib.DotNet.ReflectionTypeNameParser.#ctor(dnlib.DotNet.ModuleDef,System.String,dnlib.DotNet.IAssemblyRefFinder,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="ownerModule">Module that will own the returned <see cref="T:dnlib.DotNet.IType"/> or <c>null</c></param>
            <param name="typeFullName">Full name of type</param>
            <param name="typeNameParserHelper">Helper class</param>
            <param name="gpContext">Generic parameter context</param>
        </member>
        <member name="M:dnlib.DotNet.ReflectionTypeNameParser.ParseAssemblyRef(System.String)">
            <summary>
            Parses an assembly name
            </summary>
            <param name="asmFullName">Full assembly name</param>
            <returns>A new <see cref="T:dnlib.DotNet.AssemblyRef"/> instance or <c>null</c> if parsing failed</returns>
        </member>
        <member name="M:dnlib.DotNet.ReflectionTypeNameParser.ParseAssemblyRef(System.String,dnlib.DotNet.GenericParamContext)">
            <summary>
            Parses an assembly name
            </summary>
            <param name="asmFullName">Full assembly name</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>A new <see cref="T:dnlib.DotNet.AssemblyRef"/> instance or <c>null</c> if parsing failed</returns>
        </member>
        <member name="M:dnlib.DotNet.ReflectionTypeNameParser.ParseAsTypeSig">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.TypeRef">
            <summary>
            A high-level representation of a row in the TypeRef table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeRef.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeRef.module">
            <summary>
            The owner module
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.TypeDefOrRefTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.MemberRefParentTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.ResolutionScopeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.dnlib#DotNet#IGenericParameterProvider#NumberOfGenericParameters">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.dnlib#DotNet#IType#TypeName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.ReflectionName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.dnlib#DotNet#IType#Namespace">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.ReflectionNamespace">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.FullName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.ReflectionFullName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.AssemblyQualifiedName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.DefinitionAssembly">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.Scope">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.ScopeType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.ContainsGenericParameter">
            <summary>
            Always returns <c>false</c> since a <see cref="T:dnlib.DotNet.TypeRef"/> does not contain any
            <see cref="T:dnlib.DotNet.GenericVar"/> or <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.ResolutionScope">
            <summary>
            From column TypeRef.ResolutionScope
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeRef.resolutionScope">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.TypeRef.resolutionScope_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeRef.GetResolutionScope_NoLock">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.TypeRef.resolutionScope"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.Name">
            <summary>
            From column TypeRef.Name
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeRef.name">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.Namespace">
            <summary>
            From column TypeRef.Namespace
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeRef.namespace">
            <summary>Name</summary>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeRef.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeRef.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeRef.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeRef.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeRef.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeRef.customDebugInfos"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.IsNested">
            <summary>
            <c>true</c> if it's nested within another <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.IsValueType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.IsPrimitive">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.DeclaringType">
            <summary>
            Gets the declaring type, if any
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeRef.dnlib#DotNet#IMemberRef#DeclaringType">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeRef.Resolve">
            <summary>
            Resolves the type
            </summary>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeRef.Resolve(dnlib.DotNet.ModuleDef)">
            <summary>
            Resolves the type
            </summary>
            <param name="sourceModule">The module that needs to resolve the type or <c>null</c></param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
        </member>
        <member name="M:dnlib.DotNet.TypeRef.ResolveThrow">
            <summary>
            Resolves the type
            </summary>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> instance</returns>
            <exception cref="T:dnlib.DotNet.TypeResolveException">If the type couldn't be resolved</exception>
        </member>
        <member name="M:dnlib.DotNet.TypeRef.ResolveThrow(dnlib.DotNet.ModuleDef)">
            <summary>
            Resolves the type
            </summary>
            <param name="sourceModule">The module that needs to resolve the type or <c>null</c></param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> instance</returns>
            <exception cref="T:dnlib.DotNet.TypeResolveException">If the type couldn't be resolved</exception>
        </member>
        <member name="M:dnlib.DotNet.TypeRef.GetNonNestedTypeRef(dnlib.DotNet.TypeRef)">
            <summary>
            Gets the top-most (non-nested) <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="typeRef">Input</param>
            <returns>The non-nested <see cref="T:dnlib.DotNet.TypeRef"/> or <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.TypeRef.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.TypeRefUser">
            <summary>
            A TypeRef row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeRefUser.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
            <param name="name">Type name</param>
        </member>
        <member name="M:dnlib.DotNet.TypeRefUser.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
            <param name="namespace">Type namespace</param>
            <param name="name">Type name</param>
        </member>
        <member name="M:dnlib.DotNet.TypeRefUser.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String,dnlib.DotNet.IResolutionScope)">
            <summary>
            Constructor
            </summary>
            <param name="module">Owner module</param>
            <param name="namespace">Type namespace</param>
            <param name="name">Type name</param>
            <param name="resolutionScope">Resolution scope (a <see cref="T:dnlib.DotNet.ModuleDef"/>,
            <see cref="T:dnlib.DotNet.ModuleRef"/>, <see cref="T:dnlib.DotNet.AssemblyRef"/> or <see cref="T:dnlib.DotNet.TypeRef"/>)</param>
        </member>
        <member name="T:dnlib.DotNet.TypeRefMD">
            <summary>
            Created from a row in the TypeRef table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeRefMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.TypeRefMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeRefMD.GetResolutionScope_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeRefMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeRefMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeRefMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>TypeRef</c> row</param>
            <param name="rid">Row ID</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.TypeSig">
            <summary>
            Type sig base class
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.Next">
            <summary>
            Returns the wrapped element type. Can only be <c>null</c> if it was an invalid sig or
            if it's a <see cref="T:dnlib.DotNet.LeafSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.ElementType">
            <summary>
            Gets the element type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.dnlib#DotNet#IIsTypeOrMethod#IsMethod">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.dnlib#DotNet#IIsTypeOrMethod#IsType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.dnlib#DotNet#IGenericParameterProvider#NumberOfGenericParameters">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsValueType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsPrimitive">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.TypeName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.dnlib#DotNet#IFullName#Name">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.ReflectionName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.Namespace">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.ReflectionNamespace">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.FullName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.ReflectionFullName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.AssemblyQualifiedName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.DefinitionAssembly">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.Scope">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.ScopeType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsTypeDefOrRef">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.TypeDefOrRefSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsCorLibType">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.CorLibTypeSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsClassSig">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.ClassSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsValueTypeSig">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.ValueTypeSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsGenericParameter">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.GenericSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsGenericTypeParameter">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.GenericVar"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsGenericMethodParameter">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.GenericMVar"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsSentinel">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.SentinelSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsFunctionPointer">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.FnPtrSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsGenericInstanceType">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.GenericInstSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsPointer">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.PtrSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsByRef">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.ByRefSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsSingleOrMultiDimensionalArray">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.ArraySig"/> or a <see cref="T:dnlib.DotNet.SZArraySig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsArray">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.ArraySig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsSZArray">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.SZArraySig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsModifier">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.ModifierSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsRequiredModifier">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.CModReqdSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsOptionalModifier">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.CModOptSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsPinned">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.PinnedSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsValueArray">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.ValueArraySig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.IsModuleSig">
            <summary>
            <c>true</c> if it's a <see cref="T:dnlib.DotNet.ModuleSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSig.ContainsGenericParameter">
            <summary>
            <c>true</c> if this <see cref="T:dnlib.DotNet.TypeSig"/> contains a <see cref="T:dnlib.DotNet.GenericVar"/> or a
            <see cref="T:dnlib.DotNet.GenericMVar"/>.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeSig.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.LeafSig">
            <summary>
            Base class for element types that are last in a type sig, ie.,
            <see cref="T:dnlib.DotNet.TypeDefOrRefSig"/>, <see cref="T:dnlib.DotNet.GenericSig"/>, <see cref="T:dnlib.DotNet.SentinelSig"/>,
            <see cref="T:dnlib.DotNet.FnPtrSig"/>, <see cref="T:dnlib.DotNet.GenericInstSig"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.LeafSig.Next">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.TypeDefOrRefSig">
            <summary>
            Wraps a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDefOrRefSig.TypeDefOrRef">
            <summary>
            Gets the the <c>TypeDefOrRef</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDefOrRefSig.IsTypeRef">
            <summary>
            Returns <c>true</c> if <see cref="P:dnlib.DotNet.TypeDefOrRefSig.TypeRef"/> != <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDefOrRefSig.IsTypeDef">
            <summary>
            Returns <c>true</c> if <see cref="P:dnlib.DotNet.TypeDefOrRefSig.TypeDef"/> != <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDefOrRefSig.IsTypeSpec">
            <summary>
            Returns <c>true</c> if <see cref="P:dnlib.DotNet.TypeDefOrRefSig.TypeSpec"/> != <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDefOrRefSig.TypeRef">
            <summary>
            Gets the <see cref="P:dnlib.DotNet.TypeDefOrRefSig.TypeRef"/> or <c>null</c> if it's not a <see cref="P:dnlib.DotNet.TypeDefOrRefSig.TypeRef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDefOrRefSig.TypeDef">
            <summary>
            Gets the <see cref="P:dnlib.DotNet.TypeDefOrRefSig.TypeDef"/> or <c>null</c> if it's not a <see cref="P:dnlib.DotNet.TypeDefOrRefSig.TypeDef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeDefOrRefSig.TypeSpec">
            <summary>
            Gets the <see cref="P:dnlib.DotNet.TypeDefOrRefSig.TypeSpec"/> or <c>null</c> if it's not a <see cref="P:dnlib.DotNet.TypeDefOrRefSig.TypeSpec"/>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeDefOrRefSig.#ctor(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="typeDefOrRef">A <see cref="P:dnlib.DotNet.TypeDefOrRefSig.TypeRef"/>, <see cref="P:dnlib.DotNet.TypeDefOrRefSig.TypeDef"/> or
            a <see cref="P:dnlib.DotNet.TypeDefOrRefSig.TypeSpec"/></param>
        </member>
        <member name="T:dnlib.DotNet.CorLibTypeSig">
            <summary>
            A core library type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CorLibTypeSig.ElementType">
            <summary>
            Gets the element type
            </summary>
        </member>
        <member name="M:dnlib.DotNet.CorLibTypeSig.#ctor(dnlib.DotNet.ITypeDefOrRef,dnlib.DotNet.ElementType)">
            <summary>
            Constructor
            </summary>
            <param name="corType">The type which must be a <see cref="T:dnlib.DotNet.TypeRef"/> or a
            <see cref="T:dnlib.DotNet.TypeDef"/>. <see cref="T:dnlib.DotNet.TypeSpec"/> and <c>null</c> are not allowed.</param>
            <param name="elementType">The type's element type</param>
        </member>
        <member name="T:dnlib.DotNet.ClassOrValueTypeSig">
            <summary>
            Base class for class/valuetype element types
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ClassOrValueTypeSig.#ctor(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="typeDefOrRef">A <see cref="T:dnlib.DotNet.ITypeDefOrRef"/></param>
        </member>
        <member name="T:dnlib.DotNet.ValueTypeSig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.ValueType"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ValueTypeSig.ElementType">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ValueTypeSig.#ctor(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="typeDefOrRef">A <see cref="T:dnlib.DotNet.ITypeDefOrRef"/></param>
        </member>
        <member name="T:dnlib.DotNet.ClassSig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.Class"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ClassSig.ElementType">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ClassSig.#ctor(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Constructor
            </summary>
            <param name="typeDefOrRef">A <see cref="T:dnlib.DotNet.ITypeDefOrRef"/></param>
        </member>
        <member name="T:dnlib.DotNet.GenericSig">
            <summary>
            Generic method/type var base class
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericSig.HasOwner">
            <summary>
            <c>true</c> if it has an owner <see cref="T:dnlib.DotNet.TypeDef"/> or <see cref="T:dnlib.DotNet.MethodDef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericSig.HasOwnerType">
            <summary>
            <c>true</c> if it has an owner <see cref="T:dnlib.DotNet.TypeDef"/> (<see cref="P:dnlib.DotNet.GenericSig.OwnerType"/> is
            not <c>null</c>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericSig.HasOwnerMethod">
            <summary>
            <c>true</c> if it has an owner <see cref="T:dnlib.DotNet.MethodDef"/> (<see cref="P:dnlib.DotNet.GenericSig.OwnerMethod"/> is
            not <c>null</c>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericSig.OwnerType">
            <summary>
            Gets the owner type or <c>null</c> if the owner is a <see cref="T:dnlib.DotNet.MethodDef"/> or if it
            has no owner.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericSig.OwnerMethod">
            <summary>
            Gets the owner method or <c>null</c> if the owner is a <see cref="T:dnlib.DotNet.TypeDef"/> or if it
            has no owner.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericSig.Number">
            <summary>
            Gets the generic param number
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericSig.GenericParam">
            <summary>
            Gets the corresponding <see cref="T:dnlib.DotNet.GenericParam"/> or <c>null</c> if none exists.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.GenericSig.#ctor(System.Boolean,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="isTypeVar"><c>true</c> if it's a <c>Var</c>, <c>false</c> if it's a <c>MVar</c></param>
            <param name="number">Generic param number</param>
        </member>
        <member name="M:dnlib.DotNet.GenericSig.#ctor(System.Boolean,System.UInt32,dnlib.DotNet.ITypeOrMethodDef)">
            <summary>
            Constructor
            </summary>
            <param name="isTypeVar"><c>true</c> if it's a <c>Var</c>, <c>false</c> if it's a <c>MVar</c></param>
            <param name="number">Generic param number</param>
            <param name="genericParamProvider">Owner method/type or <c>null</c></param>
        </member>
        <member name="P:dnlib.DotNet.GenericSig.IsMethodVar">
            <summary>
            Returns <c>true</c> if it's a <c>MVar</c> element type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericSig.IsTypeVar">
            <summary>
            Returns <c>true</c> if it's a <c>Var</c> element type
            </summary>
        </member>
        <member name="T:dnlib.DotNet.GenericVar">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.Var"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericVar.ElementType">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericVar.#ctor(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericVar.#ctor(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericVar.#ctor(System.UInt32,dnlib.DotNet.TypeDef)">
            <summary>
            Constructor
            </summary>
            <param name="number">Generic parameter number</param>
            <param name="genericParamProvider">Owner type or <c>null</c></param>
        </member>
        <member name="M:dnlib.DotNet.GenericVar.#ctor(System.Int32,dnlib.DotNet.TypeDef)">
            <summary>
            Constructor
            </summary>
            <param name="number">Generic parameter number</param>
            <param name="genericParamProvider">Owner type or <c>null</c></param>
        </member>
        <member name="T:dnlib.DotNet.GenericMVar">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.MVar"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericMVar.ElementType">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericMVar.#ctor(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericMVar.#ctor(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.GenericMVar.#ctor(System.UInt32,dnlib.DotNet.MethodDef)">
            <summary>
            Constructor
            </summary>
            <param name="number">Generic parameter number</param>
            <param name="genericParamProvider">Owner method or <c>null</c></param>
        </member>
        <member name="M:dnlib.DotNet.GenericMVar.#ctor(System.Int32,dnlib.DotNet.MethodDef)">
            <summary>
            Constructor
            </summary>
            <param name="number">Generic parameter number</param>
            <param name="genericParamProvider">Owner method or <c>null</c></param>
        </member>
        <member name="T:dnlib.DotNet.SentinelSig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.Sentinel"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.SentinelSig.ElementType">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.FnPtrSig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.FnPtr"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FnPtrSig.ElementType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.FnPtrSig.Signature">
            <summary>
            Gets the signature
            </summary>
        </member>
        <member name="P:dnlib.DotNet.FnPtrSig.MethodSig">
            <summary>
            Gets the <see cref="P:dnlib.DotNet.FnPtrSig.MethodSig"/>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.FnPtrSig.#ctor(dnlib.DotNet.CallingConventionSig)">
            <summary>
            Constructor
            </summary>
            <param name="signature">The method signature</param>
        </member>
        <member name="T:dnlib.DotNet.GenericInstSig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.GenericInst"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericInstSig.ElementType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.GenericInstSig.GenericType">
            <summary>
            Gets the generic type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.GenericInstSig.GenericArguments">
            <summary>
            Gets the generic arguments (it's never <c>null</c>)
            </summary>
        </member>
        <member name="M:dnlib.DotNet.GenericInstSig.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.GenericInstSig.#ctor(dnlib.DotNet.ClassOrValueTypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="genericType">The generic type</param>
        </member>
        <member name="M:dnlib.DotNet.GenericInstSig.#ctor(dnlib.DotNet.ClassOrValueTypeSig,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="genericType">The generic type</param>
            <param name="genArgCount">Number of generic arguments</param>
        </member>
        <member name="M:dnlib.DotNet.GenericInstSig.#ctor(dnlib.DotNet.ClassOrValueTypeSig,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="genericType">The generic type</param>
            <param name="genArgCount">Number of generic arguments</param>
        </member>
        <member name="M:dnlib.DotNet.GenericInstSig.#ctor(dnlib.DotNet.ClassOrValueTypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="genericType">The generic type</param>
            <param name="genArg1">Generic argument #1</param>
        </member>
        <member name="M:dnlib.DotNet.GenericInstSig.#ctor(dnlib.DotNet.ClassOrValueTypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="genericType">The generic type</param>
            <param name="genArg1">Generic argument #1</param>
            <param name="genArg2">Generic argument #2</param>
        </member>
        <member name="M:dnlib.DotNet.GenericInstSig.#ctor(dnlib.DotNet.ClassOrValueTypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="genericType">The generic type</param>
            <param name="genArg1">Generic argument #1</param>
            <param name="genArg2">Generic argument #2</param>
            <param name="genArg3">Generic argument #3</param>
        </member>
        <member name="M:dnlib.DotNet.GenericInstSig.#ctor(dnlib.DotNet.ClassOrValueTypeSig,dnlib.DotNet.TypeSig[])">
            <summary>
            Constructor
            </summary>
            <param name="genericType">The generic type</param>
            <param name="genArgs">Generic arguments</param>
        </member>
        <member name="M:dnlib.DotNet.GenericInstSig.#ctor(dnlib.DotNet.ClassOrValueTypeSig,System.Collections.Generic.IList{dnlib.DotNet.TypeSig})">
            <summary>
            Constructor
            </summary>
            <param name="genericType">The generic type</param>
            <param name="genArgs">Generic arguments</param>
        </member>
        <member name="T:dnlib.DotNet.NonLeafSig">
            <summary>
            Base class of non-leaf element types
            </summary>
        </member>
        <member name="P:dnlib.DotNet.NonLeafSig.Next">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.NonLeafSig.#ctor(dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="nextSig">Next sig</param>
        </member>
        <member name="T:dnlib.DotNet.PtrSig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.Ptr"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PtrSig.ElementType">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.PtrSig.#ctor(dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="nextSig">The next element type</param>
        </member>
        <member name="T:dnlib.DotNet.ByRefSig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.ByRef"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ByRefSig.ElementType">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ByRefSig.#ctor(dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="nextSig">The next element type</param>
        </member>
        <member name="T:dnlib.DotNet.ArraySigBase">
            <summary>
            Array base class
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ArraySigBase.#ctor(dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="arrayType">Array type</param>
        </member>
        <member name="P:dnlib.DotNet.ArraySigBase.IsMultiDimensional">
            <summary>
            <c>true</c> if it's a multi-dimensional array (i.e., <see cref="T:dnlib.DotNet.ArraySig"/>),
            and <c>false</c> if it's a single-dimensional array (i.e., <see cref="T:dnlib.DotNet.SZArraySig"/>)
            </summary>
            <seealso cref="P:dnlib.DotNet.ArraySigBase.IsSingleDimensional"/>
        </member>
        <member name="P:dnlib.DotNet.ArraySigBase.IsSingleDimensional">
            <summary>
            <c>true</c> if it's a single-dimensional array (i.e., <see cref="T:dnlib.DotNet.SZArraySig"/>),
            and <c>false</c> if it's a multi-dimensional array (i.e., <see cref="T:dnlib.DotNet.ArraySig"/>)
            </summary>
            <see cref="P:dnlib.DotNet.ArraySigBase.IsMultiDimensional"/>
        </member>
        <member name="P:dnlib.DotNet.ArraySigBase.Rank">
            <summary>
            Gets/sets the rank (number of dimensions). This can only be set if
            <see cref="P:dnlib.DotNet.ArraySigBase.IsMultiDimensional"/> is <c>true</c>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ArraySigBase.GetSizes">
            <summary>
            Gets all sizes. If it's a <see cref="T:dnlib.DotNet.SZArraySig"/>, then it will be an empty temporary
            list that is re-created every time this method is called.
            </summary>
            <returns>A list of sizes</returns>
        </member>
        <member name="M:dnlib.DotNet.ArraySigBase.GetLowerBounds">
            <summary>
            Gets all lower bounds. If it's a <see cref="T:dnlib.DotNet.SZArraySig"/>, then it will be an empty
            temporary list that is re-created every time this method is called.
            </summary>
            <returns>A list of lower bounds</returns>
        </member>
        <member name="T:dnlib.DotNet.ArraySig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.Array"/>
            </summary>
            <seealso cref="T:dnlib.DotNet.SZArraySig"/>
        </member>
        <member name="P:dnlib.DotNet.ArraySig.ElementType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ArraySig.Rank">
            <summary>
            Gets/sets the rank (max value is <c>0x1FFFFFFF</c>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ArraySig.Sizes">
            <summary>
            Gets all sizes (max elements is <c>0x1FFFFFFF</c>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ArraySig.LowerBounds">
            <summary>
            Gets all lower bounds (max elements is <c>0x1FFFFFFF</c>)
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ArraySig.#ctor(dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="arrayType">Array type</param>
        </member>
        <member name="M:dnlib.DotNet.ArraySig.#ctor(dnlib.DotNet.TypeSig,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="arrayType">Array type</param>
            <param name="rank">Array rank</param>
        </member>
        <member name="M:dnlib.DotNet.ArraySig.#ctor(dnlib.DotNet.TypeSig,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="arrayType">Array type</param>
            <param name="rank">Array rank</param>
        </member>
        <member name="M:dnlib.DotNet.ArraySig.#ctor(dnlib.DotNet.TypeSig,System.UInt32,System.Collections.Generic.IEnumerable{System.UInt32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Constructor
            </summary>
            <param name="arrayType">Array type</param>
            <param name="rank">Array rank</param>
            <param name="sizes">Sizes list. <c>This instance will be the owner of this list.</c></param>
            <param name="lowerBounds">Lower bounds list. <c>This instance will be the owner of this list.</c></param>
        </member>
        <member name="M:dnlib.DotNet.ArraySig.#ctor(dnlib.DotNet.TypeSig,System.Int32,System.Collections.Generic.IEnumerable{System.UInt32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Constructor
            </summary>
            <param name="arrayType">Array type</param>
            <param name="rank">Array rank</param>
            <param name="sizes">Sizes list. <c>This instance will be the owner of this list.</c></param>
            <param name="lowerBounds">Lower bounds list. <c>This instance will be the owner of this list.</c></param>
        </member>
        <member name="M:dnlib.DotNet.ArraySig.#ctor(dnlib.DotNet.TypeSig,System.UInt32,System.Collections.Generic.IList{System.UInt32},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Constructor
            </summary>
            <param name="arrayType">Array type</param>
            <param name="rank">Array rank</param>
            <param name="sizes">Sizes list. <c>This instance will be the owner of this list.</c></param>
            <param name="lowerBounds">Lower bounds list. <c>This instance will be the owner of this list.</c></param>
        </member>
        <member name="M:dnlib.DotNet.ArraySig.GetSizes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ArraySig.GetLowerBounds">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.SZArraySig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.SZArray"/> (single dimension, zero lower bound array)
            </summary>
            <seealso cref="T:dnlib.DotNet.ArraySig"/>
        </member>
        <member name="P:dnlib.DotNet.SZArraySig.ElementType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.SZArraySig.Rank">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SZArraySig.#ctor(dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="nextSig">The next element type</param>
        </member>
        <member name="M:dnlib.DotNet.SZArraySig.GetSizes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.SZArraySig.GetLowerBounds">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.ModifierSig">
            <summary>
            Base class for modifier type sigs
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModifierSig.Modifier">
            <summary>
            Returns the modifier type
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModifierSig.#ctor(dnlib.DotNet.ITypeDefOrRef,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="modifier">Modifier type</param>
            <param name="nextSig">The next element type</param>
        </member>
        <member name="T:dnlib.DotNet.CModReqdSig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.CModReqd"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CModReqdSig.ElementType">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.CModReqdSig.#ctor(dnlib.DotNet.ITypeDefOrRef,dnlib.DotNet.TypeSig)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.CModOptSig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.CModOpt"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.CModOptSig.ElementType">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.CModOptSig.#ctor(dnlib.DotNet.ITypeDefOrRef,dnlib.DotNet.TypeSig)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.PinnedSig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.Pinned"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.PinnedSig.ElementType">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.PinnedSig.#ctor(dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="nextSig">The next element type</param>
        </member>
        <member name="T:dnlib.DotNet.ValueArraySig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.ValueArray"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ValueArraySig.ElementType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ValueArraySig.Size">
            <summary>
            Gets/sets the size
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ValueArraySig.#ctor(dnlib.DotNet.TypeSig,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="nextSig">The next element type</param>
            <param name="size">Size of the array</param>
        </member>
        <member name="T:dnlib.DotNet.ModuleSig">
            <summary>
            Represents a <see cref="F:dnlib.DotNet.ElementType.Module"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.ModuleSig.ElementType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.ModuleSig.Index">
            <summary>
            Gets/sets the index
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ModuleSig.#ctor(System.UInt32,dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="index">Index</param>
            <param name="nextSig">The next element type</param>
        </member>
        <member name="T:dnlib.DotNet.TypeSpec">
            <summary>
            A high-level representation of a row in the TypeSpec table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeSpec.rid">
            <summary>
            The row id in its table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.MDToken">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.Rid">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.TypeDefOrRefTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.HasCustomAttributeTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.MemberRefParentTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.dnlib#DotNet#IGenericParameterProvider#NumberOfGenericParameters">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.dnlib#DotNet#IFullName#Name">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.dnlib#DotNet#IMemberRef#DeclaringType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.IsValueType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.IsPrimitive">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.TypeName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.ReflectionName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.dnlib#DotNet#IType#Namespace">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.ReflectionNamespace">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.FullName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.ReflectionFullName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.AssemblyQualifiedName">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.DefinitionAssembly">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.Scope">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.ScopeType">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.ContainsGenericParameter">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.TypeSig">
            <summary>
            From column TypeSpec.Signature
            </summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.ExtraData">
            <summary>
            Gets/sets the extra data that was found after the signature
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeSpec.typeSig">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.TypeSpec.extraData">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.TypeSpec.typeSigAndExtraData_isInitialized">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeSpec.GetTypeSigAndExtraData_NoLock(System.Byte[]@)">
            <summary>Called to initialize <see cref="F:dnlib.DotNet.TypeSpec.typeSig"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.CustomAttributes">
            <summary>
            Gets all custom attributes
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeSpec.customAttributes">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeSpec.InitializeCustomAttributes">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeSpec.customAttributes"/></summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.HasCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.HasCustomDebugInformationTag">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.HasCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.TypeSpec.CustomDebugInfos">
            <summary>
            Gets all custom debug infos
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeSpec.customDebugInfos">
            <summary/>
        </member>
        <member name="M:dnlib.DotNet.TypeSpec.InitializeCustomDebugInfos">
            <summary>Initializes <see cref="F:dnlib.DotNet.TypeSpec.customDebugInfos"/></summary>
        </member>
        <member name="M:dnlib.DotNet.TypeSpec.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.TypeSpecUser">
            <summary>
            A TypeSpec row created by the user and not present in the original .NET file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeSpecUser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.TypeSpecUser.#ctor(dnlib.DotNet.TypeSig)">
            <summary>
            Constructor
            </summary>
            <param name="typeSig">A type sig</param>
        </member>
        <member name="T:dnlib.DotNet.TypeSpecMD">
            <summary>
            Created from a row in the TypeSpec table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.TypeSpecMD.readerModule">
            <summary>The module where this instance is located</summary>
        </member>
        <member name="P:dnlib.DotNet.TypeSpecMD.OrigRid">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeSpecMD.GetTypeSigAndExtraData_NoLock(System.Byte[]@)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeSpecMD.InitializeCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeSpecMD.InitializeCustomDebugInfos">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.TypeSpecMD.#ctor(dnlib.DotNet.ModuleDefMD,System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Constructor
            </summary>
            <param name="readerModule">The module which contains this <c>TypeSpec</c> row</param>
            <param name="rid">Row ID</param>
            <param name="gpContext">Generic parameter context</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="rid"/> is invalid</exception>
        </member>
        <member name="T:dnlib.DotNet.UTF8StringEqualityComparer">
            <summary>
            Compares <see cref="T:dnlib.DotNet.UTF8String"/>s
            </summary>
        </member>
        <member name="F:dnlib.DotNet.UTF8StringEqualityComparer.Instance">
            <summary>
            The default instance
            </summary>
        </member>
        <member name="M:dnlib.DotNet.UTF8StringEqualityComparer.Equals(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.UTF8StringEqualityComparer.GetHashCode(dnlib.DotNet.UTF8String)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.UTF8String">
            <summary>
            A UTF-8 encoded string where the original data is kept in memory to avoid conversions
            when the data is not really valid UTF-8 encoded data
            </summary>
            <remarks>When comparing strings, a byte compare is performed. The reason is that this
            is what the CLR does when comparing strings in the #Strings stream.</remarks>
        </member>
        <member name="F:dnlib.DotNet.UTF8String.Empty">
            <summary>
            An empty <see cref="T:dnlib.DotNet.UTF8String"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.UTF8String.String">
            <summary>
            Gets the value as a UTF8 decoded string. Only use it for display purposes,
            not for serialization.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.UTF8String.Data">
            <summary>
            Gets the original encoded data. Don't modify this data.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.UTF8String.Length">
            <summary>
            Gets the length of the this as a <see cref="T:System.String"/>. I.e., it's the same as
            <c>String.Length</c>.
            </summary>
            <seealso cref="P:dnlib.DotNet.UTF8String.DataLength"/>
        </member>
        <member name="P:dnlib.DotNet.UTF8String.DataLength">
            <summary>
            Gets the length of the raw data. It's the same as <c>Data.Length</c>
            </summary>
            <seealso cref="P:dnlib.DotNet.UTF8String.Length"/>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.IsNull(dnlib.DotNet.UTF8String)">
            <summary>
            Checks whether <paramref name="utf8"/> is <c>null</c> or if its data is <c>null</c>.
            </summary>
            <param name="utf8">The instance to check</param>
            <returns><c>true</c> if <c>null</c> or empty, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.IsNullOrEmpty(dnlib.DotNet.UTF8String)">
            <summary>
            Checks whether <paramref name="utf8"/> is <c>null</c> or if its data is <c>null</c> or the
            data is zero length.
            </summary>
            <param name="utf8">The instance to check</param>
            <returns><c>true</c> if <c>null</c> or empty, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.op_Implicit(dnlib.DotNet.UTF8String)~System.String">
            <summary>Implicit conversion from <see cref="T:dnlib.DotNet.UTF8String"/> to <see cref="T:System.String"/></summary>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.op_Implicit(System.String)~dnlib.DotNet.UTF8String">
            <summary>Implicit conversion from <see cref="T:System.String"/> to <see cref="T:dnlib.DotNet.UTF8String"/></summary>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.ToSystemString(dnlib.DotNet.UTF8String)">
            <summary>
            Converts it to a <see cref="T:System.String"/>
            </summary>
            <param name="utf8">The UTF-8 string instace or <c>null</c></param>
            <returns>A <see cref="T:System.String"/> or <c>null</c> if <paramref name="utf8"/> is <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.ToSystemStringOrEmpty(dnlib.DotNet.UTF8String)">
            <summary>
            Converts it to a <see cref="T:System.String"/> or an empty string if <paramref name="utf8"/> is <c>null</c>
            </summary>
            <param name="utf8">The UTF-8 string instace or <c>null</c></param>
            <returns>A <see cref="T:System.String"/> (never <c>null</c>)</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.GetHashCode(dnlib.DotNet.UTF8String)">
            <summary>
            Gets the hash code of a <see cref="T:dnlib.DotNet.UTF8String"/>
            </summary>
            <param name="utf8">Input</param>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.CompareTo(dnlib.DotNet.UTF8String)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.CompareTo(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>
            Compares two <see cref="T:dnlib.DotNet.UTF8String"/> instances (case sensitive)
            </summary>
            <param name="a">Instance #1 or <c>null</c></param>
            <param name="b">Instance #2 or <c>null</c></param>
            <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.CaseInsensitiveCompareTo(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>
            Compares two <see cref="T:dnlib.DotNet.UTF8String"/> instances (case insensitive)
            </summary>
            <param name="a">Instance #1 or <c>null</c></param>
            <param name="b">Instance #2 or <c>null</c></param>
            <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.CaseInsensitiveEquals(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>
            Compares two <see cref="T:dnlib.DotNet.UTF8String"/> instances (case insensitive)
            </summary>
            <param name="a">Instance #1 or <c>null</c></param>
            <param name="b">Instance #2 or <c>null</c></param>
            <returns><c>true</c> if equals, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.op_Equality(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.op_Equality(dnlib.DotNet.UTF8String,System.String)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.op_Equality(System.String,dnlib.DotNet.UTF8String)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.op_Inequality(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.op_Inequality(dnlib.DotNet.UTF8String,System.String)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.op_Inequality(System.String,dnlib.DotNet.UTF8String)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.op_GreaterThan(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.op_LessThan(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.op_GreaterThanOrEqual(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.op_LessThanOrEqual(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="data">UTF-8 data that this instance now owns</param>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="s">The string</param>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.Equals(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>
            Compares two instances
            </summary>
            <param name="a">First</param>
            <param name="b">Second</param>
            <returns><c>true</c> if equals, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.Equals(dnlib.DotNet.UTF8String)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.Contains(System.String)">
            <summary>
            Checks whether <paramref name="value"/> exists in this string
            </summary>
            <param name="value">Value to find</param>
            <returns><c>true</c> if <paramref name="value"/> exists in string or is the
            empty string, else <c>false</c></returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.EndsWith(System.String)">
            <summary>
            Checks whether <paramref name="value"/> matches the end of this string
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Checks whether <paramref name="value"/> matches the end of this string
            </summary>
            <param name="value">Value</param>
            <param name="ignoreCase"><c>true</c> to ignore case</param>
            <param name="culture">Culture info</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.EndsWith(System.String,System.StringComparison)">
            <summary>
            Checks whether <paramref name="value"/> matches the end of this string
            </summary>
            <param name="value">Value</param>
            <param name="comparisonType">Comparison type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.StartsWith(System.String)">
            <summary>
            Checks whether <paramref name="value"/> matches the beginning of this string
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Checks whether <paramref name="value"/> matches the beginning of this string
            </summary>
            <param name="value">Value</param>
            <param name="ignoreCase"><c>true</c> to ignore case</param>
            <param name="culture">Culture info</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.StartsWith(System.String,System.StringComparison)">
            <summary>
            Checks whether <paramref name="value"/> matches the beginning of this string
            </summary>
            <param name="value">Value</param>
            <param name="comparisonType">Comparison type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.CompareTo(System.String)">
            <summary>
            Compares this instance with <paramref name="strB"/>
            </summary>
            <param name="strB">Other string</param>
            <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.IndexOf(System.Char)">
            <summary>
            Returns the index of the first character <paramref name="value"/> in this string
            </summary>
            <param name="value">Character</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.IndexOf(System.Char,System.Int32)">
            <summary>
            Returns the index of the first character <paramref name="value"/> in this string
            starting from index <paramref name="startIndex"/>
            </summary>
            <param name="value">Character</param>
            <param name="startIndex">Start index</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.IndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Returns the index of the first character <paramref name="value"/> in this string
            starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
            characters.
            </summary>
            <param name="value">Character</param>
            <param name="startIndex">Start index</param>
            <param name="count">Max number of chars to scan</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.IndexOf(System.String)">
            <summary>
            Returns the index of the first sub string <paramref name="value"/> in this string
            </summary>
            <param name="value">String</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.IndexOf(System.String,System.Int32)">
            <summary>
            Returns the index of the first sub string <paramref name="value"/> in this string
            starting from index <paramref name="startIndex"/>
            </summary>
            <param name="value">String</param>
            <param name="startIndex">Start index</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.IndexOf(System.String,System.Int32,System.Int32)">
            <summary>
            Returns the index of the first sub string <paramref name="value"/> in this string
            starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
            characters.
            </summary>
            <param name="value">String</param>
            <param name="startIndex">Start index</param>
            <param name="count">Max number of chars to scan</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Returns the index of the first sub string <paramref name="value"/> in this string
            starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
            characters.
            </summary>
            <param name="value">String</param>
            <param name="startIndex">Start index</param>
            <param name="count">Max number of chars to scan</param>
            <param name="comparisonType">Comparison type</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.IndexOf(System.String,System.Int32,System.StringComparison)">
            <summary>
            Returns the index of the first sub string <paramref name="value"/> in this string
            starting from index <paramref name="startIndex"/>
            </summary>
            <param name="value">String</param>
            <param name="startIndex">Start index</param>
            <param name="comparisonType">Comparison type</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.IndexOf(System.String,System.StringComparison)">
            <summary>
            Returns the index of the first sub string <paramref name="value"/> in this string
            </summary>
            <param name="value">String</param>
            <param name="comparisonType">Comparison type</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.LastIndexOf(System.Char)">
            <summary>
            Returns the index of the last character <paramref name="value"/> in this string
            </summary>
            <param name="value">Character</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.LastIndexOf(System.Char,System.Int32)">
            <summary>
            Returns the index of the last character <paramref name="value"/> in this string
            starting from index <paramref name="startIndex"/>
            </summary>
            <param name="value">Character</param>
            <param name="startIndex">Start index</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.LastIndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Returns the index of the last character <paramref name="value"/> in this string
            starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
            characters.
            </summary>
            <param name="value">Character</param>
            <param name="startIndex">Start index</param>
            <param name="count">Max number of chars to scan</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.LastIndexOf(System.String)">
            <summary>
            Returns the index of the last sub string <paramref name="value"/> in this string
            </summary>
            <param name="value">String</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.LastIndexOf(System.String,System.Int32)">
            <summary>
            Returns the index of the last sub string <paramref name="value"/> in this string
            starting from index <paramref name="startIndex"/>
            </summary>
            <param name="value">String</param>
            <param name="startIndex">Start index</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.LastIndexOf(System.String,System.Int32,System.Int32)">
            <summary>
            Returns the index of the last sub string <paramref name="value"/> in this string
            starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
            characters.
            </summary>
            <param name="value">String</param>
            <param name="startIndex">Start index</param>
            <param name="count">Max number of chars to scan</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Returns the index of the last sub string <paramref name="value"/> in this string
            starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
            characters.
            </summary>
            <param name="value">String</param>
            <param name="startIndex">Start index</param>
            <param name="count">Max number of chars to scan</param>
            <param name="comparisonType">Comparison type</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
            <summary>
            Returns the index of the last sub string <paramref name="value"/> in this string
            starting from index <paramref name="startIndex"/>
            </summary>
            <param name="value">String</param>
            <param name="startIndex">Start index</param>
            <param name="comparisonType">Comparison type</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.LastIndexOf(System.String,System.StringComparison)">
            <summary>
            Returns the index of the last sub string <paramref name="value"/> in this string
            </summary>
            <param name="value">String</param>
            <param name="comparisonType">Comparison type</param>
            <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.Insert(System.Int32,System.String)">
            <summary>
            Inserts string <paramref name="value"/> at a index <paramref name="startIndex"/>
            </summary>
            <param name="startIndex">Start index</param>
            <param name="value">Value to insert</param>
            <returns>A new instance with the <paramref name="value"/> inserted at position
            <paramref name="startIndex"/></returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.Remove(System.Int32)">
            <summary>
            Removes all characters starting from position <paramref name="startIndex"/>
            </summary>
            <param name="startIndex">Start index</param>
            <returns>A new instance</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.Remove(System.Int32,System.Int32)">
            <summary>
            Removes <paramref name="count"/> characters starting from position
            <paramref name="startIndex"/>
            </summary>
            <param name="startIndex">Start index</param>
            <param name="count">Number of characters to remove</param>
            <returns>A new instance</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.Replace(System.Char,System.Char)">
            <summary>
            Replaces all characters <paramref name="oldChar"/> with <paramref name="newChar"/>
            </summary>
            <param name="oldChar">Character to find</param>
            <param name="newChar">Character to replace all <paramref name="oldChar"/></param>
            <returns>A new instance</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.Replace(System.String,System.String)">
            <summary>
            Replaces all sub strings <paramref name="oldValue"/> with <paramref name="newValue"/>
            </summary>
            <param name="oldValue">Sub string to find</param>
            <param name="newValue">Sub string to replace all <paramref name="oldValue"/></param>
            <returns>A new instance</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.Substring(System.Int32)">
            <summary>
            Returns a sub string of this string starting at offset <paramref name="startIndex"/>
            </summary>
            <param name="startIndex">Start index</param>
            <returns>A new instance</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.Substring(System.Int32,System.Int32)">
            <summary>
            Returns a sub string of this string starting at offset <paramref name="startIndex"/>.
            Length of sub string is <paramref name="length"/>.
            </summary>
            <param name="startIndex">Start index</param>
            <param name="length">Length of sub string</param>
            <returns>A new instance</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.ToLower">
            <summary>
            Returns the lower case version of this string
            </summary>
            <returns>A new instance</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.ToLower(System.Globalization.CultureInfo)">
            <summary>
            Returns the lower case version of this string
            </summary>
            <param name="culture">Culture info</param>
            <returns>A new instance</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.ToLowerInvariant">
            <summary>
            Returns the lower case version of this string using the invariant culture
            </summary>
            <returns>A new instance</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.ToUpper">
            <summary>
            Returns the upper case version of this string
            </summary>
            <returns>A new instance</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.ToUpper(System.Globalization.CultureInfo)">
            <summary>
            Returns the upper case version of this string
            </summary>
            <param name="culture">Culture info</param>
            <returns>A new instance</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.ToUpperInvariant">
            <summary>
            Returns the upper case version of this string using the invariant culture
            </summary>
            <returns>A new instance</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.Trim">
            <summary>
            Removes all leading and trailing whitespace characters
            </summary>
            <returns>A new instance</returns>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.UTF8String.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.ByteArrayEqualityComparer">
            <summary>
            Compares byte arrays
            </summary>
        </member>
        <member name="F:dnlib.DotNet.ByteArrayEqualityComparer.Instance">
            <summary>
            Default instance
            </summary>
        </member>
        <member name="M:dnlib.DotNet.ByteArrayEqualityComparer.Equals(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.ByteArrayEqualityComparer.GetHashCode(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Utils.GetAssemblyNameString(dnlib.DotNet.UTF8String,System.Version,dnlib.DotNet.UTF8String,dnlib.DotNet.PublicKeyBase,dnlib.DotNet.AssemblyAttributes)">
            <summary>
            Returns an assembly name string
            </summary>
            <param name="name">Simple assembly name</param>
            <param name="version">Version or <c>null</c></param>
            <param name="culture">Culture or <c>null</c></param>
            <param name="publicKey">Public key / public key token or <c>null</c></param>
            <param name="attributes">Assembly attributes</param>
            <returns>An assembly name string</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.ToHex(System.Byte[],System.Boolean)">
            <summary>
            Convert a byte[] to a <see cref="T:System.String"/>
            </summary>
            <param name="bytes">All bytes</param>
            <param name="upper"><c>true</c> if output should be in upper case hex</param>
            <returns><paramref name="bytes"/> as a hex string</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.ParseBytes(System.String)">
            <summary>
            Converts a hex string to a byte[]
            </summary>
            <param name="hexString">A string with an even number of hex characters</param>
            <returns><paramref name="hexString"/> converted to a byte[] or <c>null</c>
            if <paramref name="hexString"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.TryParseHexChar(System.Char)">
            <summary>
            Converts a character to a hex digit
            </summary>
            <param name="c">Hex character</param>
            <returns><c>0x00</c>-<c>0x0F</c> if successful, <c>-1</c> if <paramref name="c"/> is not
            a valid hex digit</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.CompareTo(System.Byte[],System.Byte[])">
            <summary>
            Compares two byte arrays
            </summary>
            <param name="a">Byte array #1</param>
            <param name="b">Byte array #2</param>
            <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.Equals(System.Byte[],System.Byte[])">
            <summary>
            Checks whether two byte arrays are equal
            </summary>
            <param name="a">First</param>
            <param name="b">Second</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.GetHashCode(System.Byte[])">
            <summary>
            Gets the hash code of a byte array
            </summary>
            <param name="a">Byte array</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.CompareTo(System.Version,System.Version)">
            <summary>
            Compares two versions
            </summary>
            <remarks>This differs from <see cref="M:System.Version.CompareTo(System.Version)"/> if the build
            and/or revision numbers haven't been initialized or if one of the args is <c>null</c>.
            </remarks>
            <param name="a">Version #1 or <c>null</c> to be treated as v0.0.0.0</param>
            <param name="b">Version #2 or <c>null</c> to be treated as v0.0.0.0</param>
            <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.Equals(System.Version,System.Version)">
            <summary>
            Checks whether two versions are the same
            </summary>
            <remarks>This differs from <see cref="M:System.Version.Equals(System.Version)"/> if the build
            and/or revision numbers haven't been initialized or if one of the args is <c>null</c>.
            </remarks>
            <param name="a">Version #1 or <c>null</c> to be treated as v0.0.0.0</param>
            <param name="b">Version #2 or <c>null</c> to be treated as v0.0.0.0</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.CreateVersionWithNoUndefinedValues(System.Version)">
            <summary>
            Creates a new <see cref="T:System.Version"/> instance with no undefined version values (eg.
            the build and revision values won't be -1).
            </summary>
            <param name="a">A <see cref="T:System.Version"/> instance</param>
            <returns>A new <see cref="T:System.Version"/> instance</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.ParseVersion(System.String)">
            <summary>
            Parses a version string
            </summary>
            <param name="versionString">Version string</param>
            <returns>A new <see cref="T:System.Version"/> or <c>null</c> if <paramref name="versionString"/>
            is an invalid version</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.LocaleCompareTo(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>
            Compares two locales (cultures)
            </summary>
            <param name="a">First</param>
            <param name="b">Second</param>
            <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.LocaleEquals(dnlib.DotNet.UTF8String,dnlib.DotNet.UTF8String)">
            <summary>
            Compares two locales (cultures)
            </summary>
            <param name="a">First</param>
            <param name="b">Second</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.LocaleCompareTo(dnlib.DotNet.UTF8String,System.String)">
            <summary>
            Compares two locales (cultures)
            </summary>
            <param name="a">First</param>
            <param name="b">Second</param>
            <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.LocaleEquals(dnlib.DotNet.UTF8String,System.String)">
            <summary>
            Compares two locales (cultures)
            </summary>
            <param name="a">First</param>
            <param name="b">Second</param>
            <returns><c>true</c> if same, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.GetHashCodeLocale(dnlib.DotNet.UTF8String)">
            <summary>
            Gets the hash code of a locale
            </summary>
            <param name="a">Value</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:dnlib.DotNet.Utils.AlignUp(System.UInt32,System.UInt32)">
            <summary>
            Align up
            </summary>
            <param name="v">Value</param>
            <param name="alignment">Alignment</param>
        </member>
        <member name="M:dnlib.DotNet.Utils.AlignUp(System.Int32,System.UInt32)">
            <summary>
            Align up
            </summary>
            <param name="v">Value</param>
            <param name="alignment">Alignment</param>
        </member>
        <member name="T:dnlib.DotNet.VariantType">
            <summary>
            Variant type (<c>VT_XXX</c> in the Windows SDK)
            </summary>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Empty">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.None">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Null">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.I2">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.I4">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.R4">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.R8">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.CY">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Date">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.BStr">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Dispatch">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Error">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Bool">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Variant">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Unknown">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Decimal">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.I1">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.UI1">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.UI2">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.UI4">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.I8">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.UI8">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Int">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.UInt">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Void">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.HResult">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Ptr">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.SafeArray">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.CArray">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.UserDefined">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.LPStr">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.LPWStr">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Record">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.IntPtr">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.UIntPtr">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.FileTime">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Blob">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Stream">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Storage">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.StreamedObject">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.StoredObject">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.BlobObject">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.CF">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.CLSID">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.VersionedStream">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.BStrBlob">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Vector">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Array">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.ByRef">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Reserved">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.Illegal">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.IllegalMasked">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.TypeMask">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.VariantType.NotInitialized">
            <summary>This wasn't present in the blob</summary>
        </member>
        <member name="T:dnlib.DotNet.VTableFixups">
            <summary>
            All native vtables
            </summary>
        </member>
        <member name="P:dnlib.DotNet.VTableFixups.RVA">
            <summary>
            Gets/sets the RVA of the vtable fixups
            </summary>
        </member>
        <member name="P:dnlib.DotNet.VTableFixups.VTables">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.VTable"/>s
            </summary>
        </member>
        <member name="M:dnlib.DotNet.VTableFixups.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.VTableFixups.#ctor(dnlib.DotNet.ModuleDefMD)">
            <summary>
            Constructor
            </summary>
            <param name="module">Module</param>
        </member>
        <member name="M:dnlib.DotNet.VTableFixups.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.VTableFixups.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.VTableFlags">
            <summary>
            See COR_VTABLE_XXX in CorHdr.h
            </summary>
        </member>
        <member name="F:dnlib.DotNet.VTableFlags.Bit32">
            <summary>
            32-bit vtable slots
            </summary>
        </member>
        <member name="F:dnlib.DotNet.VTableFlags.Bit64">
            <summary>
            64-bit vtable slots
            </summary>
        </member>
        <member name="F:dnlib.DotNet.VTableFlags.FromUnmanaged">
            <summary>
            Transition from unmanaged code
            </summary>
        </member>
        <member name="F:dnlib.DotNet.VTableFlags.FromUnmanagedRetainAppDomain">
            <summary>
            Also retain app domain
            </summary>
        </member>
        <member name="F:dnlib.DotNet.VTableFlags.CallMostDerived">
            <summary>
            Call most derived method
            </summary>
        </member>
        <member name="T:dnlib.DotNet.VTable">
            <summary>
            One VTable accessed by native code
            </summary>
        </member>
        <member name="P:dnlib.DotNet.VTable.RVA">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.VTable.RVA"/> of this vtable
            </summary>
        </member>
        <member name="P:dnlib.DotNet.VTable.Flags">
            <summary>
            Gets/sets the flags
            </summary>
        </member>
        <member name="P:dnlib.DotNet.VTable.Is32Bit">
            <summary>
            <c>true</c> if each vtable slot is 32 bits in size
            </summary>
        </member>
        <member name="P:dnlib.DotNet.VTable.Is64Bit">
            <summary>
            <c>true</c> if each vtable slot is 64 bits in size
            </summary>
        </member>
        <member name="P:dnlib.DotNet.VTable.Methods">
            <summary>
            Gets the vtable methods
            </summary>
        </member>
        <member name="M:dnlib.DotNet.VTable.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.VTable.#ctor(dnlib.DotNet.VTableFlags)">
            <summary>
            Constructor
            </summary>
            <param name="flags">Flags</param>
        </member>
        <member name="M:dnlib.DotNet.VTable.#ctor(dnlib.PE.RVA,dnlib.DotNet.VTableFlags,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="rva">RVA of this vtable</param>
            <param name="flags">Flgas</param>
            <param name="numSlots">Number of methods in vtable</param>
        </member>
        <member name="M:dnlib.DotNet.VTable.#ctor(dnlib.PE.RVA,dnlib.DotNet.VTableFlags,System.Collections.Generic.IEnumerable{dnlib.DotNet.IMethod})">
            <summary>
            Constructor
            </summary>
            <param name="rva">RVA of this vtable</param>
            <param name="flags">Flgas</param>
            <param name="methods">Vtable methods</param>
        </member>
        <member name="M:dnlib.DotNet.VTable.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.VTable.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.VTable.ToString">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.WinMDHelpers.ToCLR(dnlib.DotNet.ModuleDef,dnlib.DotNet.TypeDef)">
            <summary>
            Converts WinMD type <paramref name="td"/> to a CLR type. Returns <c>null</c>
            if it's not a CLR compatible WinMD type.
            </summary>
            <param name="module">Owner module or <c>null</c></param>
            <param name="td">Type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.WinMDHelpers.ToCLR(dnlib.DotNet.ModuleDef,dnlib.DotNet.TypeDef,System.Boolean@)">
            <summary>
            Converts WinMD type <paramref name="td"/> to a CLR type. Returns <c>null</c>
            if it's not a CLR compatible WinMD type.
            </summary>
            <param name="module">Owner module or <c>null</c></param>
            <param name="td">Type</param>
            <param name="isClrValueType"><c>true</c> if the returned type is a value type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.WinMDHelpers.ToCLR(dnlib.DotNet.ModuleDef,dnlib.DotNet.TypeRef)">
            <summary>
            Converts WinMD type <paramref name="tr"/> to a CLR type. Returns <c>null</c>
            if it's not a CLR compatible WinMD type.
            </summary>
            <param name="module">Owner module or <c>null</c></param>
            <param name="tr">Type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.WinMDHelpers.ToCLR(dnlib.DotNet.ModuleDef,dnlib.DotNet.TypeRef,System.Boolean@)">
            <summary>
            Converts WinMD type <paramref name="tr"/> to a CLR type. Returns <c>null</c>
            if it's not a CLR compatible WinMD type.
            </summary>
            <param name="module">Owner module or <c>null</c></param>
            <param name="tr">Type</param>
            <param name="isClrValueType"><c>true</c> if the returned type is a value type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.WinMDHelpers.ToCLR(dnlib.DotNet.ModuleDef,dnlib.DotNet.ExportedType)">
            <summary>
            Converts WinMD type <paramref name="et"/> to a CLR type. Returns <c>null</c>
            if it's not a CLR compatible WinMD type.
            </summary>
            <param name="module">Owner module or <c>null</c></param>
            <param name="et">Type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.WinMDHelpers.ToCLR(dnlib.DotNet.ModuleDef,dnlib.DotNet.TypeSig)">
            <summary>
            Converts WinMD type <paramref name="ts"/> to a CLR type. Returns <c>null</c>
            if it's not a CLR compatible WinMD type.
            </summary>
            <param name="module">Owner module or <c>null</c></param>
            <param name="ts">Type</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.WinMDHelpers.ToCLR(dnlib.DotNet.ModuleDef,dnlib.DotNet.MemberRef)">
            <summary>
            Converts WinMD member reference <paramref name="mr"/> to a CLR member reference. Returns
            <c>null</c> if it's not a CLR compatible WinMD member reference.
            </summary>
            <param name="module">Owner module or <c>null</c></param>
            <param name="mr">Member reference</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.WinMDHelpers.ToCLR(dnlib.DotNet.ModuleDef,dnlib.DotNet.MethodDef)">
            <summary>
            Converts WinMD method <paramref name="md"/> to a CLR member reference. Returns
            <c>null</c> if it's not a CLR compatible WinMD method
            </summary>
            <param name="module">Owner module or <c>null</c></param>
            <param name="md">Method</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.WinMDStatus">
            <summary>
            WinMD status
            </summary>
        </member>
        <member name="F:dnlib.DotNet.WinMDStatus.None">
            <summary>
            This is not a WinMD file
            </summary>
        </member>
        <member name="F:dnlib.DotNet.WinMDStatus.Pure">
            <summary>
            This is a pure WinMD file (not managed)
            </summary>
        </member>
        <member name="F:dnlib.DotNet.WinMDStatus.Managed">
            <summary>
            This is a managed WinMD file (created by eg. winmdexp.exe)
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.ArrayWriter">
            <summary>
            Writes data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ArrayWriter.Position">
            <summary>
            Gets the current position
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ArrayWriter.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="data">Destination array</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ArrayWriter.WriteSByte(System.SByte)">
            <summary>
            Writes a <see cref="T:System.SByte"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ArrayWriter.WriteByte(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ArrayWriter.WriteInt16(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ArrayWriter.WriteUInt16(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ArrayWriter.WriteInt32(System.Int32)">
            <summary>
            Writes a <see cref="T:System.Int32"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ArrayWriter.WriteUInt32(System.UInt32)">
            <summary>
            Writes a <see cref="T:System.UInt32"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ArrayWriter.WriteInt64(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ArrayWriter.WriteUInt64(System.UInt64)">
            <summary>
            Writes a <see cref="T:System.UInt64"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ArrayWriter.WriteSingle(System.Single)">
            <summary>
            Writes a <see cref="T:System.Single"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ArrayWriter.WriteDouble(System.Double)">
            <summary>
            Writes a <see cref="T:System.Double"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ArrayWriter.WriteBytes(System.Byte[])">
            <summary>
            Writes bytes
            </summary>
            <param name="source">Bytes</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ArrayWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes
            </summary>
            <param name="source">Bytes</param>
            <param name="index">Source index</param>
            <param name="length">Number of bytes to write</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.BlobHeap">
            <summary>
            #Blob heap
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.BlobHeap.Name">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.BlobHeap.Populate(dnlib.DotNet.MD.BlobStream)">
            <summary>
            Populates blobs from an existing <see cref="T:dnlib.DotNet.MD.BlobStream"/> (eg. to preserve
            blob offsets)
            </summary>
            <param name="blobStream">The #Blob stream with the original content</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.BlobHeap.Add(System.Byte[])">
            <summary>
            Adds data to the #Blob heap
            </summary>
            <param name="data">The data</param>
            <returns>The offset of the data in the #Blob heap</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.BlobHeap.Create(System.Byte[])">
            <summary>
            Adds data to the #Blob heap, but does not re-use an existing position
            </summary>
            <param name="data">The data</param>
            <returns>The offset of the data in the #Blob heap</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.BlobHeap.GetRawLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.BlobHeap.WriteToImpl(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.BlobHeap.GetRawDataSize(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.BlobHeap.SetRawData(System.UInt32,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.BlobHeap.GetAllRawData">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.ByteArrayChunk">
            <summary>
            Stores a byte array
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ByteArrayChunk.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.ByteArrayChunk.RVA">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.ByteArrayChunk.Data">
            <summary>
            Gets the data
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ByteArrayChunk.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="array">The data. It will be owned by this instance and can't be modified by
            other code if this instance is inserted as a <c>key</c> in a dictionary (because
            <see cref="M:dnlib.DotNet.Writer.ByteArrayChunk.GetHashCode"/> return value will be different if you modify the array). If
            it's never inserted as a <c>key</c> in a dictionary, then the contents can be modified,
            but shouldn't be resized after <see cref="M:dnlib.DotNet.Writer.ByteArrayChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> has been called.</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ByteArrayChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ByteArrayChunk.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ByteArrayChunk.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ByteArrayChunk.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ByteArrayChunk.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ByteArrayChunk.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.ChecksumAlgorithm">
            <summary>
            Checksum algorithm
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ChecksumAlgorithm.SHA1">
            <summary>
            SHA-1
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ChecksumAlgorithm.SHA256">
            <summary>
            SHA-256
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ChecksumAlgorithm.SHA384">
            <summary>
            SHA-384
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ChecksumAlgorithm.SHA512">
            <summary>
            SHA-512
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.ChunkList`1">
            <summary>
            Contains a list of <see cref="T:dnlib.DotNet.Writer.IChunk"/>s
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ChunkList`1.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ChunkList`1.Add(`0,System.UInt32)">
            <summary>
            Add a <see cref="T:dnlib.DotNet.Writer.IChunk"/>
            </summary>
            <param name="chunk">The chunk to add or <c>null</c> if none</param>
            <param name="alignment">Chunk alignment</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ChunkList`1.Remove(`0)">
            <summary>
            Remove a <see cref="T:dnlib.DotNet.Writer.IChunk"/>
            </summary>
            <param name="chunk">The chunk to remove or <c>null</c> if none</param>
            <returns>Alignment of the chunk, or <c>null</c> if the chunk cannot be removed.</returns>
        </member>
        <member name="T:dnlib.DotNet.Writer.ChunkListBase`1">
            <summary>
            Base class of chunk list types
            </summary>
            <typeparam name="T">Chunk type</typeparam>
        </member>
        <member name="F:dnlib.DotNet.Writer.ChunkListBase`1.chunks">
            <summary>All chunks</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ChunkListBase`1.setOffsetCalled">
            <summary><c>true</c> if <see cref="M:dnlib.DotNet.Writer.ChunkListBase`1.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> has been called</summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.ChunkListBase`1.Elem">
            <summary>
            Helper struct
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ChunkListBase`1.Elem.chunk">
            <summary>Data</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ChunkListBase`1.Elem.alignment">
            <summary>Alignment</summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ChunkListBase`1.Elem.#ctor(`0,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="chunk">Chunk</param>
            <param name="alignment">Alignment</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.ChunkListBase`1.ElemEqualityComparer">
            <summary>
            Equality comparer for <see cref="T:dnlib.DotNet.Writer.ChunkListBase`1.Elem"/>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ChunkListBase`1.ElemEqualityComparer.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor
            </summary>
            <param name="chunkComparer">Compares the chunk type</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ChunkListBase`1.ElemEqualityComparer.Equals(dnlib.DotNet.Writer.ChunkListBase{`0}.Elem,dnlib.DotNet.Writer.ChunkListBase{`0}.Elem)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ChunkListBase`1.ElemEqualityComparer.GetHashCode(dnlib.DotNet.Writer.ChunkListBase{`0}.Elem)">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.ChunkListBase`1.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.ChunkListBase`1.RVA">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ChunkListBase`1.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ChunkListBase`1.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ChunkListBase`1.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ChunkListBase`1.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.ICustomAttributeWriterHelper">
            <summary>
            Helps <see cref="T:dnlib.DotNet.Writer.CustomAttributeWriter"/> write custom attributes
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.CustomAttributeWriter">
            <summary>
            Writes <see cref="T:dnlib.DotNet.CustomAttribute"/>s
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.CustomAttributeWriter.Write(dnlib.DotNet.Writer.ICustomAttributeWriterHelper,dnlib.DotNet.CustomAttribute)">
            <summary>
            Writes a custom attribute
            </summary>
            <param name="helper">Helper class</param>
            <param name="ca">The custom attribute</param>
            <returns>Custom attribute blob</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.CustomAttributeWriter.Write(dnlib.DotNet.Writer.ICustomAttributeWriterHelper,System.Collections.Generic.IList{dnlib.DotNet.CANamedArgument})">
            <summary>
            Writes custom attribute named arguments
            </summary>
            <param name="helper">Helper class</param>
            <param name="namedArgs">Named arguments</param>
            <returns>The named args blob</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.CustomAttributeWriter.WriteElem(dnlib.DotNet.TypeSig,dnlib.DotNet.CAArgument)">
            <summary>
            Write a value
            </summary>
            <param name="argType">The ctor arg type, field type, or property type</param>
            <param name="value">The value to write</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.CustomAttributeWriter.GetEnumUnderlyingType(dnlib.DotNet.TypeSig)">
            <summary>
            Gets the enum's underlying type
            </summary>
            <param name="type">An enum type</param>
            <returns>The underlying type or <c>null</c> if we couldn't resolve the type ref</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.CustomAttributeWriter.GetTypeDef(dnlib.DotNet.TypeSig)">
            <summary>
            Converts <paramref name="type"/> to a <see cref="T:dnlib.DotNet.TypeDef"/>, possibly resolving
            a <see cref="T:dnlib.DotNet.TypeRef"/>
            </summary>
            <param name="type">The type</param>
            <returns>A <see cref="T:dnlib.DotNet.TypeDef"/> or <c>null</c> if we couldn't resolve the
            <see cref="T:dnlib.DotNet.TypeRef"/> or if <paramref name="type"/> is a type spec</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.CustomAttributeWriter.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.DataReaderChunk">
            <summary>
            A <see cref="T:dnlib.IO.DataReader"/> chunk
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.DataReaderChunk.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.DataReaderChunk.RVA">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderChunk.#ctor(dnlib.IO.DataReader)">
            <summary>
            Constructor
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderChunk.#ctor(dnlib.IO.DataReader,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="data">The data</param>
            <param name="virtualSize">Virtual size of <paramref name="data"/></param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderChunk.#ctor(dnlib.IO.DataReader@)">
            <summary>
            Constructor
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderChunk.#ctor(dnlib.IO.DataReader@,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="data">The data</param>
            <param name="virtualSize">Virtual size of <paramref name="data"/></param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderChunk.CreateReader">
            <summary>
            Gets the data reader
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderChunk.SetData(dnlib.IO.DataReader)">
            <summary>
            Replaces the old data with new data. The new data must be the same size as the old data if
            <see cref="M:dnlib.DotNet.Writer.DataReaderChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> has been called. That method gets called after
            event <see cref="F:dnlib.DotNet.Writer.ModuleWriterEvent.BeginCalculateRvasAndFileOffsets"/>
            </summary>
            <param name="newData"></param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderChunk.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderChunk.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderChunk.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.DataReaderHeap">
            <summary>
            Copies existing data to a new metadata heap
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.DataReaderHeap.Name">
            <summary>
            Gets the name of the heap
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderHeap.#ctor(dnlib.DotNet.MD.DotNetStream)">
            <summary>
            Constructor
            </summary>
            <param name="stream">The stream whose data will be copied to the new metadata file</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderHeap.#ctor(System.String,dnlib.IO.DataReader)">
            <summary>
            Constructor
            </summary>
            <param name="name">Heap name</param>
            <param name="heapReader">Heap content</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderHeap.GetRawLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataReaderHeap.WriteToImpl(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.DataWriter">
            <summary>
            Writes data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.DataWriter.Position">
            <summary>
            Gets/sets the position
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.#ctor(System.IO.Stream)">
            <summary>
            Constructor
            </summary>
            <param name="stream">Destination stream</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteBoolean(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteSByte(System.SByte)">
            <summary>
            Writes a <see cref="T:System.SByte"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteByte(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteInt16(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteUInt16(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteInt32(System.Int32)">
            <summary>
            Writes a <see cref="T:System.Int32"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteUInt32(System.UInt32)">
            <summary>
            Writes a <see cref="T:System.UInt32"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteInt64(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteUInt64(System.UInt64)">
            <summary>
            Writes a <see cref="T:System.UInt64"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteSingle(System.Single)">
            <summary>
            Writes a <see cref="T:System.Single"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteDouble(System.Double)">
            <summary>
            Writes a <see cref="T:System.Double"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteBytes(System.Byte[])">
            <summary>
            Writes bytes
            </summary>
            <param name="source">Bytes to write</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes
            </summary>
            <param name="source">Bytes to write</param>
            <param name="index">Index to start copying from</param>
            <param name="length">Number of bytes to copy</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteCompressedUInt32(System.UInt32)">
            <summary>
            Writes a compressed <see cref="T:System.UInt32"/>
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.WriteCompressedInt32(System.Int32)">
            <summary>
            Writes a compressed <see cref="T:System.Int32"/>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:dnlib.DotNet.Writer.DataWriter.GetCompressedUInt32Length(System.UInt32)">
            <summary>
            Gets the size of a compressed <see cref="T:System.UInt32"/>, see <see cref="M:dnlib.DotNet.Writer.DataWriter.WriteCompressedUInt32(System.UInt32)"/>
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.Writer.DebugDirectoryEntry">
            <summary>
            Debug directory entry
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.DebugDirectoryEntry.DebugDirectory">
            <summary>
            Gets the header
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.DebugDirectoryEntry.Chunk">
            <summary>
            Gets the data
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.DebugDirectoryEntry.#ctor(dnlib.DotNet.Writer.IChunk)">
            <summary>
            Constructor
            </summary>
            <param name="chunk">Data</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.DebugDirectory">
            <summary>
            Debug directory chunk
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.DebugDirectory.DEFAULT_DEBUGDIRECTORY_ALIGNMENT">
            <summary>Default debug directory alignment</summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.DebugDirectory.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.DebugDirectory.RVA">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.DebugDirectory.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.DebugDirectory.Add(System.Byte[])">
            <summary>
            Adds data
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.DebugDirectory.Add(dnlib.DotNet.Writer.IChunk)">
            <summary>
            Adds data
            </summary>
            <param name="chunk">Data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.DebugDirectory.Add(System.Byte[],dnlib.PE.ImageDebugType,System.UInt16,System.UInt16,System.UInt32)">
            <summary>
            Adds data
            </summary>
            <param name="data">Data</param>
            <param name="type">Debug type</param>
            <param name="majorVersion">Major version</param>
            <param name="minorVersion">Minor version</param>
            <param name="timeDateStamp">Timestamp</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.DebugDirectory.Add(dnlib.DotNet.Writer.IChunk,dnlib.PE.ImageDebugType,System.UInt16,System.UInt16,System.UInt32)">
            <summary>
            Adds data
            </summary>
            <param name="chunk">Data</param>
            <param name="type">Debug type</param>
            <param name="majorVersion">Major version</param>
            <param name="minorVersion">Minor version</param>
            <param name="timeDateStamp">Timestamp</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.DebugDirectory.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.DebugDirectory.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.DebugDirectory.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.DebugDirectory.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.DeclSecurityWriter">
            <summary>
            Writes <c>DeclSecurity</c> blobs
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.DeclSecurityWriter.Write(dnlib.DotNet.ModuleDef,System.Collections.Generic.IList{dnlib.DotNet.SecurityAttribute},dnlib.DotNet.Writer.IWriterError)">
            <summary>
            Creates a <c>DeclSecurity</c> blob from <paramref name="secAttrs"/>
            </summary>
            <param name="module">Owner module</param>
            <param name="secAttrs">List of <see cref="T:dnlib.DotNet.SecurityAttribute"/>s</param>
            <param name="helper">Helps this class</param>
            <returns>A <c>DeclSecurity</c> blob</returns>
        </member>
        <member name="T:dnlib.DotNet.Writer.Extensions">
            <summary>
            Extension methods
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Extensions.WriteZeroes(dnlib.DotNet.Writer.DataWriter,System.Int32)">
            <summary>
            Write zeros
            </summary>
            <param name="writer">this</param>
            <param name="count">Number of zeros</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Extensions.VerifyWriteTo(dnlib.DotNet.Writer.IChunk,dnlib.DotNet.Writer.DataWriter)">
            <summary>
            Writes all data to <paramref name="writer"/> and verifies that all bytes were written
            </summary>
            <param name="chunk">this</param>
            <param name="writer">Destination</param>
            <exception cref="T:System.IO.IOException">Not all bytes were written</exception>
        </member>
        <member name="M:dnlib.DotNet.Writer.Extensions.WriteDataDirectory(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.IChunk)">
            <summary>
            Writes a data directory
            </summary>
            <param name="writer">Writer</param>
            <param name="chunk">The data</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.GuidHeap">
            <summary>
            #GUID heap
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.GuidHeap.Name">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.GuidHeap.Add(System.Nullable{System.Guid})">
            <summary>
            Adds a guid to the #GUID heap
            </summary>
            <param name="guid">The guid</param>
            <returns>The index of the guid in the #GUID heap</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.GuidHeap.GetRawLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.GuidHeap.WriteToImpl(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.GuidHeap.GetRawDataSize(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.GuidHeap.SetRawData(System.UInt32,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.GuidHeap.GetAllRawData">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.HeapBase">
            <summary>
            Base class of most heaps
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.HeapBase.isReadOnly">
            <summary>
            <c>true</c> if <see cref="M:dnlib.DotNet.Writer.HeapBase.SetReadOnly"/> has been called
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.HeapBase.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.HeapBase.RVA">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.HeapBase.Name">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.HeapBase.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.HeapBase.IsBig">
            <summary>
            <c>true</c> if offsets require 4 bytes instead of 2 bytes.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.HeapBase.SetReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.HeapBase.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.HeapBase.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.HeapBase.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.HeapBase.GetRawLength">
            <summary>
            Gets the raw length of the heap
            </summary>
            <returns>Raw length of the heap</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.HeapBase.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.HeapBase.WriteToImpl(dnlib.DotNet.Writer.DataWriter)">
            <summary>
            Writes all data to <paramref name="writer"/> at its current location.
            </summary>
            <param name="writer">Destination</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.HeapBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.IChunk">
            <summary>
            Data that gets written to the file
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.IChunk.FileOffset">
            <summary>
            Gets the file offset. This is valid only after <see cref="M:dnlib.DotNet.Writer.IChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> has been called.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.IChunk.RVA">
            <summary>
            Gets the RVA. This is valid only after <see cref="M:dnlib.DotNet.Writer.IChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> has been called.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.IChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <summary>
            Called when the file offset and RVA are known
            </summary>
            <param name="offset">File offset of this chunk</param>
            <param name="rva">RVA of this chunk</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.IChunk.GetFileLength">
            <summary>
            Gets the raw file length of this chunk. Must only be called after <see cref="M:dnlib.DotNet.Writer.IChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/>
            has been called.
            </summary>
            <returns>Length of this chunk</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.IChunk.GetVirtualSize">
            <summary>
            Gets the virtual size of this chunk. Must only be called after <see cref="M:dnlib.DotNet.Writer.IChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/>
            has been called.
            </summary>
            <returns>Virtual size of this chunk</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.IChunk.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <summary>
            Writes all data to <paramref name="writer"/> at its current location. It's only
            called after <see cref="M:dnlib.DotNet.Writer.IChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> and <see cref="M:dnlib.DotNet.Writer.IChunk.GetFileLength"/> have been called.
            You cannot assume that <paramref name="writer"/>'s file position is the same as this
            chunk's file position.
            </summary>
            <param name="writer">Destination</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.IReuseChunk">
            <summary>
            Implemented by <see cref="T:dnlib.DotNet.Writer.IChunk"/>s that can reuse the old data location in the original PE file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.IReuseChunk.CanReuse(dnlib.PE.RVA,System.UInt32)">
            <summary>
            Returns true if this chunk fits in the old location
            </summary>
            <param name="origRva">Original RVA of data</param>
            <param name="origSize">Size of the original location</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.Writer.IHeap">
            <summary>
            .NET Heap interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.IHeap.Name">
            <summary>
            Gets the name of the heap
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.IHeap.IsEmpty">
            <summary>
            Checks whether the heap is empty
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.IHeap.SetReadOnly">
            <summary>
            Called when the heap should be set to read-only mode
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.Cor20HeaderOptions">
            <summary>
            Options to <see cref="T:dnlib.DotNet.Writer.ImageCor20Header"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.Cor20HeaderOptions.DEFAULT_MAJOR_RT_VER">
            <summary>
            Default major runtime version
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.Cor20HeaderOptions.DEFAULT_MINOR_RT_VER">
            <summary>
            Default minor runtime version
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.Cor20HeaderOptions.MajorRuntimeVersion">
            <summary>
            Major runtime version
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.Cor20HeaderOptions.MinorRuntimeVersion">
            <summary>
            Minor runtime version
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.Cor20HeaderOptions.Flags">
            <summary>
            Flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.Cor20HeaderOptions.EntryPoint">
            <summary>
            Entry point or <c>null</c>. Either a Method/File token or an RVA.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Cor20HeaderOptions.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Cor20HeaderOptions.#ctor(dnlib.DotNet.MD.ComImageFlags)">
            <summary>
            Constructor
            </summary>
            <param name="flags">Flags</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Cor20HeaderOptions.#ctor(System.UInt16,System.UInt16,dnlib.DotNet.MD.ComImageFlags)">
            <summary>
            Constructor
            </summary>
            <param name="major">Major runtime version (default is <see cref="F:dnlib.DotNet.Writer.Cor20HeaderOptions.DEFAULT_MAJOR_RT_VER"/>)</param>
            <param name="minor">Minor runtime version (default is <see cref="F:dnlib.DotNet.Writer.Cor20HeaderOptions.DEFAULT_MINOR_RT_VER"/>)</param>
            <param name="flags">Flags</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.ImageCor20Header">
            <summary>
            .NET header
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImageCor20Header.Metadata">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.Writer.ImageCor20Header.Metadata"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImageCor20Header.NetResources">
            <summary>
            Gets/sets the .NET resources
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImageCor20Header.StrongNameSignature">
            <summary>
            Gets/sets the strong name signature
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImageCor20Header.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImageCor20Header.RVA">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImageCor20Header.#ctor(dnlib.DotNet.Writer.Cor20HeaderOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Options</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImageCor20Header.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImageCor20Header.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImageCor20Header.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImageCor20Header.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.ImportAddressTable">
            <summary>
            Import address table chunk
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImportAddressTable.ImportDirectory">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.Writer.ImportAddressTable.ImportDirectory"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImportAddressTable.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImportAddressTable.RVA">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImportAddressTable.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="is64bit">true if it's a 64-bit PE file, false if it's a 32-bit PE file</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImportAddressTable.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImportAddressTable.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImportAddressTable.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImportAddressTable.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.ImportDirectory">
            <summary>
            Import directory chunk
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImportDirectory.ImportAddressTable">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.Writer.ImportDirectory.ImportAddressTable"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImportDirectory.CorXxxMainRVA">
            <summary>
            Gets the RVA of _CorDllMain/_CorExeMain in the import lookup table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImportDirectory.IatCorXxxMainRVA">
            <summary>
            Gets RVA of _CorExeMain/_CorDllMain in the IAT
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImportDirectory.IsExeFile">
            <summary>
            Gets/sets a value indicating whether this is a EXE or a DLL file
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImportDirectory.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImportDirectory.RVA">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.ImportDirectory.DllToImport">
            <summary>
            Gets/sets the name of the dll which should be imported.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImportDirectory.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="is64bit">true if it's a 64-bit PE file, false if it's a 32-bit PE file</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImportDirectory.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImportDirectory.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImportDirectory.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ImportDirectory.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.IOffsetHeap`1">
            <summary>
            Interface to get and set raw heap data. Implemented by the offset heaps: #Strings,
            #GUID, #Blob, and #US.
            </summary>
            <typeparam name="TValue">Type of cooked data</typeparam>
        </member>
        <member name="M:dnlib.DotNet.Writer.IOffsetHeap`1.GetRawDataSize(`0)">
            <summary>
            Gets the size of the data as raw data when written to the heap
            </summary>
            <param name="data">The data</param>
            <returns>Size of the data as raw data when written to the heap</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.IOffsetHeap`1.SetRawData(System.UInt32,System.Byte[])">
            <summary>
            Overrides what value should be written to the heap.
            </summary>
            <param name="offset">Offset of value. Must match an offset returned by
            <see cref="M:dnlib.DotNet.Writer.IOffsetHeap`1.GetAllRawData"/></param>
            <param name="rawData">The new raw data. The size must match the raw size exactly.</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.IOffsetHeap`1.GetAllRawData">
            <summary>
            Gets all inserted raw data and their offsets. The returned <see cref="T:System.Byte"/> array
            is owned by the caller.
            </summary>
            <returns>An enumerable of all raw data and their offsets</returns>
        </member>
        <member name="T:dnlib.DotNet.Writer.IWriterError">
            <summary>
            Gets notified of errors. The default handler should normally throw since the written data
            will probably be invalid. Any error can be ignored.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.IWriterError.Error(System.String)">
            <summary>
            Called when an error is detected (eg. a null pointer or other invalid value). The error
            can be ignored but the written data won't be valid.
            </summary>
            <param name="message">Error message</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ManagedExportsWriter.WriteSdataBlob(System.UInt32)">
            <summary>
            Writes the .sdata blob. We could write the data in any order, but we write the data in the same order as ILASM
            </summary>
            <param name="timestamp">PE timestamp</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.MarshalBlobWriter">
            <summary>
            Writes field marshal blobs
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MarshalBlobWriter.Write(dnlib.DotNet.ModuleDef,dnlib.DotNet.MarshalType,dnlib.DotNet.Writer.IWriterError)">
            <summary>
            Creates a field marshal blob from <paramref name="marshalType"/>
            </summary>
            <param name="module">Owner module</param>
            <param name="marshalType">Marshal type</param>
            <param name="helper">Helps this class</param>
            <returns>A field marshal blob or <c>null</c> if <paramref name="marshalType"/> is
            <c>null</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.MarshalBlobWriter.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.MaxStackCalculator">
            <summary>
            Calculates max stack usage by using a simple pass over all instructions. This value
            can be placed in the fat method header's MaxStack field.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MaxStackCalculator.GetMaxStack(System.Collections.Generic.IList{dnlib.DotNet.Emit.Instruction},System.Collections.Generic.IList{dnlib.DotNet.Emit.ExceptionHandler})">
            <summary>
            Gets max stack value
            </summary>
            <param name="instructions">All instructions</param>
            <param name="exceptionHandlers">All exception handlers</param>
            <returns>Max stack value</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.MaxStackCalculator.GetMaxStack(System.Collections.Generic.IList{dnlib.DotNet.Emit.Instruction},System.Collections.Generic.IList{dnlib.DotNet.Emit.ExceptionHandler},System.UInt32@)">
            <summary>
            Gets max stack value
            </summary>
            <param name="instructions">All instructions</param>
            <param name="exceptionHandlers">All exception handlers</param>
            <param name="maxStack">Updated with max stack value</param>
            <returns><c>true</c> if no errors were detected, <c>false</c> otherwise</returns>
        </member>
        <member name="T:dnlib.DotNet.Writer.IMDTable">
            <summary>
            MD table interface
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.IMDTable.Table">
            <summary>
            Gets the table type
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.IMDTable.IsEmpty">
            <summary>
            <c>true</c> if the table is empty
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.IMDTable.Rows">
            <summary>
            Gets the number of rows in this table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.IMDTable.IsSorted">
            <summary>
            Gets/sets a value indicating whether it's sorted
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.IMDTable.IsReadOnly">
            <summary>
            <c>true</c> if <see cref="M:dnlib.DotNet.Writer.IMDTable.SetReadOnly"/> has been called
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.IMDTable.TableInfo">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.Writer.IMDTable.TableInfo"/>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.IMDTable.SetReadOnly">
            <summary>
            Called when the table can't be modified any more
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.MDTable`1">
            <summary>
            Creates rows in a table. Rows can optionally be shared to create a compact table.
            </summary>
            <typeparam name="TRow">The raw row type</typeparam>
        </member>
        <member name="P:dnlib.DotNet.Writer.MDTable`1.Table">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.MDTable`1.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.MDTable`1.Rows">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.MDTable`1.IsSorted">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.MDTable`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.MDTable`1.TableInfo">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.MDTable`1.Item(System.UInt32)">
            <summary>
            Gets the value with rid <paramref name="rid"/>
            </summary>
            <param name="rid">The row ID</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTable`1.#ctor(dnlib.DotNet.MD.Table,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor
            </summary>
            <param name="table">The table type</param>
            <param name="equalityComparer">Equality comparer</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTable`1.SetReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTable`1.Add(`0)">
            <summary>
            Adds a row. If the row already exists, returns a rid to the existing one, else
            it's created and a new rid is returned.
            </summary>
            <param name="row">The row. It's now owned by us and must NOT be modified by the caller.</param>
            <returns>The RID (row ID) of the row</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTable`1.Create(`0)">
            <summary>
            Creates a new row even if this row already exists.
            </summary>
            <param name="row">The row. It's now owned by us and must NOT be modified by the caller.</param>
            <returns>The RID (row ID) of the row</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTable`1.ReAddRows">
            <summary>
            Re-adds all added rows. Should be called if rows have been modified after being
            inserted.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTable`1.Reset">
            <summary>
            Reset the table.
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.MDTableWriter">
            <summary>
            Writes <see cref="T:dnlib.DotNet.Writer.MDTable`1"/>s
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawModuleRow})">
            <summary>
            Writes a <c>Module</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawTypeRefRow})">
            <summary>
            Writes a <c>TypeRef</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawTypeDefRow})">
            <summary>
            Writes a <c>TypeDef</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawFieldPtrRow})">
            <summary>
            Writes a <c>FieldPtr</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawFieldRow})">
            <summary>
            Writes a <c>Field</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawMethodPtrRow})">
            <summary>
            Writes a <c>MethodPtr</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawMethodRow})">
            <summary>
            Writes a <c>Method</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawParamPtrRow})">
            <summary>
            Writes a <c>ParamPtr</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawParamRow})">
            <summary>
            Writes a <c>Param</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawInterfaceImplRow})">
            <summary>
            Writes a <c>InterfaceImpl</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawMemberRefRow})">
            <summary>
            Writes a <c>MemberRef</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawConstantRow})">
            <summary>
            Writes a <c>Constant</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawCustomAttributeRow})">
            <summary>
            Writes a <c>CustomAttribute</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawFieldMarshalRow})">
            <summary>
            Writes a <c>FieldMarshal</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawDeclSecurityRow})">
            <summary>
            Writes a <c>DeclSecurity</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawClassLayoutRow})">
            <summary>
            Writes a <c>ClassLayout</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawFieldLayoutRow})">
            <summary>
            Writes a <c>FieldLayout</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawStandAloneSigRow})">
            <summary>
            Writes a <c>StandAloneSig</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawEventMapRow})">
            <summary>
            Writes a <c>EventMap</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawEventPtrRow})">
            <summary>
            Writes a <c>EventPtr</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawEventRow})">
            <summary>
            Writes a <c>Event</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawPropertyMapRow})">
            <summary>
            Writes a <c>PropertyMap</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawPropertyPtrRow})">
            <summary>
            Writes a <c>PropertyPtr</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawPropertyRow})">
            <summary>
            Writes a <c>Property</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawMethodSemanticsRow})">
            <summary>
            Writes a <c>MethodSemantics</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawMethodImplRow})">
            <summary>
            Writes a <c>MethodImpl</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawModuleRefRow})">
            <summary>
            Writes a <c>ModuleRef</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawTypeSpecRow})">
            <summary>
            Writes a <c>TypeSpec</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawImplMapRow})">
            <summary>
            Writes a <c>ImplMap</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawFieldRVARow})">
            <summary>
            Writes a <c>FieldRVA</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawENCLogRow})">
            <summary>
            Writes a <c>ENCLog</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawENCMapRow})">
            <summary>
            Writes a <c>ENCMap</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawAssemblyRow})">
            <summary>
            Writes a <c>Assembly</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawAssemblyProcessorRow})">
            <summary>
            Writes a <c>AssemblyProcessor</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawAssemblyOSRow})">
            <summary>
            Writes a <c>AssemblyOS</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawAssemblyRefRow})">
            <summary>
            Writes a <c>AssemblyRef</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawAssemblyRefProcessorRow})">
            <summary>
            Writes a <c>AssemblyRefProcessor</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawAssemblyRefOSRow})">
            <summary>
            Writes a <c>AssemblyRefOS</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawFileRow})">
            <summary>
            Writes a <c>File</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawExportedTypeRow})">
            <summary>
            Writes a <c>ExportedType</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawManifestResourceRow})">
            <summary>
            Writes a <c>ManifestResource</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawNestedClassRow})">
            <summary>
            Writes a <c>NestedClass</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawGenericParamRow})">
            <summary>
            Writes a <c>GenericParam</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawMethodSpecRow})">
            <summary>
            Writes a <c>MethodSpec</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawGenericParamConstraintRow})">
            <summary>
            Writes a <c>GenericParamConstraint</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawDocumentRow})">
            <summary>
            Writes a <c>Document</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawMethodDebugInformationRow})">
            <summary>
            Writes a <c>MethodDebugInformation</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawLocalScopeRow})">
            <summary>
            Writes a <c>LocalScope</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawLocalVariableRow})">
            <summary>
            Writes a <c>LocalVariable</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawLocalConstantRow})">
            <summary>
            Writes a <c>LocalConstant</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawImportScopeRow})">
            <summary>
            Writes a <c>ImportScope</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawStateMachineMethodRow})">
            <summary>
            Writes a <c>StateMachineMethod</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MDTableWriter.Write(dnlib.DotNet.Writer.DataWriter,dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MDTable{dnlib.DotNet.MD.RawCustomDebugInformationRow})">
            <summary>
            Writes a <c>CustomDebugInformation</c> table
            </summary>
            <param name="writer">Writer</param>
            <param name="metadata">Metadata</param>
            <param name="table">Table</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.MetadataFlags">
            <summary>
            <see cref="T:dnlib.DotNet.Writer.Metadata"/> flags
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveTypeRefRids">
            <summary>
            Preserves all rids in the <c>TypeRef</c> table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveTypeDefRids">
            <summary>
            Preserves all rids in the <c>TypeDef</c> table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveFieldRids">
            <summary>
            Preserves all rids in the <c>Field</c> table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveMethodRids">
            <summary>
            Preserves all rids in the <c>Method</c> table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveParamRids">
            <summary>
            Preserves all rids in the <c>Param</c> table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveMemberRefRids">
            <summary>
            Preserves all rids in the <c>MemberRef</c> table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveStandAloneSigRids">
            <summary>
            Preserves all rids in the <c>StandAloneSig</c> table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveEventRids">
            <summary>
            Preserves all rids in the <c>Event</c> table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreservePropertyRids">
            <summary>
            Preserves all rids in the <c>Property</c> table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveTypeSpecRids">
            <summary>
            Preserves all rids in the <c>TypeSpec</c> table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveMethodSpecRids">
            <summary>
            Preserves all rids in the <c>MethodSpec</c> table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveAllMethodRids">
            <summary>
            Preserves all method rids, i.e., <c>Method</c>, <c>MemberRef</c> and
            <c>MethodSpec</c> rids.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveRids">
            <summary>
            Preserves all rids in the following tables: <c>TypeRef</c>, <c>TypeDef</c>,
            <c>Field</c>, <c>Method</c>, <c>Param</c>, <c>MemberRef</c>, <c>StandAloneSig</c>,
            <c>Event</c>, <c>Property</c>, <c>TypeSpec</c>, <c>MethodSpec</c>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveStringsOffsets">
            <summary>
            Preserves all offsets in the #Strings heap (the original #Strings heap will be saved
            in the new file). Type names, field names, and other non-user strings are stored
            in the #Strings heap.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveUSOffsets">
            <summary>
            Preserves all offsets in the #US heap (the original #US heap will be saved
            in the new file). User strings (referenced by the ldstr instruction) are stored in
            the #US heap.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveBlobOffsets">
            <summary>
            Preserves all offsets in the #Blob heap (the original #Blob heap will be saved
            in the new file). Custom attributes, signatures and other blobs are stored in the
            #Blob heap.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveExtraSignatureData">
            <summary>
            Preserves the extra data that is present after the original signature in the #Blob
            heap. This extra data shouldn't be present but might be present if an obfuscator
            has added this extra data and is eg. using it to decrypt stuff.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.PreserveAll">
            <summary>
            Preserves as much as possible
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.KeepOldMaxStack">
            <summary>
            The original method body's max stack field should be used and a new one should not
            be calculated.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.AlwaysCreateGuidHeap">
            <summary>
            Always create the #GUID heap even if it's empty
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.AlwaysCreateStringsHeap">
            <summary>
            Always create the #Strings heap even if it's empty
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.AlwaysCreateUSHeap">
            <summary>
            Always create the #US heap even if it's empty
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.AlwaysCreateBlobHeap">
            <summary>
            Always create the #Blob heap even if it's empty
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataFlags.RoslynSortInterfaceImpl">
            <summary>
            Sort the InterfaceImpl table the same way Roslyn sorts it. Roslyn doesn't sort it
            according to the ECMA spec, see https://github.com/dotnet/roslyn/issues/3905
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.MetadataHeapsAddedEventArgs">
            <summary>
            Metadata heaps event args
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataHeapsAddedEventArgs.Metadata">
            <summary>
            Gets the metadata writer
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataHeapsAddedEventArgs.Heaps">
            <summary>
            Gets all heaps
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataHeapsAddedEventArgs.#ctor(dnlib.DotNet.Writer.Metadata,System.Collections.Generic.List{dnlib.DotNet.Writer.IHeap})">
            <summary>
            Constructor
            </summary>
            <param name="metadata">Metadata writer</param>
            <param name="heaps">All heaps</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.MetadataOptions">
            <summary>
            <see cref="T:dnlib.DotNet.Writer.Metadata"/> options
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataOptions.MetadataHeaderOptions">
            <summary>
            Gets/sets the <see cref="T:dnlib.DotNet.Writer.MetadataHeader"/> options. This is never <c>null</c>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataOptions.DebugMetadataHeaderOptions">
            <summary>
            Gets/sets the debug (portable PDB) <see cref="T:dnlib.DotNet.Writer.MetadataHeader"/> options. This is never <c>null</c>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataOptions.TablesHeapOptions">
            <summary>
            Gets/sets the <see cref="T:dnlib.DotNet.Writer.TablesHeap"/> options. This is never <c>null</c>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataOptions.DebugTablesHeapOptions">
            <summary>
            Gets/sets the debug (portable PDB) <see cref="T:dnlib.DotNet.Writer.TablesHeap"/> options. This is never <c>null</c>.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataOptions.Flags">
            <summary>
            Various options
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataOptions.CustomHeaps">
            <summary>
            Extra heaps to add to the metadata. Also see <see cref="E:dnlib.DotNet.Writer.MetadataOptions.MetadataHeapsAdded"/> and <see cref="M:dnlib.DotNet.Writer.MetadataOptions.PreserveHeapOrder(dnlib.DotNet.ModuleDef,System.Boolean)"/>
            </summary>
        </member>
        <member name="E:dnlib.DotNet.Writer.MetadataOptions.MetadataHeapsAdded">
            <summary>
            Raised after all heaps have been added. The caller can sort the list if needed
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataOptions.PreserveHeapOrder(dnlib.DotNet.ModuleDef,System.Boolean)">
            <summary>
            Preserves the original order of heaps, and optionally adds all custom heaps to <see cref="P:dnlib.DotNet.Writer.MetadataOptions.CustomHeaps"/>.
            </summary>
            <param name="module">Original module with the heaps</param>
            <param name="addCustomHeaps">If true, all custom streams are added to <see cref="P:dnlib.DotNet.Writer.MetadataOptions.CustomHeaps"/></param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataOptions.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataOptions.#ctor(dnlib.DotNet.Writer.MetadataFlags)">
            <summary>
            Constructor
            </summary>
            <param name="flags">Flags</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataOptions.#ctor(dnlib.DotNet.Writer.MetadataHeaderOptions)">
            <summary>
            Constructor
            </summary>
            <param name="mdhOptions">Meta data header options</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataOptions.#ctor(dnlib.DotNet.Writer.MetadataHeaderOptions,dnlib.DotNet.Writer.MetadataFlags)">
            <summary>
            Constructor
            </summary>
            <param name="mdhOptions">Meta data header options</param>
            <param name="flags">Flags</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.DebugMetadataKind">
            <summary>
            Portable PDB metadata kind
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.DebugMetadataKind.None">
            <summary>
            No debugging metadata
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.DebugMetadataKind.Standalone">
            <summary>
            Standalone / embedded portable PDB metadata
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.MetadataWriterEventArgs">
            <summary>
            Metadata writer event args
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataWriterEventArgs.Metadata">
            <summary>
            Gets the metadata writer
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataWriterEventArgs.Event">
            <summary>
            Gets the event
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataWriterEventArgs.#ctor(dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.MetadataEvent)">
            <summary>
            Constructor
            </summary>
            <param name="metadata">Writer</param>
            <param name="event">Event</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.MetadataProgressEventArgs">
            <summary>
            Metadata writer progress event args
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataProgressEventArgs.Metadata">
            <summary>
            Gets the metadata writer
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataProgressEventArgs.Progress">
            <summary>
            Gets the progress, 0.0 - 1.0
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataProgressEventArgs.#ctor(dnlib.DotNet.Writer.Metadata,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="metadata">Writer</param>
            <param name="progress">Progress, 0.0 - 1.0</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.Metadata">
            <summary>
            .NET meta data
            </summary>
        </member>
        <member name="E:dnlib.DotNet.Writer.Metadata.MetadataEvent">
            <summary>
            Raised at various times when writing the metadata
            </summary>
        </member>
        <member name="E:dnlib.DotNet.Writer.Metadata.ProgressUpdated">
            <summary>
            Raised when the progress is updated
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.Logger">
            <summary>
            Gets/sets the logger
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.Module">
            <summary>
            Gets the module
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.Constants">
            <summary>
            Gets the constants
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.MethodBodyChunks">
            <summary>
            Gets the method body chunks
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.NetResources">
            <summary>
            Gets the .NET resources
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.MetadataHeader">
            <summary>
            Gets the MD header
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.TablesHeap">
            <summary>
            Gets the tables heap. Access to this heap is not recommended, but is useful if you
            want to add random table entries.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.StringsHeap">
            <summary>
            Gets the #Strings heap. Access to this heap is not recommended, but is useful if you
            want to add random strings.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.USHeap">
            <summary>
            Gets the #US heap. Access to this heap is not recommended, but is useful if
            you want to add random user strings.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.GuidHeap">
            <summary>
            Gets the #GUID heap. Access to this heap is not recommended, but is useful if you
            want to add random GUIDs.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.BlobHeap">
            <summary>
            Gets the #Blob heap. Access to this heap is not recommended, but is useful if you
            want to add random blobs.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PdbHeap">
            <summary>
            Gets the #Pdb heap. It's only used if it's portable PDB metadata
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.ExportedMethods">
            <summary>
            Gets all exported methods
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.AssemblyPublicKey">
            <summary>
            The public key that should be used instead of the one in <see cref="T:dnlib.DotNet.AssemblyDef"/>.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.Create(dnlib.DotNet.ModuleDef,dnlib.DotNet.Writer.UniqueChunkList{dnlib.DotNet.Writer.ByteArrayChunk},dnlib.DotNet.Writer.MethodBodyChunks,dnlib.DotNet.Writer.NetResources,dnlib.DotNet.Writer.MetadataOptions,dnlib.DotNet.Writer.DebugMetadataKind)">
            <summary>
            Creates a <see cref="T:dnlib.DotNet.Writer.Metadata"/> instance
            </summary>
            <param name="module">Module</param>
            <param name="constants">Constants list</param>
            <param name="methodBodies">Method bodies list</param>
            <param name="netResources">.NET resources list</param>
            <param name="options">Options</param>
            <param name="debugKind">Debug metadata kind</param>
            <returns>A new <see cref="T:dnlib.DotNet.Writer.Metadata"/> instance</returns>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.RVA">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveTypeRefRids">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveTypeRefRids"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveTypeDefRids">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveTypeDefRids"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveFieldRids">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveFieldRids"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveMethodRids">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveMethodRids"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveParamRids">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveParamRids"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveMemberRefRids">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveMemberRefRids"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveStandAloneSigRids">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveStandAloneSigRids"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveEventRids">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveEventRids"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreservePropertyRids">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreservePropertyRids"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveTypeSpecRids">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveTypeSpecRids"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveMethodSpecRids">
            <summary>
            Gets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveMethodSpecRids"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveStringsOffsets">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveStringsOffsets"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveUSOffsets">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveUSOffsets"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveBlobOffsets">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveBlobOffsets"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.PreserveExtraSignatureData">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.PreserveExtraSignatureData"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.KeepOldMaxStack">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.KeepOldMaxStack"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.AlwaysCreateGuidHeap">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.AlwaysCreateGuidHeap"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.AlwaysCreateStringsHeap">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.AlwaysCreateStringsHeap"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.AlwaysCreateUSHeap">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.AlwaysCreateUSHeap"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.AlwaysCreateBlobHeap">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.AlwaysCreateBlobHeap"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.RoslynSortInterfaceImpl">
            <summary>
            Gets/sets the <see cref="F:dnlib.DotNet.Writer.MetadataFlags.RoslynSortInterfaceImpl"/> bit
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.KeepFieldRVA">
            <summary>
            If <c>true</c>, use the original Field RVAs. If it has no RVA, assume it's a new
            field value and create a new Field RVA.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Metadata.NumberOfMethods">
            <summary>
            Gets the number of methods that will be written.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.ModuleDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="module">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.TypeRef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="tr">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.TypeDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="td">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.FieldDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="fd">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.MethodDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="md">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.ParamDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="pd">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.InterfaceImpl)">
            <summary>
            Gets the new rid
            </summary>
            <param name="ii">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.MemberRef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="mr">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetConstantRid(dnlib.DotNet.IHasConstant)">
            <summary>
            Gets the new rid
            </summary>
            <param name="hc">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetCustomAttributeRid(dnlib.DotNet.CustomAttribute)">
            <summary>
            Gets the new rid
            </summary>
            <param name="ca">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetFieldMarshalRid(dnlib.DotNet.IHasFieldMarshal)">
            <summary>
            Gets the new rid
            </summary>
            <param name="hfm">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.DeclSecurity)">
            <summary>
            Gets the new rid
            </summary>
            <param name="ds">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetClassLayoutRid(dnlib.DotNet.TypeDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="td">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetFieldLayoutRid(dnlib.DotNet.FieldDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="fd">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.StandAloneSig)">
            <summary>
            Gets the new rid
            </summary>
            <param name="sas">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetEventMapRid(dnlib.DotNet.TypeDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="td">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.EventDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="ed">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetPropertyMapRid(dnlib.DotNet.TypeDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="td">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.PropertyDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="pd">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetMethodSemanticsRid(dnlib.DotNet.MethodDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="md">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.ModuleRef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="mr">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.TypeSpec)">
            <summary>
            Gets the new rid
            </summary>
            <param name="ts">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetImplMapRid(dnlib.DotNet.IMemberForwarded)">
            <summary>
            Gets the new rid
            </summary>
            <param name="mf">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetFieldRVARid(dnlib.DotNet.FieldDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="fd">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.AssemblyDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="asm">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.AssemblyRef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="asmRef">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.FileDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="fd">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.ExportedType)">
            <summary>
            Gets the new rid
            </summary>
            <param name="et">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetManifestResourceRid(dnlib.DotNet.Resource)">
            <summary>
            Gets the new rid
            </summary>
            <param name="resource">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetNestedClassRid(dnlib.DotNet.TypeDef)">
            <summary>
            Gets the new rid
            </summary>
            <param name="td">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.GenericParam)">
            <summary>
            Gets the new rid
            </summary>
            <param name="gp">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.MethodSpec)">
            <summary>
            Gets the new rid
            </summary>
            <param name="ms">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.GenericParamConstraint)">
            <summary>
            Gets the new rid
            </summary>
            <param name="gpc">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.Pdb.PdbDocument)">
            <summary>
            Gets the new rid
            </summary>
            <param name="doc">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.Pdb.PdbScope)">
            <summary>
            Gets the new rid
            </summary>
            <param name="scope">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.Pdb.PdbLocal)">
            <summary>
            Gets the new rid
            </summary>
            <param name="local">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.Pdb.PdbConstant)">
            <summary>
            Gets the new rid
            </summary>
            <param name="constant">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetRid(dnlib.DotNet.Pdb.PdbImportScope)">
            <summary>
            Gets the new rid
            </summary>
            <param name="importScope">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetStateMachineMethodRid(dnlib.DotNet.Pdb.PdbAsyncMethodCustomDebugInfo)">
            <summary>
            Gets the new rid
            </summary>
            <param name="asyncMethod">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetStateMachineMethodRid(dnlib.DotNet.Pdb.PdbIteratorMethodCustomDebugInfo)">
            <summary>
            Gets the new rid
            </summary>
            <param name="iteratorMethod">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetCustomDebugInfoRid(dnlib.DotNet.Pdb.PdbCustomDebugInfo)">
            <summary>
            Gets the new rid
            </summary>
            <param name="cdi">Value</param>
            <returns>Its new rid or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetMethodBody(dnlib.DotNet.MethodDef)">
            <summary>
            Gets the <see cref="T:dnlib.DotNet.Writer.MethodBody"/>
            </summary>
            <param name="md">Method</param>
            <returns>The <see cref="T:dnlib.DotNet.Writer.MethodBody"/> or <c>null</c> if <paramref name="md"/> is
            <c>null</c> or not a method defined in this module.</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetLocalVarSigToken(dnlib.DotNet.MethodDef)">
            <summary>
            Gets a method's local variable signature token
            </summary>
            <param name="md">Method</param>
            <returns>Locals sig token or <c>0</c></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetChunk(dnlib.DotNet.EmbeddedResource)">
            <summary>
            Gets the <see cref="T:dnlib.DotNet.Writer.DataReaderChunk"/> where the resource data will be stored
            </summary>
            <param name="er">Embedded resource</param>
            <returns>A <see cref="T:dnlib.DotNet.Writer.DataReaderChunk"/> instance or <c>null</c> if <paramref name="er"/>
            is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetInitialValueChunk(dnlib.DotNet.FieldDef)">
            <summary>
            Gets the <see cref="T:dnlib.DotNet.Writer.ByteArrayChunk"/> where the initial value is stored
            </summary>
            <param name="fd">Field</param>
            <returns>A <see cref="T:dnlib.DotNet.Writer.ByteArrayChunk"/> instance or <c>null</c> if <paramref name="fd"/>
            is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.Error(System.String,System.Object[])">
            <summary>
            Called when an error is detected
            </summary>
            <param name="message">Error message</param>
            <param name="args">Optional message arguments</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.Warning(System.String,System.Object[])">
            <summary>
            Called to warn of something
            </summary>
            <param name="message">Warning message</param>
            <param name="args">Optional message arguments</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.OnMetadataEvent(dnlib.DotNet.Writer.MetadataEvent)">
            <summary>
            Raises <see cref="E:dnlib.DotNet.Writer.Metadata.MetadataEvent"/>
            </summary>
            <param name="evt">Event</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.RaiseProgress(dnlib.DotNet.Writer.MetadataEvent,System.Double)">
            <summary>
            Raises the progress event
            </summary>
            <param name="evt">Base event</param>
            <param name="subProgress">Sub progress</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.CreateTables">
            <summary>
            Creates the .NET metadata tables
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.UpdateMethodRvas">
            <summary>
            Updates each <c>Method</c> row's <c>RVA</c> column if it has any code
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.UpdateFieldRvas">
            <summary>
            Updates the <c>FieldRVA</c> rows
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.InitializeTypeDefsAndMemberDefs">
            <summary>
            Initializes all <c>TypeDef</c>, <c>Field</c>, <c>Method</c>, <c>Event</c>,
            <c>Property</c> and <c>Param</c> rows. Other tables that are related to these six
            tables are also updated. No custom attributes are written yet, though. Method bodies
            aren't written either.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.WriteTypeDefAndMemberDefCustomAttributesAndCustomDebugInfos">
            <summary>
            Writes <c>TypeDef</c>, <c>Field</c>, <c>Method</c>, <c>Event</c>,
            <c>Property</c> and <c>Param</c> custom attributes and custom debug infos.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.InitializeVTableFixups">
            <summary>
            Adds the tokens of all methods in all vtables, if any
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.InitializeEntryPoint">
            <summary>
            Adds the entry point. It's only needed if it's a <see cref="T:dnlib.DotNet.FileDef"/> since if it's
            a <see cref="T:dnlib.DotNet.MethodDef"/>, it will have already been added.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.SortTables">
            <summary>
            Sorts all unsorted tables except <c>GenericParamConstraint</c> and <c>CustomAttribute</c>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.InitializeGenericParamConstraintTable">
            <summary>
            Initializes the <c>GenericParamConstraint</c> table
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.InitializeCustomAttributeAndCustomDebugInfoTables">
            <summary>
            Inserts all custom attribute / custom debug info rows in the tables and sort them
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.WriteMethodBodies">
            <summary>
            Writes all method bodies
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.IsEmpty``1(System.Collections.Generic.IList{``0})">
            <summary>
            Checks whether a list is empty or whether it contains only <c>null</c>s
            </summary>
            <typeparam name="T">Any type</typeparam>
            <param name="list">The list</param>
            <returns><c>true</c> if the list is empty or if it contains only <c>null</c>s, <c>false</c> otherwise</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetToken(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetToken(System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddStandAloneSig(dnlib.DotNet.MethodSig,System.UInt32)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.StandAloneSig"/>
            </summary>
            <param name="methodSig">Method signature</param>
            <param name="origToken">Original <c>StandAloneSig</c> token or 0 if none</param>
            <returns>Its new rid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddStandAloneSig(dnlib.DotNet.FieldSig,System.UInt32)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.StandAloneSig"/>
            </summary>
            <param name="fieldSig">FIeld signature</param>
            <param name="origToken">Original <c>StandAloneSig</c> token or 0 if none</param>
            <returns>Its new rid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddTypeDefOrRef(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>
            </summary>
            <param name="tdr">Value</param>
            <returns>Its encoded token</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddResolutionScope(dnlib.DotNet.IResolutionScope)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.IResolutionScope"/>
            </summary>
            <param name="rs">Value</param>
            <returns>Its encoded token</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddMethodDefOrRef(dnlib.DotNet.IMethodDefOrRef)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.IMethodDefOrRef"/>
            </summary>
            <param name="mdr">Value</param>
            <returns>Its encoded token</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddMemberRefParent(dnlib.DotNet.IMemberRefParent)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.IMemberRefParent"/>
            </summary>
            <param name="parent">Value</param>
            <returns>Its encoded token</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddImplementation(dnlib.DotNet.IImplementation)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.IImplementation"/>
            </summary>
            <param name="impl">Value</param>
            <returns>Its encoded token</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddCustomAttributeType(dnlib.DotNet.ICustomAttributeType)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.ICustomAttributeType"/>
            </summary>
            <param name="cat">Value</param>
            <returns>Its encoded token</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddNestedType(dnlib.DotNet.TypeDef,dnlib.DotNet.TypeDef)">
            <summary>
            Adds a <c>NestedType</c> row
            </summary>
            <param name="nestedType">Nested type</param>
            <param name="declaringType">Declaring type</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddModule(dnlib.DotNet.ModuleDef)">
            <summary>
            Adds a <c>Module</c> row
            </summary>
            <param name="module">Module</param>
            <returns>Its new rid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddModuleRef(dnlib.DotNet.ModuleRef)">
            <summary>
            Adds a <c>ModuleRef</c> row
            </summary>
            <param name="modRef">Module ref</param>
            <returns>Its new rid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddAssemblyRef(dnlib.DotNet.AssemblyRef)">
            <summary>
            Adds an <c>AssemblyRef</c> row
            </summary>
            <param name="asmRef">Assembly ref</param>
            <returns>Its new rid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddAssembly(dnlib.DotNet.AssemblyDef,System.Byte[])">
            <summary>
            Adds an <c>Assembly</c> row
            </summary>
            <param name="asm">Assembly</param>
            <param name="publicKey">The public key that should be used</param>
            <returns>Its new rid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddGenericParams(dnlib.DotNet.MDToken,System.Collections.Generic.IList{dnlib.DotNet.GenericParam})">
            <summary>
            Adds generic parameters
            </summary>
            <param name="token">New token of owner</param>
            <param name="gps">All generic params</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddGenericParam(dnlib.DotNet.MDToken,dnlib.DotNet.GenericParam)">
            <summary>
            Adds a generic param
            </summary>
            <param name="owner">New token of owner</param>
            <param name="gp">Generic paramater</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddGenericParamConstraints(System.UInt32,System.Collections.Generic.IList{dnlib.DotNet.GenericParamConstraint})">
            <summary>
            Adds generic parameter constraints
            </summary>
            <param name="gpRid">New rid of owner generic param</param>
            <param name="constraints">Its constraints</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddGenericParamConstraint(System.UInt32,dnlib.DotNet.GenericParamConstraint)">
            <summary>
            Adds a generic parameter constraint
            </summary>
            <param name="gpRid">New rid of owner generic param</param>
            <param name="gpc">Generic parameter constraint</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddInterfaceImpls(System.UInt32,System.Collections.Generic.IList{dnlib.DotNet.InterfaceImpl})">
            <summary>
            Adds a <c>InterfaceImpl</c> row
            </summary>
            <param name="typeDefRid">New rid of owner</param>
            <param name="ifaces">All interfaces</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddFieldLayout(dnlib.DotNet.FieldDef)">
            <summary>
            Adds a <c>FieldLayout</c> row
            </summary>
            <param name="field">Owner field</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddFieldMarshal(dnlib.DotNet.MDToken,dnlib.DotNet.IHasFieldMarshal)">
            <summary>
            Adds a <c>FieldMarshal</c> row
            </summary>
            <param name="parent">New owner token</param>
            <param name="hfm">Owner</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddFieldRVA(dnlib.DotNet.FieldDef)">
            <summary>
            Adds a <c>FieldRVA</c> row
            </summary>
            <param name="field">The field</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddImplMap(dnlib.DotNet.MDToken,dnlib.DotNet.IMemberForwarded)">
            <summary>
            Adds a <c>ImplMap</c> row
            </summary>
            <param name="parent">New owner token</param>
            <param name="mf">Owner</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddConstant(dnlib.DotNet.MDToken,dnlib.DotNet.IHasConstant)">
            <summary>
            Adds a <c>Constant</c> row
            </summary>
            <param name="parent">New owner token</param>
            <param name="hc">Owner</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddDeclSecurities(dnlib.DotNet.MDToken,System.Collections.Generic.IList{dnlib.DotNet.DeclSecurity})">
            <summary>
            Adds a <c>DeclSecurity</c> row
            </summary>
            <param name="parent">New owner token</param>
            <param name="declSecurities">All <c>DeclSecurity</c> rows</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddMethodSemantics(dnlib.DotNet.EventDef)">
            <summary>
            Adds <c>MethodSemantics</c> rows
            </summary>
            <param name="evt">Event</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddMethodSemantics(dnlib.DotNet.PropertyDef)">
            <summary>
            Adds <c>MethodSemantics</c> rows
            </summary>
            <param name="prop">Property</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddClassLayout(dnlib.DotNet.TypeDef)">
            <summary>
            Adds a <c>ClassLayout</c> row
            </summary>
            <param name="type">Type</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddFile(dnlib.DotNet.FileDef)">
            <summary>
            Adds a <c>File</c> row
            </summary>
            <param name="file">File</param>
            <returns>Its new rid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddExportedType(dnlib.DotNet.ExportedType)">
            <summary>
            Adds a <c>ExportedType</c> row
            </summary>
            <param name="et">Exported type</param>
            <returns>Its new rid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetSignature(dnlib.DotNet.TypeSig,System.Byte[])">
            <summary>
            Gets a #Blob offset of a type signature
            </summary>
            <param name="ts">Type sig</param>
            <param name="extraData">Extra data to append the signature if
            <see cref="P:dnlib.DotNet.Writer.Metadata.PreserveExtraSignatureData"/> is <c>true</c>.</param>
            <returns>#Blob offset</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetSignature(dnlib.DotNet.CallingConventionSig)">
            <summary>
            Gets a #Blob offset of a calling convention signature
            </summary>
            <param name="sig">Signature</param>
            <returns>#Blob offset</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddCustomAttributes(dnlib.DotNet.MD.Table,System.UInt32,dnlib.DotNet.IHasCustomAttribute)">
            <summary>
            Adds a <c>CustomAttribute</c> row
            </summary>
            <param name="table">Owner table</param>
            <param name="rid">New owner rid</param>
            <param name="hca">Onwer</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddCustomDebugInformationList(dnlib.DotNet.MD.Table,System.UInt32,dnlib.DotNet.IHasCustomDebugInformation)">
            <summary>
            Adds a <c>CustomDebugInformation</c> row
            </summary>
            <param name="table">Owner table</param>
            <param name="rid">New owner rid</param>
            <param name="hcdi">Onwer</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.WritePortablePdb(System.IO.Stream,System.UInt32,System.Int64@)">
            <summary>
            Writes the portable PDB to <paramref name="output"/>.
            </summary>
            <param name="output">Output stream</param>
            <param name="entryPointToken">Entry point token</param>
            <param name="pdbIdOffset">Updated with the offset of the 20-byte PDB ID. The caller is responsible for initializing it with the PDB ID</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.dnlib#DotNet#Writer#ISignatureWriterHelper#ToEncodedToken(dnlib.DotNet.ITypeDefOrRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.dnlib#DotNet#Writer#IWriterError#Error(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.dnlib#DotNet#IFullNameFactoryHelper#MustUseAssemblyName(dnlib.DotNet.IType)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.Initialize">
            <summary>
            Called before any other methods
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetAllTypeDefs">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.TypeDef"/>s that should be saved in the meta data
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AllocateTypeDefRids">
            <summary>
            Initializes <c>TypeDef</c> rids and creates raw rows, but does not initialize
            any columns.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AllocateMemberDefRids">
            <summary>
            Allocates <c>Field</c>, <c>Method</c>, <c>Property</c>, <c>Event</c>, <c>Param</c>:
            rid and raw row, but doesn't initialize the raw row.
            Initializes <c>TypeDef</c> columns: <c>FieldList</c>, <c>MethodList</c>.
            Initializes <c>Method</c> column: <c>ParamList</c>.
            Initializes <see cref="F:dnlib.DotNet.Writer.Metadata.eventMapInfos"/> and <see cref="F:dnlib.DotNet.Writer.Metadata.propertyMapInfos"/>.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddTypeRef(dnlib.DotNet.TypeRef)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.TypeRef"/>. Its custom attributes are also added.
            </summary>
            <param name="tr">Type reference</param>
            <returns>Its new rid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddTypeSpec(dnlib.DotNet.TypeSpec)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.TypeSpec"/>. Its custom attributes are also added.
            </summary>
            <param name="ts">Type spec</param>
            <returns>Its new rid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddMemberRef(dnlib.DotNet.MemberRef)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.MemberRef"/>. Its custom attributes are also added.
            </summary>
            <param name="mr">Member ref</param>
            <returns>Its new rid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddStandAloneSig(dnlib.DotNet.StandAloneSig)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.StandAloneSig"/>. Its custom attributes are also added.
            </summary>
            <param name="sas">Stand alone sig</param>
            <returns>Its new rid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.AddMethodSpec(dnlib.DotNet.MethodSpec)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.MethodSpec"/>. Its custom attributes are also added.
            </summary>
            <param name="ms">Method spec</param>
            <returns>Its new rid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.BeforeSortingCustomAttributes">
            <summary>
            Called before sorting the <c>CustomAttribute</c> table. This is the last time anything
            can be inserted into this table.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.EverythingInitialized">
            <summary>
            Called after everything has been initialized. The sub class can initialize more
            rows if necessary or do nothing. After this method has been called, nothing else
            can be added.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.OnBeforeSetOffset">
            <summary>
            Should be called before all chunks get an RVA
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.Metadata.Sort(System.Collections.Generic.IEnumerable{dnlib.DotNet.ParamDef})">
            <summary>
            Sorts the <see cref="T:dnlib.DotNet.ParamDef"/>s
            </summary>
            <param name="pds">All <see cref="T:dnlib.DotNet.ParamDef"/>s</param>
            <returns>A sorted <see cref="T:dnlib.DotNet.ParamDef"/> list</returns>
        </member>
        <member name="T:dnlib.DotNet.Writer.MetadataEvent">
            <summary>
            All <see cref="T:dnlib.DotNet.Writer.Metadata"/> events
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.BeginCreateTables">
            <summary>
            Creating the tables has just begun
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.AllocateTypeDefRids">
            <summary>
            Before allocating all TypeDef RIDs
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.AllocateMemberDefRids">
            <summary>
            Before allocating all MemberDef RIDs
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.MemberDefRidsAllocated">
            <summary>
            The <c>rid</c>s of types, fields, methods, events, properties and parameters are
            now known.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.MemberDefsInitialized">
            <summary>
            The tables and rows of all types, fields, methods, events, properties and parameters
            have been initialized. Method body RVAs are still not known, and no method has been
            written yet.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.BeforeSortTables">
            <summary>
            Before sorting most tables
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.MostTablesSorted">
            <summary>
            Most of the tables that should be sorted have been sorted. The <c>CustomAttribute</c>
            table is still unsorted since it's not been created yet.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.MemberDefCustomAttributesWritten">
            <summary>
            Custom attributes of all types, fields, methods, events, properties and parameters
            have now been written.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.BeginAddResources">
            <summary>
            All resources are about to be added to the .NET resources table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.EndAddResources">
            <summary>
            All resources have been added to the .NET resources table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.BeginWriteMethodBodies">
            <summary>
            All method bodies are about to be written
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.EndWriteMethodBodies">
            <summary>
            All method bodies have been written. Their RVAs are still not known.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.OnAllTablesSorted">
            <summary>
            All tables are now sorted, including the <c>CustomAttribute</c> table.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataEvent.EndCreateTables">
            <summary>
            All tables have been created and all rows populated. The only columns that haven't
            been initialized yet are the ones that are RVAs.
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.MetadataHeaderOptions">
            <summary>
            <see cref="T:dnlib.DotNet.Writer.MetadataHeader"/> options
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataHeaderOptions.DEFAULT_VERSION_STRING">
            <summary>
            Default version string
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataHeaderOptions.DEFAULT_SIGNATURE">
            <summary>
            Default header signature
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataHeaderOptions.Signature">
            <summary>
            MD header signature. Default value is <see cref="F:dnlib.DotNet.Writer.MetadataHeaderOptions.DEFAULT_SIGNATURE"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataHeaderOptions.MajorVersion">
            <summary>
            Major version. Default is 1. MS' CLR supports v0.x (x >= 19) and v1.1, nothing else.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataHeaderOptions.MinorVersion">
            <summary>
            Minor version. Default is 1.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataHeaderOptions.Reserved1">
            <summary>
            Reserved and should be 0.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataHeaderOptions.VersionString">
            <summary>
            Version string. Default is <see cref="F:dnlib.DotNet.Writer.MetadataHeaderOptions.DEFAULT_VERSION_STRING"/>. It's stored as a
            zero-terminated UTF-8 string. Length should be &lt;= 255 bytes.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataHeaderOptions.StorageFlags">
            <summary>
            Storage flags should be 0
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MetadataHeaderOptions.Reserved2">
            <summary>
            Reserved and should be 0
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataHeaderOptions.CreatePortablePdbV1_0">
            <summary>
            Creates portable PDB v1.0 options
            </summary>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.Writer.MetadataHeader">
            <summary>
            Meta data header. IMAGE_COR20_HEADER.Metadata points to this header.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataHeader.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataHeader.RVA">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.MetadataHeader.Heaps">
            <summary>
            Gets/sets the heaps
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataHeader.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataHeader.#ctor(dnlib.DotNet.Writer.MetadataHeaderOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Options</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataHeader.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataHeader.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataHeader.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MetadataHeader.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.MethodBody">
            <summary>
            Method body chunk
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBody.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBody.RVA">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBody.Code">
            <summary>
            Gets the code
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBody.ExtraSections">
            <summary>
            Gets the extra sections (exception handlers) or <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBody.LocalVarSigTok">
            <summary>
            Gets the token of the locals
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBody.IsFat">
            <summary>
            <c>true</c> if it's a fat body
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBody.IsTiny">
            <summary>
            <c>true</c> if it's a tiny body
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBody.HasExtraSections">
            <summary>
            <c>true</c> if there's an extra section
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBody.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="code">Code</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBody.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="code">Code</param>
            <param name="extraSections">Extra sections or <c>null</c></param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBody.#ctor(System.Byte[],System.Byte[],System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="code">Code</param>
            <param name="extraSections">Extra sections or <c>null</c></param>
            <param name="localVarSigTok">Token of locals</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBody.GetApproximateSizeOfMethodBody">
            <summary>
            Gets the approximate size of the method body (code + exception handlers)
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBody.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBody.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBody.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBody.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBody.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBody.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.MethodBodyChunks">
            <summary>
            Stores all method body chunks
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBodyChunks.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBodyChunks.RVA">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBodyChunks.SavedBytes">
            <summary>
            Gets the number of bytes saved by re-using method bodies
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyChunks.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="shareBodies"><c>true</c> if bodies can be shared</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyChunks.Add(dnlib.DotNet.Writer.MethodBody)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.Writer.MethodBody"/> and returns the one that has been cached
            </summary>
            <param name="methodBody">The method body</param>
            <returns>The cached method body</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyChunks.Remove(dnlib.DotNet.Writer.MethodBody)">
            <summary>Removes the specified method body from this chunk</summary>
            <param name="methodBody">The method body</param>
            <returns><see langword="true" /> if the method body is removed</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyChunks.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyChunks.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyChunks.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyChunks.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.ITokenProvider">
            <summary>
            Returns tokens of token types, strings and signatures
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ITokenProvider.GetToken(System.Object)">
            <summary>
            Gets the token of <paramref name="o"/>
            </summary>
            <param name="o">A token type or a string or a signature</param>
            <returns>The token</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.ITokenProvider.GetToken(System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.UInt32)">
            <summary>
            Gets a <c>StandAloneSig</c> token
            </summary>
            <param name="locals">All locals</param>
            <param name="origToken">The original token or <c>0</c> if none</param>
            <returns>A <c>StandAloneSig</c> token or <c>0</c> if <paramref name="locals"/> is
            empty.</returns>
        </member>
        <member name="T:dnlib.DotNet.Writer.MethodBodyWriter">
            <summary>
            Writes CIL method bodies
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBodyWriter.Code">
            <summary>
            Gets the code as a byte array. This is valid only after calling <see cref="M:dnlib.DotNet.Writer.MethodBodyWriter.Write"/>.
            The size of this array is not necessarily a multiple of 4, even if there are exception
            handlers present. See also <see cref="M:dnlib.DotNet.Writer.MethodBodyWriter.GetFullMethodBody"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBodyWriter.ExtraSections">
            <summary>
            Gets the extra sections (exception handlers) as a byte array or <c>null</c> if there
            are no exception handlers. This is valid only after calling <see cref="M:dnlib.DotNet.Writer.MethodBodyWriter.Write"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBodyWriter.LocalVarSigTok">
            <summary>
            Gets the token of the locals
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriter.#ctor(dnlib.DotNet.Writer.ITokenProvider,dnlib.DotNet.Emit.CilBody)">
            <summary>
            Constructor
            </summary>
            <param name="helper">Helps this instance</param>
            <param name="cilBody">The CIL method body</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriter.#ctor(dnlib.DotNet.Writer.ITokenProvider,dnlib.DotNet.Emit.CilBody,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="helper">Helps this instance</param>
            <param name="cilBody">The CIL method body</param>
            <param name="keepMaxStack">Keep the original max stack value that has been initialized
            in <paramref name="cilBody"/></param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriter.Write">
            <summary>
            Writes the method body
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriter.GetFullMethodBody">
            <summary>
            Gets the code and (possible) exception handlers in one array. The exception handlers
            are 4-byte aligned.
            </summary>
            <returns>The code and any exception handlers</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriter.ErrorImpl(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriter.WriteInlineField(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriter.WriteInlineMethod(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriter.WriteInlineSig(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriter.WriteInlineString(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriter.WriteInlineTok(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriter.WriteInlineType(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.MethodBodyWriterBase">
            <summary>
            Base class of all CIL method body writers
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.MethodBodyWriterBase.instructions">
            <summary/>
        </member>
        <member name="F:dnlib.DotNet.Writer.MethodBodyWriterBase.exceptionHandlers">
            <summary/>
        </member>
        <member name="P:dnlib.DotNet.Writer.MethodBodyWriterBase.ErrorDetected">
            <summary>
            <c>true</c> if there was at least one error
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.#ctor(System.Collections.Generic.IList{dnlib.DotNet.Emit.Instruction},System.Collections.Generic.IList{dnlib.DotNet.Emit.ExceptionHandler})">
            <summary>
            Constructor
            </summary>
            <param name="instructions">All instructions</param>
            <param name="exceptionHandlers">All exception handlers</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.Error(System.String)">
            <summary>
            Called when an error is detected (eg. a null pointer). The error can be
            ignored but the method won't be valid.
            </summary>
            <param name="message">Error message</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.ErrorImpl(System.String)">
            <summary>
            Called when an error is detected (eg. a null pointer). The error can be
            ignored but the method won't be valid.
            </summary>
            <param name="message">Error message</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.GetMaxStack">
            <summary>
            Gets max stack value
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.GetOffset(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Gets the offset of an instruction
            </summary>
            <param name="instr">The instruction</param>
            <returns>The offset or <c>0</c> if <paramref name="instr"/> is <c>null</c> or not
            present in the list of all instructions.</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.InitializeInstructionOffsets">
            <summary>
            Initializes instruction offsets and returns the total code size
            </summary>
            <returns>Size of code</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.GetSizeOfInstruction(dnlib.DotNet.Emit.Instruction)">
            <summary>
            Gets the size of an instruction
            </summary>
            <param name="instr">The instruction</param>
            <returns>Size of the instruction in bytes</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInstructions(dnlib.DotNet.Writer.ArrayWriter@)">
            <summary>
            Writes all instructions to <paramref name="writer"/> at its current offset
            </summary>
            <param name="writer">The instruction writer</param>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.ToInstructionOffset(dnlib.DotNet.Writer.ArrayWriter@)">
            <summary>
            Gets the current offset in the instruction stream. This offset is relative to
            the first written instruction.
            </summary>
            <param name="writer">The instruction writer</param>
            <returns>Current offset, relative to the first written instruction</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInstruction(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an instruction
            </summary>
            <param name="writer">The instruction writer</param>
            <param name="instr">The instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteOpCode(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an instruction's opcode
            </summary>
            <param name="writer">The instruction writer</param>
            <param name="instr">The instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteOperand(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an instruction's operand
            </summary>
            <param name="writer">The instruction writer</param>
            <param name="instr">The instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlineBrTarget(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlineBrTarget"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlineField(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlineField"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlineI(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlineI"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlineI8(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlineI8"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlineMethod(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlineMethod"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlineNone(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlineNone"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlinePhi(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlinePhi"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlineR(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlineR"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlineSig(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlineSig"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlineString(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlineString"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlineSwitch(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlineSwitch"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlineTok(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlineTok"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlineType(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlineType"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteInlineVar(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes an <see cref="F:dnlib.DotNet.Emit.OperandType.InlineVar"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteShortInlineBrTarget(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes a <see cref="F:dnlib.DotNet.Emit.OperandType.ShortInlineBrTarget"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteShortInlineI(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes a <see cref="F:dnlib.DotNet.Emit.OperandType.ShortInlineI"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteShortInlineR(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes a <see cref="F:dnlib.DotNet.Emit.OperandType.ShortInlineR"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.MethodBodyWriterBase.WriteShortInlineVar(dnlib.DotNet.Writer.ArrayWriter@,dnlib.DotNet.Emit.Instruction)">
            <summary>
            Writes a <see cref="F:dnlib.DotNet.Emit.OperandType.ShortInlineVar"/> operand
            </summary>
            <param name="writer">Instruction writer</param>
            <param name="instr">Instruction</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.ModuleWriterOptions">
            <summary>
            <see cref="T:dnlib.DotNet.Writer.ModuleWriter"/> options
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterOptions.#ctor(dnlib.DotNet.ModuleDef)">
            <summary>
            Constructor
            </summary>
            <param name="module">The module</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.ModuleWriter">
            <summary>
            Writes a .NET PE file. See also <see cref="T:dnlib.DotNet.Writer.NativeModuleWriter"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.TheOptions">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.Options">
            <summary>
            Gets/sets the writer options. This is never <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.Sections">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.Writer.PESection"/>s. The reloc section must be the last section, so use <see cref="M:dnlib.DotNet.Writer.ModuleWriter.AddSection(dnlib.DotNet.Writer.PESection)"/> if you need to append a section
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriter.AddSection(dnlib.DotNet.Writer.PESection)">
            <summary>
            Adds <paramref name="section"/> to the sections list, but before the reloc section which must be last
            </summary>
            <param name="section">New section to add to the list</param>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.TextSection">
            <summary>
            Gets the <c>.text</c> section
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.SdataSection">
            <summary>
            Gets the <c>.sdata</c> section
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.RsrcSection">
            <summary>
            Gets the <c>.rsrc</c> section or null if none
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.RelocSection">
            <summary>
            Gets the <c>.reloc</c> section
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.PEHeaders">
            <summary>
            Gets the PE headers
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.ImportAddressTable">
            <summary>
            Gets the IAT or <c>null</c> if there's none
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.ImageCor20Header">
            <summary>
            Gets the .NET header
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.ImportDirectory">
            <summary>
            Gets the import directory or <c>null</c> if there's none
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.StartupStub">
            <summary>
            Gets the startup stub or <c>null</c> if there's none
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriter.RelocDirectory">
            <summary>
            Gets the reloc directory or <c>null</c> if there's none
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriter.#ctor(dnlib.DotNet.ModuleDef)">
            <summary>
            Constructor
            </summary>
            <param name="module">The module</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriter.#ctor(dnlib.DotNet.ModuleDef,dnlib.DotNet.Writer.ModuleWriterOptions)">
            <summary>
            Constructor
            </summary>
            <param name="module">The module</param>
            <param name="options">Options or <c>null</c></param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriter.WriteImpl">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriter.GetWin32Resources">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.ModuleWriterEventArgs">
            <summary>
            Module writer event args
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterEventArgs.Writer">
            <summary>
            Gets the writer (<see cref="T:dnlib.DotNet.Writer.ModuleWriter"/> or <see cref="T:dnlib.DotNet.Writer.NativeModuleWriter"/>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterEventArgs.Event">
            <summary>
            Gets the event
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterEventArgs.#ctor(dnlib.DotNet.Writer.ModuleWriterBase,dnlib.DotNet.Writer.ModuleWriterEvent)">
            <summary>
            Constructor
            </summary>
            <param name="writer">Writer</param>
            <param name="event">Event</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.ModuleWriterProgressEventArgs">
            <summary>
            Module writer progress event args
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterProgressEventArgs.Writer">
            <summary>
            Gets the writer (<see cref="T:dnlib.DotNet.Writer.ModuleWriter"/> or <see cref="T:dnlib.DotNet.Writer.NativeModuleWriter"/>)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterProgressEventArgs.Progress">
            <summary>
            Gets the progress, 0.0 - 1.0
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterProgressEventArgs.#ctor(dnlib.DotNet.Writer.ModuleWriterBase,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="writer">Writer</param>
            <param name="progress">Progress, 0.0 - 1.0</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.ContentId">
            <summary>
            Content ID
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ContentId.Guid">
            <summary>
            Gets the GUID
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ContentId.Timestamp">
            <summary>
            Gets the timestamp
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ContentId.#ctor(System.Guid,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="guid">Guid</param>
            <param name="timestamp">Timestamp</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.EventHandler2`1">
            <summary>
            Event handler
            </summary>
            <typeparam name="TEventArgs">Event args type</typeparam>
            <param name="sender">Sender</param>
            <param name="e">Event args</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.PdbWriterOptions">
            <summary>
            PDB writer options
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PdbWriterOptions.None">
            <summary>
            No bit is set
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PdbWriterOptions.NoDiaSymReader">
            <summary>
            Don't use Microsoft.DiaSymReader.Native. This is a NuGet package with an updated Windows PDB reader/writer implementation,
            and if it's available at runtime, dnlib will try to use it. If this option is set, dnlib won't use it.
            You have to add a reference to the NuGet package if you want to use it, dnlib has no reference to the NuGet package.
            
            This is only used if it's a Windows PDB file.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PdbWriterOptions.NoOldDiaSymReader">
            <summary>
            Don't use diasymreader.dll's PDB writer that is shipped with .NET Framework.
            
            This is only used if it's a Windows PDB file.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PdbWriterOptions.Deterministic">
            <summary>
            Create a deterministic PDB file and add a <see cref="F:dnlib.PE.ImageDebugType.Reproducible"/> debug directory entry to the PE file.
            
            It's ignored if the PDB writer doesn't support it.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PdbWriterOptions.PdbChecksum">
            <summary>
            Hash the PDB file and add a PDB checksum debug directory entry to the PE file.
            
            It's ignored if the PDB writer doesn't support it.
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.ModuleWriterOptionsBase">
            <summary>
            Common module writer options base class
            </summary>
        </member>
        <member name="E:dnlib.DotNet.Writer.ModuleWriterOptionsBase.WriterEvent">
            <summary>
            Raised at various times when writing the file. The listener has a chance to modify
            the file, eg. add extra metadata, encrypt methods, etc.
            </summary>
        </member>
        <member name="E:dnlib.DotNet.Writer.ModuleWriterOptionsBase.ProgressUpdated">
            <summary>
            Raised when the progress is updated
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.Logger">
            <summary>
            Gets/sets the logger. If this is <c>null</c>, any errors result in a
            <see cref="T:dnlib.DotNet.Writer.ModuleWriterException"/> being thrown. To disable this behavior, either
            create your own logger or use <see cref="F:dnlib.DotNet.DummyLogger.NoThrowInstance"/>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.MetadataLogger">
            <summary>
            Gets/sets the <see cref="T:dnlib.DotNet.Writer.Metadata"/> writer logger. If this is <c>null</c>, use
            <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.Logger"/>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.PEHeadersOptions">
            <summary>
            Gets/sets the <see cref="T:dnlib.DotNet.Writer.PEHeaders"/> options. This is never <c>null</c>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.Cor20HeaderOptions">
            <summary>
            Gets/sets the <see cref="T:dnlib.DotNet.Writer.ImageCor20Header"/> options. This is never <c>null</c>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.MetadataOptions">
            <summary>
            Gets/sets the <see cref="T:dnlib.DotNet.Writer.Metadata"/> options. This is never <c>null</c>.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.Win32Resources">
            <summary>
            Gets/sets the Win32 resources. If this is <c>null</c>, use the module's
            Win32 resources if any.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.DelaySign">
            <summary>
            true to delay sign the assembly. Initialize <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.StrongNamePublicKey"/> to the
            public key to use, and don't initialize <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.StrongNameKey"/>. To generate the
            public key from your strong name key file, execute <c>sn -p mykey.snk mypublickey.snk</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.StrongNameKey">
            <summary>
            Gets/sets the strong name key. When you enhance strong name sign an assembly,
            this instance's HashAlgorithm must be initialized to its public key's HashAlgorithm.
            You should call <see cref="M:dnlib.DotNet.Writer.ModuleWriterOptionsBase.InitializeStrongNameSigning(dnlib.DotNet.ModuleDef,dnlib.DotNet.StrongNameKey)"/>
            to initialize this property if you use normal strong name signing.
            You should call <see cref="M:dnlib.DotNet.Writer.ModuleWriterOptionsBase.InitializeEnhancedStrongNameSigning(dnlib.DotNet.ModuleDef,dnlib.DotNet.StrongNameKey,dnlib.DotNet.StrongNamePublicKey)"/>
            or <see cref="M:dnlib.DotNet.Writer.ModuleWriterOptionsBase.InitializeEnhancedStrongNameSigning(dnlib.DotNet.ModuleDef,dnlib.DotNet.StrongNameKey,dnlib.DotNet.StrongNamePublicKey,dnlib.DotNet.StrongNameKey,dnlib.DotNet.StrongNamePublicKey)"/>
            to initialize this property if you use enhanced strong name signing.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.StrongNamePublicKey">
            <summary>
            Gets/sets the new public key that should be used. If this is <c>null</c>, use
            the public key generated from <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.StrongNameKey"/>. If it is also <c>null</c>,
            use the module's Assembly's public key.
            You should call <see cref="M:dnlib.DotNet.Writer.ModuleWriterOptionsBase.InitializeEnhancedStrongNameSigning(dnlib.DotNet.ModuleDef,dnlib.DotNet.StrongNameKey,dnlib.DotNet.StrongNamePublicKey)"/>
            or <see cref="M:dnlib.DotNet.Writer.ModuleWriterOptionsBase.InitializeEnhancedStrongNameSigning(dnlib.DotNet.ModuleDef,dnlib.DotNet.StrongNameKey,dnlib.DotNet.StrongNamePublicKey,dnlib.DotNet.StrongNameKey,dnlib.DotNet.StrongNamePublicKey)"/>
            to initialize this property if you use enhanced strong name signing.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.ShareMethodBodies">
            <summary>
            <c>true</c> if method bodies can be shared (two or more method bodies can share the
            same RVA), <c>false</c> if method bodies can't be shared. Don't enable it if there
            must be a 1:1 relationship with method bodies and their RVAs.
            This is enabled by default and results in smaller files.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.AddCheckSum">
            <summary>
            <c>true</c> if the PE header CheckSum field should be updated, <c>false</c> if the
            CheckSum field isn't updated.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.Is64Bit">
            <summary>
            <c>true</c> if it's a 64-bit module, <c>false</c> if it's a 32-bit or AnyCPU module.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.ModuleKind">
            <summary>
            Gets/sets the module kind
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.IsExeFile">
            <summary>
            <c>true</c> if it should be written as an EXE file, <c>false</c> if it should be
            written as a DLL file.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.WritePdb">
            <summary>
            Set it to <c>true</c> to enable writing a PDB file. Default is <c>false</c> (a PDB file
            won't be written to disk).
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.PdbOptions">
            <summary>
            PDB writer options. This property is ignored if <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.WritePdb"/> is false.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.PdbFileName">
            <summary>
            PDB file name. If it's <c>null</c> a PDB file with the same name as the output assembly
            will be created but with a PDB extension. <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.WritePdb"/> must be <c>true</c> or
            this property is ignored.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.PdbFileNameInDebugDirectory">
            <summary>
            PDB file name stored in the debug directory, or null to use <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.PdbFileName"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.PdbStream">
            <summary>
            PDB stream. If this is initialized, then you should also set <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.PdbFileName"/>
            to the name of the PDB file since the file name must be written to the PE debug directory.
            <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.WritePdb"/> must be <c>true</c> or this property is ignored.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.GetPdbContentId">
            <summary>
            Gets the PDB content id (portable PDBs). The <see cref="T:System.IO.Stream"/> argument is the PDB stream with the PDB ID zeroed out,
            and the 2nd <see cref="T:System.UInt32"/> argument is the default timestamp.
            This property is ignored if a deterministic PDB file is created or if the PDB checksum is calculated.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.PdbChecksumAlgorithm">
            <summary>
            PDB checksum algorithm
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.AddMvidSection">
            <summary>
            true if an <c>.mvid</c> section should be added to the assembly. Not used by native module writer.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterOptionsBase.#ctor(dnlib.DotNet.ModuleDef)">
            <summary>
            Constructor
            </summary>
            <param name="module">The module</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterOptionsBase.InitializeStrongNameSigning(dnlib.DotNet.ModuleDef,dnlib.DotNet.StrongNameKey)">
            <summary>
            Initializes <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.StrongNameKey"/> and <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.StrongNamePublicKey"/>
            for normal strong name signing.
            </summary>
            <param name="module">Module</param>
            <param name="signatureKey">Signature strong name key pair</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterOptionsBase.InitializeEnhancedStrongNameSigning(dnlib.DotNet.ModuleDef,dnlib.DotNet.StrongNameKey,dnlib.DotNet.StrongNamePublicKey)">
            <summary>
            Initializes <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.StrongNameKey"/> and <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.StrongNamePublicKey"/>
            for enhanced strong name signing (without key migration). See
            http://msdn.microsoft.com/en-us/library/hh415055.aspx
            </summary>
            <param name="module">Module</param>
            <param name="signatureKey">Signature strong name key pair</param>
            <param name="signaturePubKey">Signature public key</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterOptionsBase.InitializeEnhancedStrongNameSigning(dnlib.DotNet.ModuleDef,dnlib.DotNet.StrongNameKey,dnlib.DotNet.StrongNamePublicKey,dnlib.DotNet.StrongNameKey,dnlib.DotNet.StrongNamePublicKey)">
            <summary>
            Initializes <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.StrongNameKey"/> and <see cref="P:dnlib.DotNet.Writer.ModuleWriterOptionsBase.StrongNamePublicKey"/>
            for enhanced strong name signing (with key migration). See
            http://msdn.microsoft.com/en-us/library/hh415055.aspx
            </summary>
            <param name="module">Module</param>
            <param name="signatureKey">Signature strong name key pair</param>
            <param name="signaturePubKey">Signature public key</param>
            <param name="identityKey">Identity strong name key pair</param>
            <param name="identityPubKey">Identity public key</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.ModuleWriterBase">
            <summary>
            Module writer base class
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.DEFAULT_CONSTANTS_ALIGNMENT">
            <summary>Default alignment of all constants</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.DEFAULT_METHODBODIES_ALIGNMENT">
            <summary>Default alignment of all method bodies</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.DEFAULT_NETRESOURCES_ALIGNMENT">
            <summary>Default alignment of all .NET resources</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.DEFAULT_METADATA_ALIGNMENT">
            <summary>Default alignment of the .NET metadata</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.DEFAULT_WIN32_RESOURCES_ALIGNMENT">
            <summary>Default Win32 resources alignment</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.DEFAULT_STRONGNAMESIG_ALIGNMENT">
            <summary>Default strong name signature alignment</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.DEFAULT_COR20HEADER_ALIGNMENT">
            <summary>Default COR20 header alignment</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.destStream">
            <summary>See <see cref="P:dnlib.DotNet.Writer.ModuleWriterBase.DestinationStream"/></summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.constants">
            <summary>See <see cref="P:dnlib.DotNet.Writer.ModuleWriterBase.Constants"/></summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.methodBodies">
            <summary>See <see cref="P:dnlib.DotNet.Writer.ModuleWriterBase.MethodBodies"/></summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.netResources">
            <summary>See <see cref="P:dnlib.DotNet.Writer.ModuleWriterBase.NetResources"/></summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.metadata">
            <summary>See <see cref="P:dnlib.DotNet.Writer.ModuleWriterBase.Metadata"/></summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.win32Resources">
            <summary>See <see cref="P:dnlib.DotNet.Writer.ModuleWriterBase.Win32Resources"/></summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.destStreamBaseOffset">
            <summary>Offset where the module is written. Usually 0.</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.debugDirectory">
            <summary>Debug directory</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.strongNameSignature">
            <summary>
            Strong name signature
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.TheOptions">
            <summary>
            Returns the module writer options
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.DestinationStream">
            <summary>
            Gets the destination stream
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.Constants">
            <summary>
            Gets the constants
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.MethodBodies">
            <summary>
            Gets the method bodies
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.NetResources">
            <summary>
            Gets the .NET resources
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.Metadata">
            <summary>
            Gets the .NET metadata
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.Win32Resources">
            <summary>
            Gets the Win32 resources or <c>null</c> if there's none
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.StrongNameSignature">
            <summary>
            Gets the strong name signature or <c>null</c> if there's none
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.Sections">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.Writer.PESection"/>s. The reloc section must be the last section, so use <see cref="M:dnlib.DotNet.Writer.ModuleWriterBase.AddSection(dnlib.DotNet.Writer.PESection)"/> if you need to append a section
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.AddSection(dnlib.DotNet.Writer.PESection)">
            <summary>
            Adds <paramref name="section"/> to the sections list, but before the reloc section which must be last
            </summary>
            <param name="section">New section to add to the list</param>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.TextSection">
            <summary>
            Gets the <c>.text</c> section
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.RsrcSection">
            <summary>
            Gets the <c>.rsrc</c> section or <c>null</c> if there's none
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.DebugDirectory">
            <summary>
            Gets the debug directory or <c>null</c> if there's none
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.IsNativeWriter">
            <summary>
            <c>true</c> if <c>this</c> is a <see cref="T:dnlib.DotNet.Writer.NativeModuleWriter"/>, <c>false</c> if
            <c>this</c> is a <see cref="T:dnlib.DotNet.Writer.ModuleWriter"/>.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterBase.pdbState">
            <summary>
            null if we're not writing a PDB
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.Write(System.String)">
            <summary>
            Writes the module to a file
            </summary>
            <param name="fileName">File name. The file will be truncated if it exists.</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.Write(System.IO.Stream)">
            <summary>
            Writes the module to a <see cref="T:System.IO.Stream"/>
            </summary>
            <param name="dest">Destination stream</param>
        </member>
        <member name="P:dnlib.DotNet.Writer.ModuleWriterBase.Module">
            <summary>
            Returns the module that is written
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.WriteImpl">
            <summary>
            Writes the module to <see cref="F:dnlib.DotNet.Writer.ModuleWriterBase.destStream"/>. Event listeners and
            <see cref="F:dnlib.DotNet.Writer.ModuleWriterBase.destStream"/> have been initialized when this method is called.
            </summary>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.CreateStrongNameSignature">
            <summary>
            Creates the strong name signature if the module has one of the strong name flags
            set or wants to sign the assembly.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.CreateMetadataChunks(dnlib.DotNet.ModuleDef)">
            <summary>
            Creates the .NET metadata chunks (constants, method bodies, .NET resources,
            the metadata, and Win32 resources)
            </summary>
            <param name="module"></param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.GetWin32Resources">
            <summary>
            Gets the Win32 resources that should be written to the new image or <c>null</c> if none
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.CalculateRvasAndFileOffsets(System.Collections.Generic.List{dnlib.DotNet.Writer.IChunk},dnlib.IO.FileOffset,dnlib.PE.RVA,System.UInt32,System.UInt32)">
            <summary>
            Calculates <see cref="T:dnlib.PE.RVA"/> and <see cref="T:dnlib.IO.FileOffset"/> of all <see cref="T:dnlib.DotNet.Writer.IChunk"/>s
            </summary>
            <param name="chunks">All chunks</param>
            <param name="offset">Starting file offset</param>
            <param name="rva">Starting RVA</param>
            <param name="fileAlignment">File alignment</param>
            <param name="sectionAlignment">Section alignment</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.WriteChunks(dnlib.DotNet.Writer.DataWriter,System.Collections.Generic.List{dnlib.DotNet.Writer.IChunk},dnlib.IO.FileOffset,System.UInt32)">
            <summary>
            Writes all chunks to <paramref name="writer"/>
            </summary>
            <param name="writer">The writer</param>
            <param name="chunks">All chunks</param>
            <param name="offset">File offset of first chunk</param>
            <param name="fileAlignment">File alignment</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.StrongNameSign(System.Int64)">
            <summary>
            Strong name sign the assembly
            </summary>
            <param name="snSigOffset">Strong name signature offset</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.CreateDebugDirectory">
            <summary>
            Creates the debug directory if a PDB file should be written
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.WritePdbFile">
            <summary>
            Write the PDB file. The caller should send the PDB events before and after calling this
            method.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.GetTimeDateStamp">
            <summary>
            Gets the timestamp stored in the PE header
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.OnWriterEvent(dnlib.DotNet.Writer.ModuleWriterEvent)">
            <summary>
            Raises a writer event
            </summary>
            <param name="evt">Event</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.dnlib#DotNet#ILogger#Log(System.Object,dnlib.DotNet.LoggerEvent,System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.dnlib#DotNet#ILogger#IgnoresEvent(dnlib.DotNet.LoggerEvent)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.Error(System.String,System.Object[])">
            <summary>
            Logs an error message
            </summary>
            <param name="format">Format</param>
            <param name="args">Format args</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterBase.Warning(System.String,System.Object[])">
            <summary>
            Logs a warning message
            </summary>
            <param name="format">Format</param>
            <param name="args">Format args</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.ModuleWriterEvent">
            <summary>
            All <see cref="T:dnlib.DotNet.Writer.ModuleWriter"/> / <see cref="T:dnlib.DotNet.Writer.NativeModuleWriter"/> events
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.Begin">
            <summary>
            Writing has just begun
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.PESectionsCreated">
            <summary>
            All PE sections have been created
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.ChunksCreated">
            <summary>
            All chunks have been created
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.ChunksAddedToSections">
            <summary>
            All chunks have been added to their sections
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDBeginCreateTables">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.BeginCreateTables"/>.
            Creating the metadata tables has just begun
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDAllocateTypeDefRids">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.AllocateTypeDefRids"/>.
            Before allocating all TypeDef RIDs
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDAllocateMemberDefRids">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.AllocateMemberDefRids"/>.
            Before allocating all MemberDef RIDs
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDMemberDefRidsAllocated">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.MemberDefRidsAllocated"/>.
            The <c>rid</c>s of types, fields, methods, events, properties and parameters are
            now known.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDMemberDefsInitialized">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.MemberDefsInitialized"/>.
            The tables and rows of all types, fields, methods, events, properties and parameters
            have been initialized. Method body RVAs are still not known, and no method has been
            written yet.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDBeforeSortTables">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.BeforeSortTables"/>.
            Before sorting most tables
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDMostTablesSorted">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.MostTablesSorted"/>.
            Most of the tables that should be sorted have been sorted. The <c>CustomAttribute</c>
            table is still unsorted since it's not been created yet.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDMemberDefCustomAttributesWritten">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.MemberDefCustomAttributesWritten"/>.
            Custom attributes of all types, fields, methods, events, properties and parameters
            have now been written.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDBeginAddResources">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.BeginAddResources"/>.
            All resources are about to be added to the .NET resources table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDEndAddResources">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.EndAddResources"/>.
            All resources have been added to the .NET resources table
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDBeginWriteMethodBodies">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.BeginWriteMethodBodies"/>.
            All method bodies are about to be written
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDEndWriteMethodBodies">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.EndWriteMethodBodies"/>.
            All method bodies have been written. Their RVAs are still not known.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDOnAllTablesSorted">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.OnAllTablesSorted"/>.
            All tables are now sorted, including the <c>CustomAttribute</c> table.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.MDEndCreateTables">
            <summary>
            Original event: <see cref="F:dnlib.DotNet.Writer.MetadataEvent.EndCreateTables"/>.
            All tables have been created and all rows populated. The only columns that haven't
            been initialized yet are the ones that are RVAs.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.BeginWritePdb">
            <summary>
            This event occurs before the PDB file is written. This event occurs even if no PDB file
            will be written.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.EndWritePdb">
            <summary>
            The PDB file has been written. This event occurs even if no PDB file has been written.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.BeginCalculateRvasAndFileOffsets">
            <summary>
            This event occurs just before all RVAs and file offsets of the chunks are calculated.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.EndCalculateRvasAndFileOffsets">
            <summary>
            File offsets and RVAs of all chunks are now known. This includes method body and
            field RVAs. Nothing has been written to the destination stream yet.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.BeginWriteChunks">
            <summary>
            This event occurs before all chunks are written to the destination stream, and after
            all RVAs and file offsets are known.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.EndWriteChunks">
            <summary>
            All chunks have been written to the destination stream.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.BeginStrongNameSign">
            <summary>
            This event occurs before the strong name signature is calculated. This event
            occurs even if the assembly isn't strong name signed.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.EndStrongNameSign">
            <summary>
            This event occurs after the strong name signature has been calculated. This event
            occurs even if the assembly isn't strong name signed.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.BeginWritePEChecksum">
            <summary>
            This event occurs before the checksum in the PE header is updated. This event
            occurs even if the checksum isn't updated.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.EndWritePEChecksum">
            <summary>
            This event occurs after the checksum in the PE header has been updated. This event
            occurs even if the checksum isn't updated.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.ModuleWriterEvent.End">
            <summary>
            Writing has ended
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.ModuleWriterException">
            <summary>
            Thrown when the module writer encounters an unrecoverable error
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterException.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Error message</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Error message</param>
            <param name="innerException">Other exception</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.ModuleWriterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:dnlib.DotNet.Writer.NativeModuleWriterOptions">
            <summary>
            <see cref="T:dnlib.DotNet.Writer.NativeModuleWriter"/> options
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.NativeModuleWriterOptions.KeepExtraPEData">
            <summary>
            If <c>true</c>, any extra data after the PE data in the original file is also saved
            at the end of the new file. Enable this option if some protector has written data to
            the end of the file and uses it at runtime.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.NativeModuleWriterOptions.KeepWin32Resources">
            <summary>
            If <c>true</c>, keep the original Win32 resources
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriterOptions.#ctor(dnlib.DotNet.ModuleDefMD,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="module">Module</param>
            <param name="optimizeImageSize">true to optimize the image size so it's as small as possible.
            Since the file can contain native methods and other native data, we re-use the
            original file when writing the new file. If <paramref name="optimizeImageSize"/> is true,
            we'll try to re-use the old method body locations in the original file and
            also try to fit the new metadata in the old metadata location.</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.NativeModuleWriter">
            <summary>
            A module writer that supports saving mixed-mode modules (modules with native code).
            The original image will be re-used. See also <see cref="T:dnlib.DotNet.Writer.ModuleWriter"/>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.NativeModuleWriter.module">
            <summary>The original .NET module</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.NativeModuleWriter.options">
            <summary>All options</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.NativeModuleWriter.extraData">
            <summary>
            Any extra data found at the end of the original file. This is <c>null</c> if there's
            no extra data or if <see cref="P:dnlib.DotNet.Writer.NativeModuleWriterOptions.KeepExtraPEData"/> is
            <c>false</c>.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.NativeModuleWriter.origSections">
            <summary>The original PE sections and their data</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.NativeModuleWriter.peImage">
            <summary>Original PE image</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.NativeModuleWriter.sections">
            <summary>New sections we've added and their data</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.NativeModuleWriter.textSection">
            <summary>New .text section where we put some stuff, eg. .NET metadata</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.NativeModuleWriter.imageCor20Header">
            <summary>The new COR20 header</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.NativeModuleWriter.rsrcSection">
            <summary>
            New .rsrc section where we put the new Win32 resources. This is <c>null</c> if there
            are no Win32 resources or if <see cref="P:dnlib.DotNet.Writer.NativeModuleWriterOptions.KeepWin32Resources"/>
            is <c>true</c>
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.NativeModuleWriter.checkSumOffset">
            <summary>
            Offset in <see cref="F:dnlib.DotNet.Writer.ModuleWriterBase.destStream"/> of the PE checksum field.
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.NativeModuleWriter.OrigSection">
            <summary>
            Original PE section
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.NativeModuleWriter.OrigSection.PESection">
            <summary>PE section</summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.NativeModuleWriter.OrigSection.Chunk">
            <summary>PE section data</summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriter.OrigSection.#ctor(dnlib.PE.ImageSectionHeader)">
            <summary>
            Constructor
            </summary>
            <param name="peSection">PE section</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriter.OrigSection.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriter.OrigSection.ToString">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.NativeModuleWriter.ModuleDefMD">
            <summary>
            Gets the module
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.NativeModuleWriter.Module">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.NativeModuleWriter.TheOptions">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.NativeModuleWriter.Options">
            <summary>
            Gets/sets the writer options. This is never <c>null</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.NativeModuleWriter.Sections">
            <summary>
            Gets all <see cref="T:dnlib.DotNet.Writer.PESection"/>s
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.NativeModuleWriter.OrigSections">
            <summary>
            Gets the original PE sections and their data
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.NativeModuleWriter.TextSection">
            <summary>
            Gets the <c>.text</c> section
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.NativeModuleWriter.RsrcSection">
            <summary>
            Gets the <c>.rsrc</c> section or <c>null</c> if there's none
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriter.#ctor(dnlib.DotNet.ModuleDefMD,dnlib.DotNet.Writer.NativeModuleWriterOptions)">
            <summary>
            Constructor
            </summary>
            <param name="module">The module</param>
            <param name="options">Options or <c>null</c></param>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriter.WriteImpl">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriter.GetWin32Resources">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriter.CreateRawSections">
            <summary>
            Gets the raw section data of the image. The sections are saved in
            <see cref="F:dnlib.DotNet.Writer.NativeModuleWriter.origSections"/>.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriter.CreateHeaderSection(dnlib.DotNet.Writer.IChunk@)">
            <summary>
            Creates the PE header "section"
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriter.CreateExtraData">
            <summary>
            Saves any data that is appended to the original PE file
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriter.Is64Bit">
            <summary>
            <c>true</c> if image is 64-bit
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriter.UpdateHeaderFields(dnlib.DotNet.Writer.DataWriter,System.Boolean,System.UInt32,dnlib.DotNet.Writer.SectionSizes@)">
            <summary>
            Updates the PE header and COR20 header fields that need updating. All sections are
            also updated, and the new ones are added.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriter.ToWriterOffset(dnlib.PE.RVA)">
            <summary>
            Converts <paramref name="rva"/> to a file offset in the destination stream
            </summary>
            <param name="rva">RVA</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.NativeModuleWriter.GetEntryPoint(System.UInt32@)">
            <summary>
            Gets the entry point
            </summary>
            <param name="ep">Updated with entry point (either a token or RVA of native method)</param>
            <returns><c>true</c> if it's a managed entry point or there's no entry point,
            <c>false</c> if it's a native entry point</returns>
        </member>
        <member name="T:dnlib.DotNet.Writer.NetResources">
            <summary>
            .NET resources
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.NetResources.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.NetResources.RVA">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.NetResources.NextOffset">
            <summary>
            Gets offset of next resource. This offset is relative to the start of
            the .NET resources and is always aligned.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.NetResources.#ctor(System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="alignment">Alignment of all resources</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.NetResources.Add(dnlib.IO.DataReader)">
            <summary>
            Adds a resource
            </summary>
            <param name="reader">The resource data</param>
            <returns>The resource data</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.NetResources.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NetResources.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NetResources.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NetResources.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.NormalMetadata">
            <summary>
            Does not preserve metadata tokens
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.GetAllTypeDefs">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.AllocateTypeDefRids">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.AllocateMemberDefRids">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.GetRid(dnlib.DotNet.TypeRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.GetRid(dnlib.DotNet.TypeDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.GetRid(dnlib.DotNet.FieldDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.GetRid(dnlib.DotNet.MethodDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.GetRid(dnlib.DotNet.ParamDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.GetRid(dnlib.DotNet.MemberRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.GetRid(dnlib.DotNet.StandAloneSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.GetRid(dnlib.DotNet.EventDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.GetRid(dnlib.DotNet.PropertyDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.GetRid(dnlib.DotNet.TypeSpec)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.GetRid(dnlib.DotNet.MethodSpec)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.AddTypeRef(dnlib.DotNet.TypeRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.AddTypeSpec(dnlib.DotNet.TypeSpec)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.AddMemberRef(dnlib.DotNet.MemberRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.AddStandAloneSig(dnlib.DotNet.StandAloneSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.NormalMetadata.AddMethodSpec(dnlib.DotNet.MethodSpec)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.PdbHeap">
            <summary>
            #Pdb heap
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PdbHeap.Name">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.PdbHeap.PdbId">
            <summary>
            Gets the PDB ID. This is always 20 bytes in size.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PdbHeap.EntryPoint">
            <summary>
            Gets/sets the entry point token
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PdbHeap.PdbIdOffset">
            <summary>
            Gets the offset of the 20-byte PDB ID
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PdbHeap.ReferencedTypeSystemTables">
            <summary>
            Gets/sets the referenced type system tables
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PdbHeap.TypeSystemTableRows">
            <summary>
            Gets the type system table rows. This table has 64 elements.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PdbHeap.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PdbHeap.GetRawLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PdbHeap.WriteToImpl(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.PEHeadersOptions">
            <summary>
            <see cref="T:dnlib.DotNet.Writer.PEHeaders"/> options
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.DefaultDllCharacteristics">
            <summary>
            Default DLL characteristics
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.DEFAULT_SUBSYSTEM">
            <summary>
            Default subsystem value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.DEFAULT_MAJOR_LINKER_VERSION">
            <summary>
            Default major linker version. Roslyn C# defaults to 0x30, and Roslyn VB defaults to 0x50.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.DEFAULT_MINOR_LINKER_VERSION">
            <summary>
            Default minor linker version
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.Machine">
            <summary>
            IMAGE_FILE_HEADER.Machine value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.TimeDateStamp">
            <summary>
            IMAGE_FILE_HEADER.TimeDateStamp value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.PointerToSymbolTable">
            <summary>
            IMAGE_FILE_HEADER.PointerToSymbolTable value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.NumberOfSymbols">
            <summary>
            IMAGE_FILE_HEADER.NumberOfSymbols value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.Characteristics">
            <summary>
            IMAGE_FILE_HEADER.Characteristics value. <see cref="F:dnlib.PE.Characteristics.Dll"/> bit
            is ignored and set/cleared depending on whether it's a EXE or a DLL file.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.MajorLinkerVersion">
            <summary>
            IMAGE_OPTIONAL_HEADER.MajorLinkerVersion value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.MinorLinkerVersion">
            <summary>
            IMAGE_OPTIONAL_HEADER.MinorLinkerVersion value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.ImageBase">
            <summary>
            IMAGE_OPTIONAL_HEADER.ImageBase value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.SectionAlignment">
            <summary>
            IMAGE_OPTIONAL_HEADER.SectionAlignment value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.FileAlignment">
            <summary>
            IMAGE_OPTIONAL_HEADER.FileAlignment value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.MajorOperatingSystemVersion">
            <summary>
            IMAGE_OPTIONAL_HEADER.MajorOperatingSystemVersion value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.MinorOperatingSystemVersion">
            <summary>
            IMAGE_OPTIONAL_HEADER.MinorOperatingSystemVersion value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.MajorImageVersion">
            <summary>
            IMAGE_OPTIONAL_HEADER.MajorImageVersion value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.MinorImageVersion">
            <summary>
            IMAGE_OPTIONAL_HEADER.MinorImageVersion value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.MajorSubsystemVersion">
            <summary>
            IMAGE_OPTIONAL_HEADER.MajorSubsystemVersion value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.MinorSubsystemVersion">
            <summary>
            IMAGE_OPTIONAL_HEADER.MinorSubsystemVersion value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.Win32VersionValue">
            <summary>
            IMAGE_OPTIONAL_HEADER.Win32VersionValue value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.Subsystem">
            <summary>
            IMAGE_OPTIONAL_HEADER.Subsystem value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.DllCharacteristics">
            <summary>
            IMAGE_OPTIONAL_HEADER.DllCharacteristics value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.SizeOfStackReserve">
            <summary>
            IMAGE_OPTIONAL_HEADER.SizeOfStackReserve value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.SizeOfStackCommit">
            <summary>
            IMAGE_OPTIONAL_HEADER.SizeOfStackCommit value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.SizeOfHeapReserve">
            <summary>
            IMAGE_OPTIONAL_HEADER.SizeOfHeapReserve value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.SizeOfHeapCommit">
            <summary>
            IMAGE_OPTIONAL_HEADER.SizeOfHeapCommit value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.LoaderFlags">
            <summary>
            IMAGE_OPTIONAL_HEADER.LoaderFlags value
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PEHeadersOptions.NumberOfRvaAndSizes">
            <summary>
            IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes value
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PEHeadersOptions.CreateNewTimeDateStamp">
            <summary>
            Creates a new time date stamp using current time
            </summary>
            <returns>A new time date stamp</returns>
        </member>
        <member name="T:dnlib.DotNet.Writer.PEHeaders">
            <summary>
            DOS and PE headers
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.StartupStub">
            <summary>
            Gets/sets the native entry point
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.ImageCor20Header">
            <summary>
            Gets/sets the COR20 header
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.ImportAddressTable">
            <summary>
            Gets/sets the IAT
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.ImportDirectory">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.Writer.PEHeaders.ImportDirectory"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.Win32Resources">
            <summary>
            Gets/sets the Win32 resources
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.RelocDirectory">
            <summary>
            Gets/sets the relocation directory
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.DebugDirectory">
            <summary>
            Gets/sets the debug directory
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.ImageBase">
            <summary>
            Gets the image base
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.IsExeFile">
            <summary>
            Gets/sets a value indicating whether this is a EXE or a DLL file
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.RVA">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.SectionAlignment">
            <summary>
            Gets the section alignment
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.FileAlignment">
            <summary>
            Gets the file alignment
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PEHeaders.PESections">
            <summary>
            Gets/sets the <see cref="T:dnlib.DotNet.Writer.PESection"/>s
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PEHeaders.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PEHeaders.#ctor(dnlib.DotNet.Writer.PEHeadersOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Options</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.PEHeaders.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PEHeaders.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PEHeaders.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PEHeaders.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PEHeaders.WriteCheckSum(dnlib.DotNet.Writer.DataWriter,System.Int64)">
            <summary>
            Calculates the PE checksum and writes it to the checksum field
            </summary>
            <param name="writer">Writer</param>
            <param name="length">Length of PE file</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.PESection">
            <summary>
            A PE section
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PESection.Name">
            <summary>
            Gets the name
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PESection.Characteristics">
            <summary>
            Gets the Characteristics
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PESection.IsCode">
            <summary>
            <c>true</c> if this is a code section
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PESection.IsInitializedData">
            <summary>
            <c>true</c> if this is an initialized data section
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PESection.IsUninitializedData">
            <summary>
            <c>true</c> if this is an uninitialized data section
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PESection.#ctor(System.String,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="name">Section name</param>
            <param name="characteristics">Section characteristics</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.PESection.WriteHeaderTo(dnlib.DotNet.Writer.DataWriter,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Writes the section header to <paramref name="writer"/> at its current position.
            Returns aligned virtual size (aligned to <paramref name="sectionAlignment"/>)
            </summary>
            <param name="writer">Writer</param>
            <param name="fileAlignment">File alignment</param>
            <param name="sectionAlignment">Section alignment</param>
            <param name="rva">Current <see cref="T:dnlib.PE.RVA"/></param>
        </member>
        <member name="T:dnlib.DotNet.Writer.PreserveTokensMetadata">
            <summary>
            Preserves metadata tokens
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PreserveTokensMetadata.MemberDefInfo`1.Rid">
            <summary>
            Its real rid
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.PreserveTokensMetadata.MemberDefInfo`1.NewRid">
            <summary>
            Its logical rid or real rid. If the ptr table exists (eg. MethodPtr), then it's
            an index into it, else it's the real rid.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PreserveTokensMetadata.MemberDefDict`1.Count">
            <summary>
            Gets total number of defs in the list. It does <c>not</c> necessarily return
            the table size. Use <see cref="P:dnlib.DotNet.Writer.PreserveTokensMetadata.MemberDefDict`1.TableSize"/> for that.
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PreserveTokensMetadata.MemberDefDict`1.TableSize">
            <summary>
            Gets the number of rows that need to be created in the table
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.PreserveTokensMetadata.MemberDefDict`1.NeedPtrTable">
            <summary>
            Returns <c>true</c> if the ptr table (eg. <c>MethodPtr</c>) is needed
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.MemberDefDict`1.Sort(System.Comparison{dnlib.DotNet.Writer.PreserveTokensMetadata.MemberDefInfo{`0}})">
            <summary>
            Sorts the table
            </summary>
            <param name="comparer">Comparer</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.MemberDefDict`1.Add(`0,System.Int32)">
            <summary>
            Adds a def. <see cref="M:dnlib.DotNet.Writer.PreserveTokensMetadata.MemberDefDict`1.SortDefs"/> must be called after adding the last def.
            </summary>
            <param name="def">The def</param>
            <param name="collPos">Collection position</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.MemberDefDict`1.SortDefs">
            <summary>
            Must be called after <see cref="M:dnlib.DotNet.Writer.PreserveTokensMetadata.MemberDefDict`1.Add(`0,System.Int32)"/>'ing the last def
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.GetRid(dnlib.DotNet.TypeRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.GetRid(dnlib.DotNet.TypeDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.GetRid(dnlib.DotNet.FieldDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.GetRid(dnlib.DotNet.MethodDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.GetRid(dnlib.DotNet.ParamDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.GetRid(dnlib.DotNet.MemberRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.GetRid(dnlib.DotNet.StandAloneSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.GetRid(dnlib.DotNet.EventDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.GetRid(dnlib.DotNet.PropertyDef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.GetRid(dnlib.DotNet.TypeSpec)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.GetRid(dnlib.DotNet.MethodSpec)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.Initialize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.GetAllTypeDefs">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.AllocateTypeDefRids">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.CreateEmptyTableRows">
            <summary>
            Reserves rows in <c>TypeRef</c>, <c>MemberRef</c>, <c>StandAloneSig</c>,
            <c>TypeSpec</c> and <c>MethodSpec</c> where we will store the original rows
            to make sure they get the same rid. Any user created rows will be stored at
            the end of each table.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.InitializeUninitializedTableRows">
            <summary>
            Adds any non-referenced rows that haven't been added yet but are present in
            the original file. If there are any non-referenced rows, it's usually a sign
            that an obfuscator has encrypted one or more methods or that it has added
            some rows it uses to decrypt something.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.AllocateMemberDefRids">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.ReUseDeletedFieldRows">
            <summary>
            Re-uses all <c>Field</c> rows which aren't owned by any type due to the fields
            having been deleted by the user. The reason we must do this is that the
            <c>FieldPtr</c> and <c>Field</c> tables must be the same size.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.ReUseDeletedMethodRows">
            <summary>
            Re-uses all <c>Method</c> rows which aren't owned by any type due to the methods
            having been deleted by the user. The reason we must do this is that the
            <c>MethodPtr</c> and <c>Method</c> tables must be the same size.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.ReUseDeletedParamRows">
            <summary>
            Re-uses all <c>Param</c> rows which aren't owned by any type due to the params
            having been deleted by the user. The reason we must do this is that the
            <c>ParamPtr</c> and <c>Param</c> tables must be the same size.
            This method must be called after <see cref="M:dnlib.DotNet.Writer.PreserveTokensMetadata.ReUseDeletedMethodRows"/> since
            this method will create more methods at the end of the <c>Method</c> table.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.ReUseDeletedEventRows">
            <summary>
            Re-uses all <c>Event</c> rows which aren't owned by any type due to the events
            having been deleted by the user. The reason we must do this is that the
            <c>EventPtr</c> and <c>Event</c> tables must be the same size.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.ReUseDeletedPropertyRows">
            <summary>
            Re-uses all <c>Property</c> rows which aren't owned by any type due to the properties
            having been deleted by the user. The reason we must do this is that the
            <c>PropertyPtr</c> and <c>Property</c> tables must be the same size.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.CreateDummyPtrTableType">
            <summary>
            Creates a dummy <c>TypeDef</c> at the end of the <c>TypeDef</c> table that will own
            dummy methods and fields. These dummy methods and fields are only created if the size
            of the ptr table is less than the size of the non-ptr table (eg. size MethodPtr table
            is less than size Method table). The only reason the ptr table would be smaller than
            the non-ptr table is when some field/method has been deleted and we must preserve
            all method/field rids.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.AddTypeRef(dnlib.DotNet.TypeRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.AddTypeSpec(dnlib.DotNet.TypeSpec)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.AddMemberRef(dnlib.DotNet.MemberRef)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.AddStandAloneSig(dnlib.DotNet.StandAloneSig)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.GetToken(System.Collections.Generic.IList{dnlib.DotNet.TypeSig},System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.AddStandAloneSig(dnlib.DotNet.MethodSig,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.AddStandAloneSig(dnlib.DotNet.FieldSig,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.AddMethodSpec(dnlib.DotNet.MethodSpec)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.PreserveTokensMetadata.BeforeSortingCustomAttributes">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.RelocDirectory">
            <summary>
            Relocations directory
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.RelocDirectory.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.RelocDirectory.RVA">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.RelocDirectory.#ctor(dnlib.PE.Machine)">
            <summary>
            Constructor
            </summary>
            <param name="machine">Machine</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.RelocDirectory.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.RelocDirectory.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.RelocDirectory.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.RelocDirectory.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.RelocDirectory.Add(dnlib.PE.RVA)">
            <summary>
            Adds a relocation
            </summary>
            <param name="rva">RVA of location</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.RelocDirectory.Add(dnlib.DotNet.Writer.IChunk,System.UInt32)">
            <summary>
            Adds a relocation
            </summary>
            <param name="chunk">Chunk or null. If it's null, <paramref name="offset"/> is the RVA</param>
            <param name="offset">Offset relative to the start of <paramref name="chunk"/>, or if <paramref name="chunk"/> is null, this is the RVA</param>
        </member>
        <member name="F:dnlib.DotNet.Writer.SectionSizeInfo.length">
            <summary>
            Length of section
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.SectionSizeInfo.characteristics">
            <summary>
            Section characteristics
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.SectionSizeInfo.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="length">Length of section</param>
            <param name="characteristics">Section characteristics</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.SectionSizes">
            <summary>
            Calculates the optional header section sizes
            </summary>
        </member>
        <member name="T:dnlib.DotNet.Writer.ISignatureWriterHelper">
            <summary>
            Helps <see cref="T:dnlib.DotNet.Writer.SignatureWriter"/> map <see cref="T:dnlib.DotNet.ITypeDefOrRef"/>s to tokens
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.ISignatureWriterHelper.ToEncodedToken(dnlib.DotNet.ITypeDefOrRef)">
            <summary>
            Returns a <c>TypeDefOrRef</c> encoded token
            </summary>
            <param name="typeDefOrRef">A <c>TypeDefOrRef</c> type</param>
        </member>
        <member name="T:dnlib.DotNet.Writer.SignatureWriter">
            <summary>
            Writes signatures
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.SignatureWriter.Write(dnlib.DotNet.Writer.ISignatureWriterHelper,dnlib.DotNet.TypeSig)">
            <summary>
            Write a <see cref="T:dnlib.DotNet.TypeSig"/> signature
            </summary>
            <param name="helper">Helper</param>
            <param name="typeSig">The type</param>
            <returns>The signature as a byte array</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.SignatureWriter.Write(dnlib.DotNet.Writer.ISignatureWriterHelper,dnlib.DotNet.CallingConventionSig)">
            <summary>
            Write a <see cref="T:dnlib.DotNet.CallingConventionSig"/> signature
            </summary>
            <param name="helper">Helper</param>
            <param name="sig">The signature</param>
            <returns>The signature as a byte array</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.SignatureWriter.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.StartupStub">
            <summary>
            Stores the instruction that jumps to _CorExeMain/_CorDllMain
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.StartupStub.ImportDirectory">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.Writer.StartupStub.ImportDirectory"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.StartupStub.PEHeaders">
            <summary>
            Gets/sets the <see cref="P:dnlib.DotNet.Writer.StartupStub.PEHeaders"/>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.StartupStub.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.StartupStub.RVA">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.StartupStub.EntryPointRVA">
            <summary>
            Gets the address of the JMP instruction
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.StartupStub.#ctor(dnlib.DotNet.Writer.RelocDirectory,dnlib.PE.Machine,System.Action{System.String,System.Object[]})">
            <summary>
            Constructor
            </summary>
            <param name="relocDirectory">Reloc directory</param>
            <param name="machine">Machine</param>
            <param name="logError">Error logger</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.StartupStub.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.StartupStub.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.StartupStub.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.StartupStub.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.StringsHeap">
            <summary>
            #Strings heap
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.StringsHeap.Name">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.StringsHeap.Populate(dnlib.DotNet.MD.StringsStream)">
            <summary>
            Populates strings from an existing <see cref="T:dnlib.DotNet.MD.StringsStream"/> (eg. to preserve
            string offsets)
            </summary>
            <param name="stringsStream">The #Strings stream with the original content</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.StringsHeap.Add(dnlib.DotNet.UTF8String)">
            <summary>
            Adds a string to the #Strings heap. The returned value is not necessarily an offset in
            the #Strings heap. Call <see cref="M:dnlib.DotNet.Writer.StringsHeap.GetOffset(System.UInt32)"/> to get the offset.
            </summary>
            <param name="s">The string</param>
            <returns>The offset id. This is not a #Strings offset. Call <see cref="M:dnlib.DotNet.Writer.StringsHeap.GetOffset(System.UInt32)"/> to get the #Strings offset</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.StringsHeap.GetOffset(System.UInt32)">
            <summary>
            Gets the offset of a string in the #Strings heap. This method can only be called after
            all strings have been added.
            </summary>
            <param name="offsetId">Offset id returned by <see cref="M:dnlib.DotNet.Writer.StringsHeap.Add(dnlib.DotNet.UTF8String)"/></param>
            <returns></returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.StringsHeap.Create(dnlib.DotNet.UTF8String)">
            <summary>
            Adds a string to the #Strings heap, but does not re-use an existing position
            </summary>
            <param name="s">The string</param>
            <returns>The offset of the string in the #Strings heap</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.StringsHeap.GetRawLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.StringsHeap.WriteToImpl(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.StringsHeap.GetRawDataSize(dnlib.DotNet.UTF8String)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.StringsHeap.SetRawData(System.UInt32,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.StringsHeap.GetAllRawData">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.StrongNameSignature">
            <summary>
            Strong name signature chunk
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.StrongNameSignature.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.StrongNameSignature.RVA">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.StrongNameSignature.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size">Size of strong name signature</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.StrongNameSignature.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.StrongNameSignature.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.StrongNameSignature.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.StrongNameSignature.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.TablesHeapOptions">
            <summary>
            <see cref="T:dnlib.DotNet.Writer.TablesHeap"/> options
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.TablesHeapOptions.Reserved1">
            <summary>
            Should be 0
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.TablesHeapOptions.MajorVersion">
            <summary>
            Major version number. Default is 2. Valid versions are v1.0 (no generics),
            v1.1 (generics are supported), or v2.0 (recommended).
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.TablesHeapOptions.MinorVersion">
            <summary>
            Minor version number. Default is 0.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.TablesHeapOptions.UseENC">
            <summary>
            Force #- or #~ stream. Default value is <c>null</c> and recommended because the correct
            tables stream will be used. <c>true</c> will force <c>#-</c> (Edit N' Continue)
            stream, and <c>false</c> will force <c>#~</c> (normal compressed) stream.
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.TablesHeapOptions.ExtraData">
            <summary>
            Extra data to write
            </summary>
        </member>
        <member name="F:dnlib.DotNet.Writer.TablesHeapOptions.HasDeletedRows">
            <summary>
            <c>true</c> if there are deleted <see cref="T:dnlib.DotNet.TypeDef"/>s, <see cref="T:dnlib.DotNet.ExportedType"/>s,
            <see cref="T:dnlib.DotNet.FieldDef"/>s, <see cref="T:dnlib.DotNet.MethodDef"/>s, <see cref="T:dnlib.DotNet.EventDef"/>s and/or
            <see cref="T:dnlib.DotNet.PropertyDef"/>s.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.TablesHeapOptions.CreatePortablePdbV1_0">
            <summary>
            Creates portable PDB v1.0 options
            </summary>
            <returns></returns>
        </member>
        <member name="T:dnlib.DotNet.Writer.TablesHeap">
            <summary>
            Contains all .NET tables
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.TablesHeap.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.TablesHeap.RVA">
            <inheritdoc/>
        </member>
        <member name="F:dnlib.DotNet.Writer.TablesHeap.Tables">
            <summary>
            All tables
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.TablesHeap.Name">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.TablesHeap.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.TablesHeap.IsENC">
            <summary>
            <c>true</c> if the Edit 'N Continue name will be used (#-)
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.TablesHeap.HasDeletedRows">
            <summary>
            <c>true</c> if any rows have been deleted (eg. a deleted TypeDef, Method, Field, etc.
            Its name has been renamed to _Deleted).
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.TablesHeap.BigStrings">
            <summary>
            <c>true</c> if #Strings heap size > <c>0xFFFF</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.TablesHeap.BigGuid">
            <summary>
            <c>true</c> if #GUID heap size > <c>0xFFFF</c>
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.TablesHeap.BigBlob">
            <summary>
            <c>true</c> if #Blob heap size > <c>0xFFFF</c>
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.TablesHeap.#ctor(dnlib.DotNet.Writer.Metadata,dnlib.DotNet.Writer.TablesHeapOptions)">
            <summary>
            Constructor
            </summary>
            <param name="metadata">Metadata owner</param>
            <param name="options">Options</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.TablesHeap.SetReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.TablesHeap.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.TablesHeap.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.TablesHeap.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.TablesHeap.CalculateLength">
            <summary>
            Calculates the length. This will set all MD tables to read-only.
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.TablesHeap.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.TablesHeap.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.UniqueChunkList`1">
            <summary>
            Re-uses existing chunks to save space
            </summary>
            <typeparam name="T">Chunk type</typeparam>
        </member>
        <member name="M:dnlib.DotNet.Writer.UniqueChunkList`1.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.DotNet.Writer.UniqueChunkList`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor
            </summary>
            <param name="chunkComparer">Compares the chunk type</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.UniqueChunkList`1.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.UniqueChunkList`1.Add(`0,System.UInt32)">
            <summary>
            Adds a <see cref="T:dnlib.DotNet.Writer.IChunk"/> if not already present
            </summary>
            <param name="chunk">The chunk to add or <c>null</c> if none</param>
            <param name="alignment">Chunk alignment</param>
            <returns>The original input if it wasn't present, or the cached one</returns>
        </member>
        <member name="T:dnlib.DotNet.Writer.USHeap">
            <summary>
            #US heap
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.USHeap.Name">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.USHeap.Populate(dnlib.DotNet.MD.USStream)">
            <summary>
            Populates strings from an existing <see cref="T:dnlib.DotNet.MD.USStream"/> (eg. to preserve
            string tokens)
            </summary>
            <param name="usStream">The #US stream with the original content</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.USHeap.Add(System.String)">
            <summary>
            Adds a string to the #US heap
            </summary>
            <param name="s">The string</param>
            <returns>The offset of the string in the #US heap</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.USHeap.Create(System.String)">
            <summary>
            Adds a string to the #US heap
            </summary>
            <param name="s">The string</param>
            <returns>The offset of the string in the #US heap</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.USHeap.GetRawLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.USHeap.WriteToImpl(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.USHeap.GetRawDataSize(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.USHeap.SetRawData(System.UInt32,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.USHeap.GetAllRawData">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.DotNet.Writer.Win32ResourcesChunk">
            <summary>
            Writes Win32 resources
            </summary>
        </member>
        <member name="P:dnlib.DotNet.Writer.Win32ResourcesChunk.FileOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.DotNet.Writer.Win32ResourcesChunk.RVA">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.#ctor(dnlib.W32Resources.Win32Resources)">
            <summary>
            Constructor
            </summary>
            <param name="win32Resources">Win32 resources</param>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetFileOffsetAndRvaOf(dnlib.W32Resources.ResourceDirectoryEntry,dnlib.IO.FileOffset@,dnlib.PE.RVA@)">
            <summary>
            Returns the <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.FileOffset"/> and <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.RVA"/> of a
            <see cref="T:dnlib.W32Resources.ResourceDirectoryEntry"/>. <see cref="M:dnlib.DotNet.Writer.Win32ResourcesChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> must have been called.
            </summary>
            <param name="dirEntry">A <see cref="T:dnlib.W32Resources.ResourceDirectoryEntry"/></param>
            <param name="fileOffset">Updated with the file offset</param>
            <param name="rva">Updated with the RVA</param>
            <returns><c>true</c> if <paramref name="dirEntry"/> is valid and
            <paramref name="fileOffset"/> and <paramref name="rva"/> have been updated. <c>false</c>
            if <paramref name="dirEntry"/> is not part of the Win32 resources.</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetFileOffset(dnlib.W32Resources.ResourceDirectoryEntry)">
            <summary>
            Returns the <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.FileOffset"/> of a <see cref="T:dnlib.W32Resources.ResourceDirectoryEntry"/>.
            <see cref="M:dnlib.DotNet.Writer.Win32ResourcesChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> must have been called.
            </summary>
            <param name="dirEntry">A <see cref="T:dnlib.W32Resources.ResourceDirectoryEntry"/></param>
            <returns>The file offset or 0 if <paramref name="dirEntry"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetRVA(dnlib.W32Resources.ResourceDirectoryEntry)">
            <summary>
            Returns the <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.RVA"/> of a <see cref="T:dnlib.W32Resources.ResourceDirectoryEntry"/>.
            <see cref="M:dnlib.DotNet.Writer.Win32ResourcesChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> must have been called.
            </summary>
            <param name="dirEntry">A <see cref="T:dnlib.W32Resources.ResourceDirectoryEntry"/></param>
            <returns>The RVA or 0 if <paramref name="dirEntry"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetFileOffsetAndRvaOf(dnlib.W32Resources.ResourceDirectory,dnlib.IO.FileOffset@,dnlib.PE.RVA@)">
            <summary>
            Returns the <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.FileOffset"/> and <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.RVA"/> of a
            <see cref="T:dnlib.W32Resources.ResourceDirectory"/>. <see cref="M:dnlib.DotNet.Writer.Win32ResourcesChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> must have been called.
            </summary>
            <param name="dir">A <see cref="T:dnlib.W32Resources.ResourceDirectory"/></param>
            <param name="fileOffset">Updated with the file offset</param>
            <param name="rva">Updated with the RVA</param>
            <returns><c>true</c> if <paramref name="dir"/> is valid and
            <paramref name="fileOffset"/> and <paramref name="rva"/> have been updated. <c>false</c>
            if <paramref name="dir"/> is not part of the Win32 resources.</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetFileOffset(dnlib.W32Resources.ResourceDirectory)">
            <summary>
            Returns the <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.FileOffset"/> of a <see cref="T:dnlib.W32Resources.ResourceDirectory"/>.
            <see cref="M:dnlib.DotNet.Writer.Win32ResourcesChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> must have been called.
            </summary>
            <param name="dir">A <see cref="T:dnlib.W32Resources.ResourceDirectory"/></param>
            <returns>The file offset or 0 if <paramref name="dir"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetRVA(dnlib.W32Resources.ResourceDirectory)">
            <summary>
            Returns the <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.RVA"/> of a <see cref="T:dnlib.W32Resources.ResourceDirectory"/>.
            <see cref="M:dnlib.DotNet.Writer.Win32ResourcesChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> must have been called.
            </summary>
            <param name="dir">A <see cref="T:dnlib.W32Resources.ResourceDirectory"/></param>
            <returns>The RVA or 0 if <paramref name="dir"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetFileOffsetAndRvaOf(dnlib.W32Resources.ResourceData,dnlib.IO.FileOffset@,dnlib.PE.RVA@)">
            <summary>
            Returns the <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.FileOffset"/> and <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.RVA"/> of a
            <see cref="T:dnlib.W32Resources.ResourceData"/>. <see cref="M:dnlib.DotNet.Writer.Win32ResourcesChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> must have been called.
            </summary>
            <param name="dataHeader">A <see cref="T:dnlib.W32Resources.ResourceData"/></param>
            <param name="fileOffset">Updated with the file offset</param>
            <param name="rva">Updated with the RVA</param>
            <returns><c>true</c> if <paramref name="dataHeader"/> is valid and
            <paramref name="fileOffset"/> and <paramref name="rva"/> have been updated. <c>false</c>
            if <paramref name="dataHeader"/> is not part of the Win32 resources.</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetFileOffset(dnlib.W32Resources.ResourceData)">
            <summary>
            Returns the <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.FileOffset"/> of a <see cref="T:dnlib.W32Resources.ResourceData"/>.
            <see cref="M:dnlib.DotNet.Writer.Win32ResourcesChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> must have been called.
            </summary>
            <param name="dataHeader">A <see cref="T:dnlib.W32Resources.ResourceData"/></param>
            <returns>The file offset or 0 if <paramref name="dataHeader"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetRVA(dnlib.W32Resources.ResourceData)">
            <summary>
            Returns the <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.RVA"/> of a <see cref="T:dnlib.W32Resources.ResourceData"/>.
            <see cref="M:dnlib.DotNet.Writer.Win32ResourcesChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> must have been called.
            </summary>
            <param name="dataHeader">A <see cref="T:dnlib.W32Resources.ResourceData"/></param>
            <returns>The RVA or 0 if <paramref name="dataHeader"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetFileOffsetAndRvaOf(System.String,dnlib.IO.FileOffset@,dnlib.PE.RVA@)">
            <summary>
            Returns the <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.FileOffset"/> and <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.RVA"/> of a
            <see cref="T:dnlib.W32Resources.ResourceDirectoryEntry"/>'s name. <see cref="M:dnlib.DotNet.Writer.Win32ResourcesChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> must have been
            called.
            </summary>
            <param name="name">The name of a <see cref="T:dnlib.W32Resources.ResourceDirectoryEntry"/></param>
            <param name="fileOffset">Updated with the file offset</param>
            <param name="rva">Updated with the RVA</param>
            <returns><c>true</c> if <paramref name="name"/> is valid and
            <paramref name="fileOffset"/> and <paramref name="rva"/> have been updated. <c>false</c>
            if <paramref name="name"/> is not part of the Win32 resources.</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetFileOffset(System.String)">
            <summary>
            Returns the <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.FileOffset"/> of a <see cref="T:dnlib.W32Resources.ResourceDirectoryEntry"/>'s name.
            <see cref="M:dnlib.DotNet.Writer.Win32ResourcesChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> must have been called.
            </summary>
            <param name="name">The name of a <see cref="T:dnlib.W32Resources.ResourceDirectoryEntry"/></param>
            <returns>The file offset or 0 if <paramref name="name"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetRVA(System.String)">
            <summary>
            Returns the <see cref="P:dnlib.DotNet.Writer.Win32ResourcesChunk.RVA"/> of a <see cref="T:dnlib.W32Resources.ResourceDirectoryEntry"/>'s name.
            <see cref="M:dnlib.DotNet.Writer.Win32ResourcesChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)"/> must have been called.
            </summary>
            <param name="name">The name of a <see cref="T:dnlib.W32Resources.ResourceDirectoryEntry"/></param>
            <returns>The RVA or 0 if <paramref name="name"/> is invalid</returns>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.SetOffset(dnlib.IO.FileOffset,dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetFileLength">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.GetVirtualSize">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.DotNet.Writer.Win32ResourcesChunk.WriteTo(dnlib.DotNet.Writer.DataWriter)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.IO.ByteArrayDataReaderFactory">
            <summary>
            A <see cref="T:dnlib.IO.DataReaderFactory"/> that reads from a byte array
            </summary>
        </member>
        <member name="P:dnlib.IO.ByteArrayDataReaderFactory.Filename">
            <summary>
            The filename or null if the data is not from a file
            </summary>
        </member>
        <member name="P:dnlib.IO.ByteArrayDataReaderFactory.Length">
            <summary>
            Gets the total length of the data
            </summary>
        </member>
        <member name="M:dnlib.IO.ByteArrayDataReaderFactory.Create(System.Byte[],System.String)">
            <summary>
            Creates a <see cref="T:dnlib.IO.ByteArrayDataReaderFactory"/> instance
            </summary>
            <param name="data">Data</param>
            <param name="filename">The filename or null if the data is not from a file</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.ByteArrayDataReaderFactory.CreateReader(System.Byte[])">
            <summary>
            Creates a data reader
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.ByteArrayDataReaderFactory.CreateReader(System.UInt32,System.UInt32)">
            <summary>
            Creates a data reader
            </summary>
            <param name="offset">Offset of data</param>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.ByteArrayDataReaderFactory.Dispose">
            <summary>
            This method doesn't need to be called since a <see cref="T:dnlib.IO.ByteArrayDataReaderFactory"/> has nothing that must be cleaned up
            </summary>
        </member>
        <member name="T:dnlib.IO.DataReaderException">
            <summary>
            Thrown by a <see cref="T:dnlib.IO.DataReader"/> when it can't read data or if the caller tries to set an invalid offset
            </summary>
        </member>
        <member name="T:dnlib.IO.DataReader">
            <summary>
            Reads data
            </summary>
        </member>
        <member name="P:dnlib.IO.DataReader.StartOffset">
            <summary>
            Gets the start offset of the data
            </summary>
        </member>
        <member name="P:dnlib.IO.DataReader.EndOffset">
            <summary>
            Gets the end offset of the data, not inclusive
            </summary>
        </member>
        <member name="P:dnlib.IO.DataReader.Length">
            <summary>
            Gets the total length of the data
            </summary>
        </member>
        <member name="P:dnlib.IO.DataReader.CurrentOffset">
            <summary>
            Gets the current offset. This is between <see cref="P:dnlib.IO.DataReader.StartOffset"/> and <see cref="P:dnlib.IO.DataReader.EndOffset"/> (inclusive)
            </summary>
        </member>
        <member name="P:dnlib.IO.DataReader.Position">
            <summary>
            Gets/sets the position relative to <see cref="P:dnlib.IO.DataReader.StartOffset"/>
            </summary>
        </member>
        <member name="P:dnlib.IO.DataReader.BytesLeft">
            <summary>
            Gets the number of bytes that can be read without throwing an exception
            </summary>
        </member>
        <member name="M:dnlib.IO.DataReader.#ctor(dnlib.IO.DataStream,System.UInt32,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="stream">Stream</param>
            <param name="offset">Start offset of data</param>
            <param name="length">Length of data</param>
        </member>
        <member name="M:dnlib.IO.DataReader.Reset">
            <summary>
            Resets the reader so it points to the start of the data
            </summary>
        </member>
        <member name="M:dnlib.IO.DataReader.Slice(System.UInt32,System.UInt32)">
            <summary>
            Creates a new reader that can access a smaller part of this reader
            </summary>
            <param name="start">Start position relative to <see cref="P:dnlib.IO.DataReader.StartOffset"/></param>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.Slice(System.UInt32)">
            <summary>
            Creates a new reader that can access everything from <paramref name="start"/> to the end of the data
            </summary>
            <param name="start">Start position relative to <see cref="P:dnlib.IO.DataReader.StartOffset"/></param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.Slice(System.Int32,System.Int32)">
            <summary>
            Creates a new reader that can access a smaller part of this reader
            </summary>
            <param name="start">Start position relative to <see cref="P:dnlib.IO.DataReader.StartOffset"/></param>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.Slice(System.Int32)">
            <summary>
            Creates a new reader that can access everything from <paramref name="start"/> to the end of the data
            </summary>
            <param name="start">Start position relative to <see cref="P:dnlib.IO.DataReader.StartOffset"/></param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.CanRead(System.Int32)">
            <summary>
            Checks if it's possible to read <paramref name="length"/> bytes
            </summary>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.CanRead(System.UInt32)">
            <summary>
            Checks if it's possible to read <paramref name="length"/> bytes
            </summary>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadBoolean">
            <summary>
            Reads a <see cref="T:System.Boolean"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadChar">
            <summary>
            Reads a <see cref="T:System.Char"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadSByte">
            <summary>
            Reads a <see cref="T:System.SByte"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadByte">
            <summary>
            Reads a <see cref="T:System.Byte"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadInt16">
            <summary>
            Reads a <see cref="T:System.Int16"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadUInt16">
            <summary>
            Reads a <see cref="T:System.UInt16"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadInt32">
            <summary>
            Reads a <see cref="T:System.Int32"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadUInt32">
            <summary>
            Reads a <see cref="T:System.UInt32"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadInt64">
            <summary>
            Reads a <see cref="T:System.Int64"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadUInt64">
            <summary>
            Reads a <see cref="T:System.UInt64"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadSingle">
            <summary>
            Reads a <see cref="T:System.Single"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadDouble">
            <summary>
            Reads a <see cref="T:System.Double"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadGuid">
            <summary>
            Reads a <see cref="T:System.Guid"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadDecimal">
            <summary>
            Reads a <see cref="T:System.Decimal"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadUtf16String(System.Int32)">
            <summary>
            Reads a UTF-16 encoded <see cref="T:System.String"/>
            </summary>
            <param name="chars">Number of characters to read</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadBytes(System.Void*,System.Int32)">
            <summary>
            Reads bytes
            </summary>
            <param name="destination">Destination pointer</param>
            <param name="length">Number of bytes to read</param>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes
            </summary>
            <param name="destination">Destination array</param>
            <param name="destinationIndex">Destination index</param>
            <param name="length">Number of bytes to read</param>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadBytes(System.Int32)">
            <summary>
            Reads bytes
            </summary>
            <param name="length">Number of bytes to read</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.TryReadCompressedUInt32(System.UInt32@)">
            <summary>
            Reads a compressed <see cref="T:System.UInt32"/>
            </summary>
            <param name="value">Uncompressed <see cref="T:System.UInt32"/></param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadCompressedUInt32">
            <summary>
            Reads a compressed <see cref="T:System.UInt32"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.TryReadCompressedInt32(System.Int32@)">
            <summary>
            Reads a compressed <see cref="T:System.Int32"/>
            </summary>
            <param name="value">Uncompressed <see cref="T:System.Int32"/></param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadCompressedInt32">
            <summary>
            Reads a compressed <see cref="T:System.Int32"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.Read7BitEncodedUInt32">
            <summary>
            Reads a 7-bit encoded integer
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.Read7BitEncodedInt32">
            <summary>
            Reads a 7-bit encoded integer
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadSerializedString">
            <summary>
            Reads a serialized UTF-8 string
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadSerializedString(System.Text.Encoding)">
            <summary>
            Reads a serialized string
            </summary>
            <param name="encoding">Encoding</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ToArray">
            <summary>
            Returns all data without updating the current position
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadRemainingBytes">
            <summary>
            Returns the remaining data
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.TryReadBytesUntil(System.Byte)">
            <summary>
            Reads all bytes until a terminating byte or returns null if <paramref name="value"/> wasn't found.
            If found, the current offset is incremented by the length of the returned data
            </summary>
            <param name="value">Terminating byte value</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.TryReadZeroTerminatedUtf8String">
            <summary>
            Reads a zero-terminated UTF-8 string or returns null if the string couldn't be read.
            If successful, the current offset is incremented past the terminating zero.
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.TryReadZeroTerminatedString(System.Text.Encoding)">
            <summary>
            Reads a zero-terminated string or returns null if the string couldn't be read.
            If successful, the current offset is incremented past the terminating zero.
            </summary>
            <param name="encoding">Encoding</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadUtf8String(System.Int32)">
            <summary>
            Reads a UTF-8 encoded string
            </summary>
            <param name="byteCount">Number of bytes to read (not characters)</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.ReadString(System.Int32,System.Text.Encoding)">
            <summary>
            Reads a string
            </summary>
            <param name="byteCount">Number of bytes to read (not characters)</param>
            <param name="encoding">Encoding</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.AsStream">
            <summary>
            Creates a <see cref="T:System.IO.Stream"/> that can access this content. The caller doesn't have to dispose of the returned stream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReader.CopyTo(dnlib.DotNet.Writer.DataWriter)">
            <summary>
            Copies the data, starting from <see cref="P:dnlib.IO.DataReader.Position"/>, to <paramref name="destination"/>
            </summary>
            <param name="destination">Destination</param>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:dnlib.IO.DataReader.CopyTo(dnlib.DotNet.Writer.DataWriter,System.Byte[])">
            <summary>
            Copies the data, starting from <see cref="P:dnlib.IO.DataReader.Position"/>, to <paramref name="destination"/>
            </summary>
            <param name="destination">Destination</param>
            <param name="dataBuffer">Temp buffer during writing</param>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:dnlib.IO.DataReader.CopyTo(System.IO.BinaryWriter)">
            <summary>
            Copies the data, starting from <see cref="P:dnlib.IO.DataReader.Position"/>, to <paramref name="destination"/>
            </summary>
            <param name="destination">Destination</param>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:dnlib.IO.DataReader.CopyTo(System.IO.BinaryWriter,System.Byte[])">
            <summary>
            Copies the data, starting from <see cref="P:dnlib.IO.DataReader.Position"/>, to <paramref name="destination"/>
            </summary>
            <param name="destination">Destination</param>
            <param name="dataBuffer">Temp buffer during writing</param>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:dnlib.IO.DataReader.CopyTo(System.IO.Stream)">
            <summary>
            Copies the data, starting from <see cref="P:dnlib.IO.DataReader.Position"/>, to <paramref name="destination"/>
            </summary>
            <param name="destination">Destination</param>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:dnlib.IO.DataReader.CopyTo(System.IO.Stream,System.Byte[])">
            <summary>
            Copies the data, starting from <see cref="P:dnlib.IO.DataReader.Position"/>, to <paramref name="destination"/>
            </summary>
            <param name="destination">Destination</param>
            <param name="dataBuffer">Temp buffer during writing</param>
            <returns>Number of bytes written</returns>
        </member>
        <member name="T:dnlib.IO.DataReaderFactory">
            <summary>
            Creates <see cref="T:dnlib.IO.DataReader"/>s that can read its data.
            
            This factory class is thread safe and its data can be read by <see cref="T:dnlib.IO.DataReader"/> on any thread.
            </summary>
        </member>
        <member name="P:dnlib.IO.DataReaderFactory.Filename">
            <summary>
            The filename or null if the data is not from a file
            </summary>
        </member>
        <member name="P:dnlib.IO.DataReaderFactory.Length">
            <summary>
            Gets the total length of the data
            </summary>
        </member>
        <member name="M:dnlib.IO.DataReaderFactory.CreateReader">
            <summary>
            Creates a data reader that can read all data
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReaderFactory.CreateReader(System.UInt32,System.UInt32)">
            <summary>
            Creates a data reader
            </summary>
            <param name="offset">Offset of data</param>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReaderFactory.CreateReader(System.UInt32,System.Int32)">
            <summary>
            Creates a data reader
            </summary>
            <param name="offset">Offset of data</param>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReaderFactory.CreateReader(System.Int32,System.UInt32)">
            <summary>
            Creates a data reader
            </summary>
            <param name="offset">Offset of data</param>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReaderFactory.CreateReader(System.Int32,System.Int32)">
            <summary>
            Creates a data reader
            </summary>
            <param name="offset">Offset of data</param>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataReaderFactory.CreateReader(dnlib.IO.DataStream,System.UInt32,System.UInt32)">
            <summary>
            Creates a data reader
            </summary>
            <param name="stream">Stream</param>
            <param name="offset">Offset of data</param>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="E:dnlib.IO.DataReaderFactory.DataReaderInvalidated">
            <summary>
            Raised when all cached <see cref="T:dnlib.IO.DataReader"/>s created by this instance must be recreated
            </summary>
        </member>
        <member name="M:dnlib.IO.DataReaderFactory.Dispose">
            <summary>
            Disposes of this instance
            </summary>
        </member>
        <member name="T:dnlib.IO.DataStream">
            <summary>
            This class is used by a <see cref="T:dnlib.IO.DataReader"/>. The <see cref="T:dnlib.IO.DataReader"/> instance
            verifies that all input are valid before calling any methods in this class.
            This class is thread safe.
            </summary>
        </member>
        <member name="M:dnlib.IO.DataStream.ReadBytes(System.UInt32,System.Void*,System.Int32)">
            <summary>
            Reads bytes
            </summary>
            <param name="offset">Offset of data</param>
            <param name="destination">Destination pointer</param>
            <param name="length">Number of bytes to read</param>
        </member>
        <member name="M:dnlib.IO.DataStream.ReadBytes(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes
            </summary>
            <param name="offset">Offset of data</param>
            <param name="destination">Destination array</param>
            <param name="destinationIndex">Destination index</param>
            <param name="length">Number of bytes to read</param>
        </member>
        <member name="M:dnlib.IO.DataStream.ReadByte(System.UInt32)">
            <summary>
            Reads a <see cref="T:System.Byte"/>
            </summary>
            <param name="offset">Offset of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataStream.ReadUInt16(System.UInt32)">
            <summary>
            Reads a <see cref="T:System.UInt16"/>
            </summary>
            <param name="offset">Offset of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataStream.ReadUInt32(System.UInt32)">
            <summary>
            Reads a <see cref="T:System.UInt32"/>
            </summary>
            <param name="offset">Offset of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataStream.ReadUInt64(System.UInt32)">
            <summary>
            Reads a <see cref="T:System.UInt64"/>
            </summary>
            <param name="offset">Offset of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataStream.ReadSingle(System.UInt32)">
            <summary>
            Reads a <see cref="T:System.Single"/>
            </summary>
            <param name="offset">Offset of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataStream.ReadDouble(System.UInt32)">
            <summary>
            Reads a <see cref="T:System.Double"/>
            </summary>
            <param name="offset">Offset of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataStream.ReadGuid(System.UInt32)">
            <summary>
            Reads a <see cref="T:System.Guid"/>
            </summary>
            <param name="offset">Offset of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataStream.ReadUtf16String(System.UInt32,System.Int32)">
            <summary>
            Reads a UTF-16 encoded <see cref="T:System.String"/>
            </summary>
            <param name="offset">Offset of data</param>
            <param name="chars">Number of characters to read</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataStream.ReadString(System.UInt32,System.Int32,System.Text.Encoding)">
            <summary>
            Reads a string
            </summary>
            <param name="offset">Offset of data</param>
            <param name="length">Length of string in bytes</param>
            <param name="encoding">Encoding</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataStream.TryGetOffsetOf(System.UInt32,System.UInt32,System.Byte,System.UInt32@)">
            <summary>
            Gets the data offset of a byte or returns false if the byte wasn't found
            </summary>
            <param name="offset">Offset of data</param>
            <param name="endOffset">End offset of data (not inclusive)</param>
            <param name="value">Byte value to search for</param>
            <param name="valueOffset">Offset of the byte if found</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.IO.DataStreamFactory">
            <summary>
            Creates <see cref="T:dnlib.IO.DataStream"/>s
            </summary>
        </member>
        <member name="M:dnlib.IO.DataStreamFactory.Create(System.Byte*)">
            <summary>
            Creates a <see cref="T:dnlib.IO.DataStream"/> that reads from native memory
            </summary>
            <param name="data">Pointer to data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.DataStreamFactory.Create(System.Byte[])">
            <summary>
            Creates a <see cref="T:dnlib.IO.DataStream"/> that reads from a byte array
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.IO.FileOffset">
            <summary>
            Represents a file offset
            </summary>
        </member>
        <member name="T:dnlib.IO.IOExtensions">
            <summary>
            Extension methods
            </summary>
        </member>
        <member name="M:dnlib.IO.IOExtensions.AlignUp(dnlib.IO.FileOffset,System.UInt32)">
            <summary>
            Align up
            </summary>
            <param name="offset">this</param>
            <param name="alignment">Alignment</param>
        </member>
        <member name="M:dnlib.IO.IOExtensions.AlignUp(dnlib.IO.FileOffset,System.Int32)">
            <summary>
            Align up
            </summary>
            <param name="offset">this</param>
            <param name="alignment">Alignment</param>
        </member>
        <member name="T:dnlib.IO.FileSection">
            <summary>
            Base class for classes needing to implement IFileSection
            </summary>
        </member>
        <member name="F:dnlib.IO.FileSection.startOffset">
            <summary>
            The start file offset of this section
            </summary>
        </member>
        <member name="F:dnlib.IO.FileSection.size">
            <summary>
            Size of the section
            </summary>
        </member>
        <member name="P:dnlib.IO.FileSection.StartOffset">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.IO.FileSection.EndOffset">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.IO.FileSection.SetStartOffset(dnlib.IO.DataReader@)">
            <summary>
            Set <see cref="F:dnlib.IO.FileSection.startOffset"/> to <paramref name="reader"/>'s current position
            </summary>
            <param name="reader">The reader</param>
        </member>
        <member name="M:dnlib.IO.FileSection.SetEndoffset(dnlib.IO.DataReader@)">
            <summary>
            Set <see cref="F:dnlib.IO.FileSection.size"/> according to <paramref name="reader"/>'s current position
            </summary>
            <param name="reader">The reader</param>
        </member>
        <member name="T:dnlib.IO.IFileSection">
            <summary>
            Represents a section in a file
            </summary>
        </member>
        <member name="P:dnlib.IO.IFileSection.StartOffset">
            <summary>
            Start offset of the section in the file
            </summary>
        </member>
        <member name="P:dnlib.IO.IFileSection.EndOffset">
            <summary>
            End offset of the section in the file. This is one byte after the last
            valid offset in the section.
            </summary>
        </member>
        <member name="T:dnlib.IO.MemoryMappedDataReaderFactory">
            <summary>
            Creates <see cref="T:dnlib.IO.DataReader"/>s that read memory mapped data
            </summary>
        </member>
        <member name="P:dnlib.IO.MemoryMappedDataReaderFactory.Filename">
            <summary>
            The filename or null if the data is not from a file
            </summary>
        </member>
        <member name="P:dnlib.IO.MemoryMappedDataReaderFactory.Length">
            <summary>
            Gets the total length of the data
            </summary>
        </member>
        <member name="E:dnlib.IO.MemoryMappedDataReaderFactory.DataReaderInvalidated">
            <summary>
            Raised when all cached <see cref="T:dnlib.IO.DataReader"/>s created by this instance must be recreated
            </summary>
        </member>
        <member name="M:dnlib.IO.MemoryMappedDataReaderFactory.CreateReader(System.UInt32,System.UInt32)">
            <summary>
            Creates a data reader
            </summary>
            <param name="offset">Offset of data</param>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.MemoryMappedDataReaderFactory.Dispose">
            <summary>
            Cleans up and frees all allocated memory
            </summary>
        </member>
        <member name="P:dnlib.IO.MemoryMappedDataReaderFactory.IsMemoryMappedIO">
            <summary>
            <c>true</c> if memory mapped I/O is enabled
            </summary>
        </member>
        <member name="M:dnlib.IO.MemoryMappedDataReaderFactory.UnsafeDisableMemoryMappedIO">
            <summary>
            Call this to disable memory mapped I/O. This must only be called if no other code is
            trying to access the memory since that could lead to an exception.
            </summary>
        </member>
        <member name="T:dnlib.IO.NativeMemoryDataReaderFactory">
            <summary>
            Creates <see cref="T:dnlib.IO.DataReader"/>s that read native memory
            </summary>
        </member>
        <member name="P:dnlib.IO.NativeMemoryDataReaderFactory.Filename">
            <summary>
            The filename or null if the data is not from a file
            </summary>
        </member>
        <member name="P:dnlib.IO.NativeMemoryDataReaderFactory.Length">
            <summary>
            Gets the total length of the data
            </summary>
        </member>
        <member name="M:dnlib.IO.NativeMemoryDataReaderFactory.Create(System.Byte*,System.UInt32,System.String)">
            <summary>
            Creates a <see cref="T:dnlib.IO.NativeMemoryDataReaderFactory"/> instance
            </summary>
            <param name="data">Pointer to data</param>
            <param name="length">Length of data</param>
            <param name="filename">The filename or null if the data is not from a file</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.NativeMemoryDataReaderFactory.CreateReader(System.UInt32,System.UInt32)">
            <summary>
            Creates a data reader
            </summary>
            <param name="offset">Offset of data</param>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.IO.NativeMemoryDataReaderFactory.Dispose">
            <summary>
            This method doesn't need to be called since this instance doesn't own the native memory
            </summary>
        </member>
        <member name="T:dnlib.PE.Characteristics">
            <summary>
            IMAGE_FILE_HEADER.Characteristics flags
            </summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.RelocsStripped">
            <summary>Relocation info stripped from file.</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.ExecutableImage">
            <summary>File is executable  (i.e. no unresolved externel references).</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.LineNumsStripped">
            <summary>Line nunbers stripped from file.</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.LocalSymsStripped">
            <summary>Local symbols stripped from file.</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.AggressiveWsTrim">
            <summary>Agressively trim working set</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.LargeAddressAware">
            <summary>App can handle >2gb addresses</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.Reserved1">
            <summary/>
        </member>
        <member name="F:dnlib.PE.Characteristics.BytesReversedLo">
            <summary>Bytes of machine word are reversed.</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.Bit32Machine">
            <summary>32 bit word machine.</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.DebugStripped">
            <summary>Debugging info stripped from file in .DBG file</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.RemovableRunFromSwap">
            <summary>If Image is on removable media, copy and run from the swap file.</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.NetRunFromSwap">
            <summary>If Image is on Net, copy and run from the swap file.</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.System">
            <summary>System File.</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.Dll">
            <summary>File is a DLL.</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.UpSystemOnly">
            <summary>File should only be run on a UP machine</summary>
        </member>
        <member name="F:dnlib.PE.Characteristics.BytesReversedHi">
            <summary>Bytes of machine word are reversed.</summary>
        </member>
        <member name="T:dnlib.PE.DllCharacteristics">
            <summary>
            IMAGE_OPTIONAL_HEADER.DllCharacteristics
            </summary>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.Reserved1">
            <summary/>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.Reserved2">
            <summary/>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.Reserved3">
            <summary/>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.Reserved4">
            <summary/>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.Reserved5">
            <summary/>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.HighEntropyVA">
            <summary>Image can handle a high entropy 64-bit virtual address space.</summary>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.DynamicBase">
            <summary>DLL can move.</summary>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.ForceIntegrity">
            <summary>Code Integrity Image</summary>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.NxCompat">
            <summary>Image is NX compatible</summary>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.NoIsolation">
            <summary>Image understands isolation and doesn't want it</summary>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.NoSeh">
            <summary>Image does not use SEH.  No SE handler may reside in this image</summary>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.NoBind">
            <summary>Do not bind this image.</summary>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.AppContainer">
            <summary>Image should execute in an AppContainer</summary>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.WdmDriver">
            <summary>Driver uses WDM model</summary>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.GuardCf">
            <summary>Image supports Control Flow Guard.</summary>
        </member>
        <member name="F:dnlib.PE.DllCharacteristics.TerminalServerAware">
            <summary/>
        </member>
        <member name="T:dnlib.PE.IImageOptionalHeader">
            <summary>
            Interface for PE optional header classes
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.Magic">
            <summary>
            Returns the Magic field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.MajorLinkerVersion">
            <summary>
            Returns the MajorLinkerVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.MinorLinkerVersion">
            <summary>
            Returns the MinorLinkerVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.SizeOfCode">
            <summary>
            Returns the SizeOfCode field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.SizeOfInitializedData">
            <summary>
            Returns the SizeOfInitializedData field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.SizeOfUninitializedData">
            <summary>
            Returns the SizeOfUninitializedData field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.AddressOfEntryPoint">
            <summary>
            Returns the AddressOfEntryPoint field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.BaseOfCode">
            <summary>
            Returns the BaseOfCode field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.BaseOfData">
            <summary>
            Returns the BaseOfData field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.ImageBase">
            <summary>
            Returns the ImageBase field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.SectionAlignment">
            <summary>
            Returns the SectionAlignment field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.FileAlignment">
            <summary>
            Returns the FileAlignment field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.MajorOperatingSystemVersion">
            <summary>
            Returns the MajorOperatingSystemVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.MinorOperatingSystemVersion">
            <summary>
            Returns the MinorOperatingSystemVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.MajorImageVersion">
            <summary>
            Returns the MajorImageVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.MinorImageVersion">
            <summary>
            Returns the MinorImageVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.MajorSubsystemVersion">
            <summary>
            Returns the MajorSubsystemVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.MinorSubsystemVersion">
            <summary>
            Returns the MinorSubsystemVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.Win32VersionValue">
            <summary>
            Returns the Win32VersionValue field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.SizeOfImage">
            <summary>
            Returns the SizeOfImage field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.SizeOfHeaders">
            <summary>
            Returns the SizeOfHeaders field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.CheckSum">
            <summary>
            Returns the CheckSum field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.Subsystem">
            <summary>
            Returns the Subsystem field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.DllCharacteristics">
            <summary>
            Returns the DllCharacteristics field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.SizeOfStackReserve">
            <summary>
            Returns the SizeOfStackReserve field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.SizeOfStackCommit">
            <summary>
            Returns the SizeOfStackCommit field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.SizeOfHeapReserve">
            <summary>
            Returns the SizeOfHeapReserve field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.SizeOfHeapCommit">
            <summary>
            Returns the SizeOfHeapCommit field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.LoaderFlags">
            <summary>
            Returns the LoaderFlags field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.NumberOfRvaAndSizes">
            <summary>
            Returns the NumberOfRvaAndSizes field
            </summary>
        </member>
        <member name="P:dnlib.PE.IImageOptionalHeader.DataDirectories">
            <summary>
            Returns the DataDirectories field. This array contains exactly 16 elements.
            </summary>
        </member>
        <member name="T:dnlib.PE.ImageDataDirectory">
            <summary>
            Represents the IMAGE_DATA_DIRECTORY PE section
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageDataDirectory.VirtualAddress">
            <summary>
            Returns the IMAGE_DATA_DIRECTORY.VirtualAddress field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageDataDirectory.Size">
            <summary>
            Returns the IMAGE_DATA_DIRECTORY.Size field
            </summary>
        </member>
        <member name="M:dnlib.PE.ImageDataDirectory.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.PE.ImageDataDirectory.#ctor(dnlib.IO.DataReader@,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="reader">PE file reader pointing to the start of this section</param>
            <param name="verify">Verify section</param>
            <exception cref="T:System.BadImageFormatException">Thrown if verification fails</exception>
        </member>
        <member name="T:dnlib.PE.ImageDebugDirectory">
            <summary>
            A <c>IMAGE_DEBUG_DIRECTORY</c>
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageDebugDirectory.Characteristics">
            <summary>
            Gets the characteristics (reserved)
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageDebugDirectory.TimeDateStamp">
            <summary>
            Gets the timestamp
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageDebugDirectory.MajorVersion">
            <summary>
            Gets the major version
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageDebugDirectory.MinorVersion">
            <summary>
            Gets the minor version
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageDebugDirectory.Type">
            <summary>
            Gets the type
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageDebugDirectory.SizeOfData">
            <summary>
            Gets the size of data
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageDebugDirectory.AddressOfRawData">
            <summary>
            RVA of the data
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageDebugDirectory.PointerToRawData">
            <summary>
            File offset of the data
            </summary>
        </member>
        <member name="M:dnlib.PE.ImageDebugDirectory.#ctor(dnlib.IO.DataReader@,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="reader">PE file reader pointing to the start of this section</param>
            <param name="verify">Verify section</param>
            <exception cref="T:System.BadImageFormatException">Thrown if verification fails</exception>
        </member>
        <member name="T:dnlib.PE.ImageDebugType">
            <summary>
            Image debug type, see <c>IMAGE_DEBUG_TYPE_*</c> in winnt.n
            </summary>
        </member>
        <member name="F:dnlib.PE.ImageDebugType.CodeView">
            <summary>
            Contains PDB info
            </summary>
        </member>
        <member name="F:dnlib.PE.ImageDebugType.Reproducible">
            <summary>
            It's a deterministic (reproducible) PE file
            </summary>
        </member>
        <member name="F:dnlib.PE.ImageDebugType.EmbeddedPortablePdb">
            <summary>
            Embedded portable PDB data
            </summary>
        </member>
        <member name="F:dnlib.PE.ImageDebugType.PdbChecksum">
            <summary>
            Checksum of the PDB file. 0 or more entries allowed.
            </summary>
        </member>
        <member name="T:dnlib.PE.ImageDosHeader">
            <summary>
            Represents the IMAGE_DOS_HEADER PE section
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageDosHeader.NTHeadersOffset">
            <summary>
            File offset of the NT headers
            </summary>
        </member>
        <member name="M:dnlib.PE.ImageDosHeader.#ctor(dnlib.IO.DataReader@,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="reader">PE file reader</param>
            <param name="verify">Verify section</param>
            <exception cref="T:System.BadImageFormatException">Thrown if verification fails</exception>
        </member>
        <member name="T:dnlib.PE.ImageFileHeader">
            <summary>
            Represents the IMAGE_FILE_HEADER PE section
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageFileHeader.Machine">
            <summary>
            Returns the IMAGE_FILE_HEADER.Machine field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageFileHeader.NumberOfSections">
            <summary>
            Returns the IMAGE_FILE_HEADER.NumberOfSections field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageFileHeader.TimeDateStamp">
            <summary>
            Returns the IMAGE_FILE_HEADER.TimeDateStamp field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageFileHeader.PointerToSymbolTable">
            <summary>
            Returns the IMAGE_FILE_HEADER.PointerToSymbolTable field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageFileHeader.NumberOfSymbols">
            <summary>
            Returns the IMAGE_FILE_HEADER.NumberOfSymbols field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageFileHeader.SizeOfOptionalHeader">
            <summary>
            Returns the IMAGE_FILE_HEADER.SizeOfOptionalHeader field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageFileHeader.Characteristics">
            <summary>
            Returns the IMAGE_FILE_HEADER.Characteristics field
            </summary>
        </member>
        <member name="M:dnlib.PE.ImageFileHeader.#ctor(dnlib.IO.DataReader@,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="reader">PE file reader pointing to the start of this section</param>
            <param name="verify">Verify section</param>
            <exception cref="T:System.BadImageFormatException">Thrown if verification fails</exception>
        </member>
        <member name="T:dnlib.PE.ImageNTHeaders">
            <summary>
            Represents the IMAGE_NT_HEADERS PE section
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageNTHeaders.Signature">
            <summary>
            Returns the IMAGE_NT_HEADERS.Signature field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageNTHeaders.FileHeader">
            <summary>
            Returns the IMAGE_NT_HEADERS.FileHeader field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageNTHeaders.OptionalHeader">
            <summary>
            Returns the IMAGE_NT_HEADERS.OptionalHeader field
            </summary>
        </member>
        <member name="M:dnlib.PE.ImageNTHeaders.#ctor(dnlib.IO.DataReader@,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="reader">PE file reader pointing to the start of this section</param>
            <param name="verify">Verify section</param>
            <exception cref="T:System.BadImageFormatException">Thrown if verification fails</exception>
        </member>
        <member name="M:dnlib.PE.ImageNTHeaders.CreateImageOptionalHeader(dnlib.IO.DataReader@,System.Boolean)">
            <summary>
            Creates an IImageOptionalHeader
            </summary>
            <param name="reader">PE file reader pointing to the start of the optional header</param>
            <param name="verify">Verify section</param>
            <returns>The created IImageOptionalHeader</returns>
            <exception cref="T:System.BadImageFormatException">Thrown if verification fails</exception>
        </member>
        <member name="T:dnlib.PE.ImageOptionalHeader32">
            <summary>
            Represents the IMAGE_OPTIONAL_HEADER (32-bit) PE section
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.Magic">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.Magic field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.MajorLinkerVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.MajorLinkerVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.MinorLinkerVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.MinorLinkerVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.SizeOfCode">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.SizeOfCode field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.SizeOfInitializedData">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.SizeOfInitializedData field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.SizeOfUninitializedData">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.SizeOfUninitializedData field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.AddressOfEntryPoint">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.AddressOfEntryPoint field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.BaseOfCode">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.BaseOfCode field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.BaseOfData">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.BaseOfData field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.ImageBase">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.ImageBase field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.SectionAlignment">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.SectionAlignment field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.FileAlignment">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.FileAlignment field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.MajorOperatingSystemVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.MajorOperatingSystemVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.MinorOperatingSystemVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.MinorOperatingSystemVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.MajorImageVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.MajorImageVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.MinorImageVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.MinorImageVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.MajorSubsystemVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.MajorSubsystemVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.MinorSubsystemVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.MinorSubsystemVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.Win32VersionValue">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.Win32VersionValue field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.SizeOfImage">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.SizeOfImage field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.SizeOfHeaders">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.SizeOfHeaders field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.CheckSum">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.CheckSum field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.Subsystem">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.Subsystem field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.DllCharacteristics">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.DllCharacteristics field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.SizeOfStackReserve">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.SizeOfStackReserve field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.SizeOfStackCommit">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.SizeOfStackCommit field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.SizeOfHeapReserve">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.SizeOfHeapReserve field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.SizeOfHeapCommit">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.SizeOfHeapCommit field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.LoaderFlags">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.LoaderFlags field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.NumberOfRvaAndSizes">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader32.DataDirectories">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER.DataDirectories field
            </summary>
        </member>
        <member name="M:dnlib.PE.ImageOptionalHeader32.#ctor(dnlib.IO.DataReader@,System.UInt32,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="reader">PE file reader pointing to the start of this section</param>
            <param name="totalSize">Total size of this optional header (from the file header)</param>
            <param name="verify">Verify section</param>
            <exception cref="T:System.BadImageFormatException">Thrown if verification fails</exception>
        </member>
        <member name="T:dnlib.PE.ImageOptionalHeader64">
            <summary>
            Represents the IMAGE_OPTIONAL_HEADER64 PE section
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.Magic">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.Magic field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.MajorLinkerVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.MajorLinkerVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.MinorLinkerVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.MinorLinkerVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.SizeOfCode">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.SizeOfCode field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.SizeOfInitializedData">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.SizeOfInitializedData field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.SizeOfUninitializedData">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.SizeOfUninitializedData field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.AddressOfEntryPoint">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.AddressOfEntryPoint field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.BaseOfCode">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.BaseOfCode field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.BaseOfData">
            <summary>
            Returns 0 since BaseOfData is not present in IMAGE_OPTIONAL_HEADER64
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.ImageBase">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.ImageBase field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.SectionAlignment">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.SectionAlignment field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.FileAlignment">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.FileAlignment field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.MajorOperatingSystemVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.MajorOperatingSystemVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.MinorOperatingSystemVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.MinorOperatingSystemVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.MajorImageVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.MajorImageVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.MinorImageVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.MinorImageVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.MajorSubsystemVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.MajorSubsystemVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.MinorSubsystemVersion">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.MinorSubsystemVersion field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.Win32VersionValue">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.Win32VersionValue field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.SizeOfImage">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.SizeOfImage field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.SizeOfHeaders">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.SizeOfHeaders field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.CheckSum">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.CheckSum field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.Subsystem">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.Subsystem field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.DllCharacteristics">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.DllCharacteristics field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.SizeOfStackReserve">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.SizeOfStackReserve field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.SizeOfStackCommit">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.SizeOfStackCommit field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.SizeOfHeapReserve">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.SizeOfHeapReserve field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.SizeOfHeapCommit">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.SizeOfHeapCommit field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.LoaderFlags">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.LoaderFlags field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.NumberOfRvaAndSizes">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.NumberOfRvaAndSizes field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageOptionalHeader64.DataDirectories">
            <summary>
            Returns the IMAGE_OPTIONAL_HEADER64.DataDirectories field
            </summary>
        </member>
        <member name="M:dnlib.PE.ImageOptionalHeader64.#ctor(dnlib.IO.DataReader@,System.UInt32,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="reader">PE file reader pointing to the start of this section</param>
            <param name="totalSize">Total size of this optional header (from the file header)</param>
            <param name="verify">Verify section</param>
            <exception cref="T:System.BadImageFormatException">Thrown if verification fails</exception>
        </member>
        <member name="T:dnlib.PE.ImageSectionHeader">
            <summary>
            Represents the IMAGE_SECTION_HEADER PE section
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageSectionHeader.DisplayName">
            <summary>
            Returns the human readable section name, ignoring everything after
            the first nul byte
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageSectionHeader.Name">
            <summary>
            Returns the IMAGE_SECTION_HEADER.Name field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageSectionHeader.VirtualSize">
            <summary>
            Returns the IMAGE_SECTION_HEADER.VirtualSize field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageSectionHeader.VirtualAddress">
            <summary>
            Returns the IMAGE_SECTION_HEADER.VirtualAddress field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageSectionHeader.SizeOfRawData">
            <summary>
            Returns the IMAGE_SECTION_HEADER.SizeOfRawData field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageSectionHeader.PointerToRawData">
            <summary>
            Returns the IMAGE_SECTION_HEADER.PointerToRawData field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageSectionHeader.PointerToRelocations">
            <summary>
            Returns the IMAGE_SECTION_HEADER.PointerToRelocations field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageSectionHeader.PointerToLinenumbers">
            <summary>
            Returns the IMAGE_SECTION_HEADER.PointerToLinenumbers field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageSectionHeader.NumberOfRelocations">
            <summary>
            Returns the IMAGE_SECTION_HEADER.NumberOfRelocations field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageSectionHeader.NumberOfLinenumbers">
            <summary>
            Returns the IMAGE_SECTION_HEADER.NumberOfLinenumbers field
            </summary>
        </member>
        <member name="P:dnlib.PE.ImageSectionHeader.Characteristics">
            <summary>
            Returns the IMAGE_SECTION_HEADER.Characteristics field
            </summary>
        </member>
        <member name="M:dnlib.PE.ImageSectionHeader.#ctor(dnlib.IO.DataReader@,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="reader">PE file reader pointing to the start of this section</param>
            <param name="verify">Verify section</param>
            <exception cref="T:System.BadImageFormatException">Thrown if verification fails</exception>
        </member>
        <member name="T:dnlib.PE.IRvaFileOffsetConverter">
            <summary>
            Converts <see cref="T:dnlib.PE.RVA"/>s to/from <see cref="T:dnlib.IO.FileOffset"/>s
            </summary>
        </member>
        <member name="M:dnlib.PE.IRvaFileOffsetConverter.ToRVA(dnlib.IO.FileOffset)">
            <summary>
            Converts a <see cref="T:dnlib.IO.FileOffset"/> to an <see cref="T:dnlib.PE.RVA"/>
            </summary>
            <param name="offset">The file offset to convert</param>
            <returns>The RVA</returns>
        </member>
        <member name="M:dnlib.PE.IRvaFileOffsetConverter.ToFileOffset(dnlib.PE.RVA)">
            <summary>
            Converts an <see cref="T:dnlib.PE.RVA"/> to a <see cref="T:dnlib.IO.FileOffset"/>
            </summary>
            <param name="rva">The RVA to convert</param>
            <returns>The file offset</returns>
        </member>
        <member name="T:dnlib.PE.IPEImage">
            <summary>
            Interface to access a PE image
            </summary>
        </member>
        <member name="P:dnlib.PE.IPEImage.IsFileImageLayout">
            <summary>
            <c>true</c> if image layout is the same as the raw PE image layout, <c>false</c>
            if it's the same layout as a PE image loaded by the OS PE loader.
            </summary>
        </member>
        <member name="P:dnlib.PE.IPEImage.MayHaveInvalidAddresses">
            <summary>
            <c>true</c> if some of the memory where the image is located could be unavailable.
            This could happen if it's been loaded by the OS loader.
            </summary>
        </member>
        <member name="P:dnlib.PE.IPEImage.Filename">
            <summary>
            The filename or null if the data is not from a file
            </summary>
        </member>
        <member name="P:dnlib.PE.IPEImage.ImageDosHeader">
            <summary>
            Returns the DOS header
            </summary>
        </member>
        <member name="P:dnlib.PE.IPEImage.ImageNTHeaders">
            <summary>
            Returns the NT headers
            </summary>
        </member>
        <member name="P:dnlib.PE.IPEImage.ImageSectionHeaders">
            <summary>
            Returns the section headers
            </summary>
        </member>
        <member name="P:dnlib.PE.IPEImage.ImageDebugDirectories">
            <summary>
            Returns the debug directories
            </summary>
        </member>
        <member name="P:dnlib.PE.IPEImage.Win32Resources">
            <summary>
            Gets/sets the Win32 resources. This is <c>null</c> if there are no Win32 resources.
            </summary>
        </member>
        <member name="P:dnlib.PE.IPEImage.DataReaderFactory">
            <summary>
            Gets the <see cref="T:dnlib.IO.DataReader"/> factory
            </summary>
        </member>
        <member name="M:dnlib.PE.IPEImage.CreateReader(dnlib.IO.FileOffset)">
            <summary>
            Creates a <see cref="T:dnlib.IO.DataReader"/> from <paramref name="offset"/> to the end of the image
            </summary>
            <param name="offset">Offset of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.PE.IPEImage.CreateReader(dnlib.IO.FileOffset,System.UInt32)">
            <summary>
            Creates a <see cref="T:dnlib.IO.DataReader"/>
            </summary>
            <param name="offset">Offset of data</param>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.PE.IPEImage.CreateReader(dnlib.PE.RVA)">
            <summary>
            Creates a <see cref="T:dnlib.IO.DataReader"/> from <paramref name="rva"/> to the end of the image
            </summary>
            <param name="rva">RVA of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.PE.IPEImage.CreateReader(dnlib.PE.RVA,System.UInt32)">
            <summary>
            Creates a <see cref="T:dnlib.IO.DataReader"/>
            </summary>
            <param name="rva">RVA of data</param>
            <param name="length">Length of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.PE.IPEImage.CreateReader">
            <summary>
            Creates a <see cref="T:dnlib.IO.DataReader"/> that can read the whole image
            </summary>
            <returns></returns>
        </member>
        <member name="T:dnlib.PE.IInternalPEImage">
            <summary>
            Interface to access a PE image
            </summary>
        </member>
        <member name="M:dnlib.PE.IInternalPEImage.UnsafeDisableMemoryMappedIO">
            <summary>
            Call this to disable memory mapped I/O if it was used to open the file. This must only
            be called if no other code is trying to access the memory since that could lead to an
            exception.
            </summary>
        </member>
        <member name="P:dnlib.PE.IInternalPEImage.IsMemoryMappedIO">
            <summary>
            <c>true</c> if memory mapped I/O is enabled
            </summary>
        </member>
        <member name="T:dnlib.PE.PEExtensions">
            <summary>
            Extension methods
            </summary>
        </member>
        <member name="M:dnlib.PE.PEExtensions.FindWin32ResourceData(dnlib.PE.IPEImage,dnlib.W32Resources.ResourceName,dnlib.W32Resources.ResourceName,dnlib.W32Resources.ResourceName)">
            <summary>
            Finds a <see cref="T:dnlib.W32Resources.ResourceData"/>
            </summary>
            <param name="self">this</param>
            <param name="type">Type</param>
            <param name="name">Name</param>
            <param name="langId">Language ID</param>
            <returns>The <see cref="T:dnlib.W32Resources.ResourceData"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.PE.PEExtensions.CalculatePECheckSum(System.IO.Stream,System.Int64,System.Int64)">
            <summary>
            Calculates a PE checksum
            </summary>
            <param name="stream">PE image stream positioned at the MZ bytes</param>
            <param name="length">Length of image</param>
            <param name="checkSumOffset">Offset of checksum</param>
            <returns>PE checksum</returns>
        </member>
        <member name="M:dnlib.PE.PEExtensions.AlignUp(dnlib.PE.RVA,System.UInt32)">
            <summary>
            Align up
            </summary>
            <param name="rva">this</param>
            <param name="alignment">Alignment</param>
        </member>
        <member name="M:dnlib.PE.PEExtensions.AlignUp(dnlib.PE.RVA,System.Int32)">
            <summary>
            Align up
            </summary>
            <param name="rva">this</param>
            <param name="alignment">Alignment</param>
        </member>
        <member name="T:dnlib.PE.IPEType">
            <summary>
            Converts a <see cref="T:dnlib.IO.FileOffset"/> to/from an <see cref="T:dnlib.PE.RVA"/>
            </summary>
        </member>
        <member name="M:dnlib.PE.IPEType.ToRVA(dnlib.PE.PEInfo,dnlib.IO.FileOffset)">
            <summary>
            Converts a <see cref="T:dnlib.IO.FileOffset"/> to an <see cref="T:dnlib.PE.RVA"/>
            </summary>
            <param name="peInfo">The PEInfo context</param>
            <param name="offset">The file offset to convert</param>
            <returns>The RVA</returns>
        </member>
        <member name="M:dnlib.PE.IPEType.ToFileOffset(dnlib.PE.PEInfo,dnlib.PE.RVA)">
            <summary>
            Converts an <see cref="T:dnlib.PE.RVA"/> to a <see cref="T:dnlib.IO.FileOffset"/>
            </summary>
            <param name="peInfo">The PEInfo context</param>
            <param name="rva">The RVA to convert</param>
            <returns>The file offset</returns>
        </member>
        <member name="T:dnlib.PE.Machine">
            <summary>
            IMAGE_FILE_HEADER.Machine enum
            </summary>
        </member>
        <member name="F:dnlib.PE.Machine.Unknown">
            <summary>Unknown machine</summary>
        </member>
        <member name="F:dnlib.PE.Machine.I386">
            <summary>x86</summary>
        </member>
        <member name="F:dnlib.PE.Machine.R3000">
            <summary>MIPS little-endian, 0x160 big-endian</summary>
        </member>
        <member name="F:dnlib.PE.Machine.R4000">
            <summary>MIPS little-endian</summary>
        </member>
        <member name="F:dnlib.PE.Machine.R10000">
            <summary>MIPS little-endian</summary>
        </member>
        <member name="F:dnlib.PE.Machine.WCEMIPSV2">
            <summary>MIPS little-endian WCE v2</summary>
        </member>
        <member name="F:dnlib.PE.Machine.ALPHA">
            <summary>Alpha_AXP</summary>
        </member>
        <member name="F:dnlib.PE.Machine.SH3">
            <summary>SH3 little-endian</summary>
        </member>
        <member name="F:dnlib.PE.Machine.SH3DSP">
            <summary></summary>
        </member>
        <member name="F:dnlib.PE.Machine.SH3E">
            <summary>SH3E little-endian</summary>
        </member>
        <member name="F:dnlib.PE.Machine.SH4">
            <summary>SH4 little-endian</summary>
        </member>
        <member name="F:dnlib.PE.Machine.SH5">
            <summary>SH5</summary>
        </member>
        <member name="F:dnlib.PE.Machine.ARM">
            <summary>ARM Little-Endian</summary>
        </member>
        <member name="F:dnlib.PE.Machine.THUMB">
            <summary>ARM Thumb/Thumb-2 Little-Endian</summary>
        </member>
        <member name="F:dnlib.PE.Machine.ARMNT">
            <summary>ARM Thumb-2 Little-Endian</summary>
        </member>
        <member name="F:dnlib.PE.Machine.AM33">
            <summary></summary>
        </member>
        <member name="F:dnlib.PE.Machine.POWERPC">
            <summary>IBM PowerPC Little-Endian</summary>
        </member>
        <member name="F:dnlib.PE.Machine.POWERPCFP">
            <summary></summary>
        </member>
        <member name="F:dnlib.PE.Machine.IA64">
            <summary>IA-64</summary>
        </member>
        <member name="F:dnlib.PE.Machine.MIPS16">
            <summary></summary>
        </member>
        <member name="F:dnlib.PE.Machine.ALPHA64">
            <summary></summary>
        </member>
        <member name="F:dnlib.PE.Machine.MIPSFPU">
            <summary></summary>
        </member>
        <member name="F:dnlib.PE.Machine.MIPSFPU16">
            <summary></summary>
        </member>
        <member name="F:dnlib.PE.Machine.TRICORE">
            <summary>Infineon</summary>
        </member>
        <member name="F:dnlib.PE.Machine.CEF">
            <summary></summary>
        </member>
        <member name="F:dnlib.PE.Machine.EBC">
            <summary>EFI Byte Code</summary>
        </member>
        <member name="F:dnlib.PE.Machine.AMD64">
            <summary>x64</summary>
        </member>
        <member name="F:dnlib.PE.Machine.M32R">
            <summary>M32R little-endian</summary>
        </member>
        <member name="F:dnlib.PE.Machine.ARM64">
            <summary></summary>
        </member>
        <member name="F:dnlib.PE.Machine.CEE">
            <summary></summary>
        </member>
        <member name="T:dnlib.PE.MachineExtensions">
            <summary>
            Extensions
            </summary>
        </member>
        <member name="M:dnlib.PE.MachineExtensions.Is64Bit(dnlib.PE.Machine)">
            <summary>
            Checks if <paramref name="machine"/> is a 64-bit machine
            </summary>
            <param name="machine">Machine</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.PE.MachineExtensions.IsI386(dnlib.PE.Machine)">
            <summary>
            Checks if <paramref name="machine"/> is <see cref="F:dnlib.PE.Machine.I386"/>, <see cref="F:dnlib.PE.Machine.I386_Native_Apple"/>, etc...
            </summary>
            <param name="machine">Machine</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.PE.MachineExtensions.IsAMD64(dnlib.PE.Machine)">
            <summary>
            Checks if <paramref name="machine"/> is <see cref="F:dnlib.PE.Machine.AMD64"/>, <see cref="F:dnlib.PE.Machine.AMD64_Native_Apple"/>, etc...
            </summary>
            <param name="machine">Machine</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.PE.MachineExtensions.IsARMNT(dnlib.PE.Machine)">
            <summary>
            Checks if <paramref name="machine"/> is <see cref="F:dnlib.PE.Machine.ARMNT"/>, <see cref="F:dnlib.PE.Machine.ARMNT_Native_Apple"/>, etc...
            </summary>
            <param name="machine">Machine</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.PE.MachineExtensions.IsARM64(dnlib.PE.Machine)">
            <summary>
            Checks if <paramref name="machine"/> is <see cref="F:dnlib.PE.Machine.ARM64"/>, <see cref="F:dnlib.PE.Machine.ARM64_Native_Apple"/>, etc...
            </summary>
            <param name="machine">Machine</param>
            <returns></returns>
        </member>
        <member name="T:dnlib.PE.ImageLayout">
            <summary>
            Image layout
            </summary>
        </member>
        <member name="F:dnlib.PE.ImageLayout.File">
            <summary>
            Use this if the PE file has a normal structure (eg. it's been read from a file on disk)
            </summary>
        </member>
        <member name="F:dnlib.PE.ImageLayout.Memory">
            <summary>
            Use this if the PE file has been loaded into memory by the OS PE file loader
            </summary>
        </member>
        <member name="T:dnlib.PE.PEImage">
            <summary>
            Accesses a PE file
            </summary>
        </member>
        <member name="P:dnlib.PE.PEImage.IsFileImageLayout">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.PE.PEImage.MayHaveInvalidAddresses">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.PE.PEImage.Filename">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.PE.PEImage.ImageDosHeader">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.PE.PEImage.ImageNTHeaders">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.PE.PEImage.ImageSectionHeaders">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.PE.PEImage.ImageDebugDirectories">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.PE.PEImage.DataReaderFactory">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.PE.PEImage.Win32Resources">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(dnlib.IO.DataReaderFactory,dnlib.PE.ImageLayout,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="dataReaderFactory">Data reader factory</param>
            <param name="imageLayout">Image layout</param>
            <param name="verify">Verify PE file data</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.String,System.Boolean,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="filename">Name of the file</param>
            <param name="mapAsImage"><c>true</c> if we should map it as an executable</param>
            <param name="verify">Verify PE file data</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="filename">Name of the file</param>
            <param name="verify">Verify PE file data</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="filename">Name of the file</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.Byte[],System.String,dnlib.PE.ImageLayout,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="data">The PE file data</param>
            <param name="filename">Filename or null</param>
            <param name="imageLayout">Image layout</param>
            <param name="verify">Verify PE file data</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.Byte[],dnlib.PE.ImageLayout,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="data">The PE file data</param>
            <param name="imageLayout">Image layout</param>
            <param name="verify">Verify PE file data</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="data">The PE file data</param>
            <param name="verify">Verify PE file data</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.Byte[],System.String,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="data">The PE file data</param>
            <param name="filename">Filename or null</param>
            <param name="verify">Verify PE file data</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="data">The PE file data</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.Byte[],System.String)">
            <summary>
            Constructor
            </summary>
            <param name="data">The PE file data</param>
            <param name="filename">Filename or null</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.IntPtr,System.UInt32,dnlib.PE.ImageLayout,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="baseAddr">Address of PE image</param>
            <param name="length">Length of PE image</param>
            <param name="imageLayout">Image layout</param>
            <param name="verify">Verify PE file data</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.IntPtr,System.UInt32,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="baseAddr">Address of PE image</param>
            <param name="length">Length of PE image</param>
            <param name="verify">Verify PE file data</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.IntPtr,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="baseAddr">Address of PE image</param>
            <param name="length">Length of PE image</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.IntPtr,dnlib.PE.ImageLayout,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="baseAddr">Address of PE image</param>
            <param name="imageLayout">Image layout</param>
            <param name="verify">Verify PE file data</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="baseAddr">Address of PE image</param>
            <param name="verify">Verify PE file data</param>
        </member>
        <member name="M:dnlib.PE.PEImage.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="baseAddr">Address of PE image</param>
        </member>
        <member name="M:dnlib.PE.PEImage.ToRVA(dnlib.IO.FileOffset)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.PE.PEImage.ToFileOffset(dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.PE.PEImage.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.PE.PEImage.CreateReader(dnlib.IO.FileOffset)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.PE.PEImage.CreateReader(dnlib.IO.FileOffset,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.PE.PEImage.CreateReader(dnlib.PE.RVA)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.PE.PEImage.CreateReader(dnlib.PE.RVA,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.PE.PEImage.CreateReader">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.PE.PEInfo">
            <summary>
            Reads all PE sections from a PE stream
            </summary>
        </member>
        <member name="P:dnlib.PE.PEInfo.ImageDosHeader">
            <summary>
            Returns the DOS header
            </summary>
        </member>
        <member name="P:dnlib.PE.PEInfo.ImageNTHeaders">
            <summary>
            Returns the NT headers
            </summary>
        </member>
        <member name="P:dnlib.PE.PEInfo.ImageSectionHeaders">
            <summary>
            Returns the section headers
            </summary>
        </member>
        <member name="M:dnlib.PE.PEInfo.#ctor(dnlib.IO.DataReader@,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="reader">PE file reader pointing to the start of this section</param>
            <param name="verify">Verify sections</param>
            <exception cref="T:System.BadImageFormatException">Thrown if verification fails</exception>
        </member>
        <member name="M:dnlib.PE.PEInfo.ToImageSectionHeader(dnlib.IO.FileOffset)">
            <summary>
            Returns the first <see cref="T:dnlib.PE.ImageSectionHeader"/> that has data at file offset
            <paramref name="offset"/>
            </summary>
            <param name="offset">The file offset</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.PE.PEInfo.ToImageSectionHeader(dnlib.PE.RVA)">
            <summary>
            Returns the first <see cref="T:dnlib.PE.ImageSectionHeader"/> that has data at RVA
            <paramref name="rva"/>
            </summary>
            <param name="rva">The RVA</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.PE.PEInfo.ToRVA(dnlib.IO.FileOffset)">
            <summary>
            Converts a <see cref="T:dnlib.IO.FileOffset"/> to an <see cref="T:dnlib.PE.RVA"/>
            </summary>
            <param name="offset">The file offset to convert</param>
            <returns>The RVA</returns>
        </member>
        <member name="M:dnlib.PE.PEInfo.ToFileOffset(dnlib.PE.RVA)">
            <summary>
            Converts an <see cref="T:dnlib.PE.RVA"/> to a <see cref="T:dnlib.IO.FileOffset"/>
            </summary>
            <param name="rva">The RVA to convert</param>
            <returns>The file offset</returns>
        </member>
        <member name="M:dnlib.PE.PEInfo.GetImageSize">
            <summary>
            Returns size of image rounded up to <see cref="P:dnlib.PE.IImageOptionalHeader.SectionAlignment"/>
            </summary>
            <remarks>It calculates the size itself, and does not return <see cref="P:dnlib.PE.IImageOptionalHeader.SizeOfImage"/></remarks>
            <returns>Size of image in bytes</returns>
        </member>
        <member name="T:dnlib.PE.RVA">
            <summary>
            Represents an RVA (relative virtual address)
            </summary>
        </member>
        <member name="T:dnlib.PE.Subsystem">
            <summary>
            IMAGE_OPTIONAL_HEADER.Subsystem
            </summary>
        </member>
        <member name="F:dnlib.PE.Subsystem.Unknown">
            <summary>Unknown subsystem.</summary>
        </member>
        <member name="F:dnlib.PE.Subsystem.Native">
            <summary>Image doesn't require a subsystem.</summary>
        </member>
        <member name="F:dnlib.PE.Subsystem.WindowsGui">
            <summary>Image runs in the Windows GUI subsystem.</summary>
        </member>
        <member name="F:dnlib.PE.Subsystem.WindowsCui">
            <summary>Image runs in the Windows character subsystem.</summary>
        </member>
        <member name="F:dnlib.PE.Subsystem.Os2Cui">
            <summary>image runs in the OS/2 character subsystem.</summary>
        </member>
        <member name="F:dnlib.PE.Subsystem.PosixCui">
            <summary>image runs in the Posix character subsystem.</summary>
        </member>
        <member name="F:dnlib.PE.Subsystem.NativeWindows">
            <summary>image is a native Win9x driver.</summary>
        </member>
        <member name="F:dnlib.PE.Subsystem.WindowsCeGui">
            <summary>Image runs in the Windows CE subsystem.</summary>
        </member>
        <member name="F:dnlib.PE.Subsystem.EfiApplication">
            <summary/>
        </member>
        <member name="F:dnlib.PE.Subsystem.EfiBootServiceDriver">
            <summary/>
        </member>
        <member name="F:dnlib.PE.Subsystem.EfiRuntimeDriver">
            <summary/>
        </member>
        <member name="F:dnlib.PE.Subsystem.EfiRom">
            <summary/>
        </member>
        <member name="F:dnlib.PE.Subsystem.Xbox">
            <summary/>
        </member>
        <member name="F:dnlib.PE.Subsystem.WindowsBootApplication">
            <summary/>
        </member>
        <member name="T:dnlib.Settings">
            <summary>
            dnlib settings
            </summary>
        </member>
        <member name="P:dnlib.Settings.IsThreadSafe">
            <summary>
            <c>true</c> if dnlib is thread safe. (<c>THREAD_SAFE</c> was defined during compilation)
            </summary>
        </member>
        <member name="T:dnlib.Threading.ICancellationToken">
            <summary>
            Cancellation token interface
            </summary>
        </member>
        <member name="M:dnlib.Threading.ICancellationToken.ThrowIfCancellationRequested">
            <summary>
            Throws a <see cref="T:System.OperationCanceledException"/> if the operation should be canceled
            </summary>
        </member>
        <member name="T:dnlib.Threading.Lock">
            <summary>
            Simple class using Monitor.Enter() and Monitor.Exit()
            and just like <c>ReaderWriterLockSlim</c> it prevents recursive locks. It doesn't support
            multiple readers. A reader lock is the same as a writer lock.
            </summary>
        </member>
        <member name="M:dnlib.Threading.Lock.Create">
            <summary>
            Creates a new instance of this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.Threading.Lock.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:dnlib.Threading.Lock.EnterReadLock">
            <summary>
            Enter read mode
            </summary>
        </member>
        <member name="M:dnlib.Threading.Lock.ExitReadLock">
            <summary>
            Exit read mode
            </summary>
        </member>
        <member name="M:dnlib.Threading.Lock.EnterWriteLock">
            <summary>
            Enter write mode
            </summary>
        </member>
        <member name="M:dnlib.Threading.Lock.ExitWriteLock">
            <summary>
            Exit write mode
            </summary>
        </member>
        <member name="T:dnlib.Utils.ILazyList`1">
            <summary>
            Interface to access a lazily initialized list
            </summary>
            <typeparam name="TValue">Type to store in list</typeparam>
        </member>
        <member name="T:dnlib.Utils.IListListener`1">
            <summary>
            Gets notified of list events
            </summary>
            <typeparam name="TListValue">List value</typeparam>
        </member>
        <member name="M:dnlib.Utils.IListListener`1.OnLazyAdd(System.Int32,`0@)">
            <summary>
            Called before a new value is lazily added to the list.
            </summary>
            <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
            since a write lock is now held by this thread.</remarks>
            <param name="index">Index where the value will be added</param>
            <param name="value">Value that will be added to the list. It can be modified by
            the callee.</param>
        </member>
        <member name="M:dnlib.Utils.IListListener`1.OnAdd(System.Int32,`0)">
            <summary>
            Called before a new value is added to the list.
            </summary>
            <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
            since a write lock is now held by this thread.</remarks>
            <param name="index">Index where the value will be added</param>
            <param name="value">Value that will be added to the list</param>
        </member>
        <member name="M:dnlib.Utils.IListListener`1.OnRemove(System.Int32,`0)">
            <summary>
            Called before a value is removed from the list. If all elements are removed,
            <see cref="M:dnlib.Utils.IListListener`1.OnClear"/> is called, and this method is not called.
            </summary>
            <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
            since a write lock is now held by this thread.</remarks>
            <param name="index">Index of value</param>
            <param name="value">The value that will be removed</param>
        </member>
        <member name="M:dnlib.Utils.IListListener`1.OnResize(System.Int32)">
            <summary>
            Called after the list has been resized (eg. an element has been added/removed). It's not
            called when an element is replaced.
            </summary>
            <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
            since a write lock is now held by this thread.</remarks>
            <param name="index">Index where the change occurred.</param>
        </member>
        <member name="M:dnlib.Utils.IListListener`1.OnClear">
            <summary>
            Called before the whole list is cleared.
            </summary>
            <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
            since a write lock is now held by this thread.</remarks>
        </member>
        <member name="T:dnlib.Utils.LazyList`1">
            <summary>
            Implements a <see cref="T:System.Collections.Generic.IList`1"/> that is lazily initialized
            </summary>
            <typeparam name="TValue">Type to store in list</typeparam>
        </member>
        <member name="T:dnlib.Utils.LazyList`1.Element">
            <summary>
            Stores a simple value
            </summary>
        </member>
        <member name="P:dnlib.Utils.LazyList`1.Element.IsInitialized_NoLock">
            <summary>
            <c>true</c> if it has been initialized, <c>false</c> otherwise
            </summary>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.Element.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.Element.#ctor(`0)">
            <summary>
            Constructor that should be used when new elements are inserted into <see cref="T:dnlib.Utils.LazyList`1"/>
            </summary>
            <param name="data">User data</param>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.Element.GetValue_NoLock(System.Int32)">
            <summary>
            Gets the value
            </summary>
            <param name="index">Index in the list</param>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.Element.SetValue_NoLock(System.Int32,`0)">
            <summary>
            Sets the value
            </summary>
            <param name="index">Index in the list</param>
            <param name="value">New value</param>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.Element.ToString">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.Utils.LazyList`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.Utils.LazyList`1.Count_NoLock">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.Utils.LazyList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:dnlib.Utils.LazyList`1.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.#ctor(dnlib.Utils.IListListener{`0})">
            <summary>
            Constructor
            </summary>
            <param name="listener">List listener</param>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.Utils.LazyList`1.Enumerator">
            <summary>
            Enumerator
            </summary>
        </member>
        <member name="P:dnlib.Utils.LazyList`1.Enumerator.Current">
            <summary>
            Gets the current value
            </summary>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.Enumerator.MoveNext">
            <summary>
            Moves to the next element in the collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.Enumerator.Dispose">
            <summary>
            Disposes the enumerator
            </summary>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.GetEnumerator">
            <summary>
            Gets the list enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:dnlib.Utils.LazyList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.Utils.LazyList`2">
            <summary>
            Implements a <see cref="T:System.Collections.Generic.IList`1"/> that is lazily initialized
            </summary>
            <typeparam name="TValue">Type to store in list</typeparam>
            <typeparam name="TContext">Type of the context passed to the read-value delegate</typeparam>
        </member>
        <member name="T:dnlib.Utils.LazyList`2.LazyElement">
            <summary>
            Stores data and keeps track of the original index and whether the data has been
            initialized or not.
            </summary>
        </member>
        <member name="P:dnlib.Utils.LazyList`2.LazyElement.IsInitialized_NoLock">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.Utils.LazyList`2.LazyElement.GetValue_NoLock(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.Utils.LazyList`2.LazyElement.SetValue_NoLock(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.Utils.LazyList`2.LazyElement.#ctor(System.Int32,dnlib.Utils.LazyList{`0,`1})">
            <summary>
            Constructor that should only be called when <see cref="T:dnlib.Utils.LazyList`2"/> is initialized.
            </summary>
            <param name="origIndex">Original index of this element</param>
            <param name="lazyList">LazyList instance</param>
        </member>
        <member name="M:dnlib.Utils.LazyList`2.LazyElement.ToString">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.Utils.LazyList`2.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:dnlib.Utils.LazyList`2.#ctor(dnlib.Utils.IListListener{`0})">
            <summary>
            Constructor
            </summary>
            <param name="listener">List listener</param>
        </member>
        <member name="M:dnlib.Utils.LazyList`2.#ctor(System.Int32,`1,System.Func{`1,System.Int32,`0})">
            <summary>
            Constructor
            </summary>
            <param name="length">Initial length of the list</param>
            <param name="context">Context passed to <paramref name="readOriginalValue"/></param>
            <param name="readOriginalValue">Delegate instance that returns original values</param>
        </member>
        <member name="M:dnlib.Utils.LazyList`2.#ctor(System.Int32,dnlib.Utils.IListListener{`0},`1,System.Func{`1,System.Int32,`0})">
            <summary>
            Constructor
            </summary>
            <param name="length">Initial length of the list</param>
            <param name="listener">List listener</param>
            <param name="context">Context passed to <paramref name="readOriginalValue"/></param>
            <param name="readOriginalValue">Delegate instance that returns original values</param>
        </member>
        <member name="T:dnlib.Utils.SimpleLazyList`1">
            <summary>
            A readonly list that gets initialized lazily
            </summary>
            <typeparam name="T">Any class type</typeparam>
        </member>
        <member name="P:dnlib.Utils.SimpleLazyList`1.Length">
            <summary>
            Gets the length of this list
            </summary>
        </member>
        <member name="P:dnlib.Utils.SimpleLazyList`1.Item(System.UInt32)">
            <summary>
            Access the list
            </summary>
            <param name="index">Index</param>
            <returns>The element or <c>null</c> if <paramref name="index"/> is invalid</returns>
        </member>
        <member name="M:dnlib.Utils.SimpleLazyList`1.#ctor(System.UInt32,System.Func{System.UInt32,`0})">
            <summary>
            Constructor
            </summary>
            <param name="length">Length of the list</param>
            <param name="readElementByRID">Delegate instance that lazily reads an element. It might
            be called more than once for each <c>rid</c> in rare cases. It must never return
            <c>null</c>.</param>
        </member>
        <member name="T:dnlib.Utils.SimpleLazyList2`1">
            <summary>
            A readonly list that gets initialized lazily
            </summary>
            <typeparam name="T">Any class type</typeparam>
        </member>
        <member name="P:dnlib.Utils.SimpleLazyList2`1.Length">
            <summary>
            Gets the length of this list
            </summary>
        </member>
        <member name="P:dnlib.Utils.SimpleLazyList2`1.Item(System.UInt32,dnlib.DotNet.GenericParamContext)">
            <summary>
            Access the list
            </summary>
            <param name="index">Index</param>
            <param name="gpContext">Generic parameter context</param>
            <returns>The element or <c>null</c> if <paramref name="index"/> is invalid</returns>
        </member>
        <member name="M:dnlib.Utils.SimpleLazyList2`1.#ctor(System.UInt32,System.Func{System.UInt32,dnlib.DotNet.GenericParamContext,`0})">
            <summary>
            Constructor
            </summary>
            <param name="length">Length of the list</param>
            <param name="readElementByRID">Delegate instance that lazily reads an element. It might
            be called more than once for each <c>rid</c>. It must never return <c>null</c>.</param>
        </member>
        <member name="T:dnlib.Utils.UserValue`1">
            <summary>
            Lazily returns the original value if the user hasn't overwritten the value
            </summary>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="P:dnlib.Utils.UserValue`1.Lock">
            <summary>
            Sets the lock that protects the data
            </summary>
        </member>
        <member name="P:dnlib.Utils.UserValue`1.ReadOriginalValue">
            <summary>
            Set a delegate instance that will return the original value
            </summary>
        </member>
        <member name="P:dnlib.Utils.UserValue`1.Value">
            <summary>
            Gets/sets the value
            </summary>
            <remarks>The getter returns the original value if the value hasn't been initialized.</remarks>
        </member>
        <member name="P:dnlib.Utils.UserValue`1.IsValueInitialized">
            <summary>
            Returns <c>true</c> if the value has been initialized
            </summary>
        </member>
        <member name="P:dnlib.Utils.UserValue`1.IsUserValue">
            <summary>
            Returns <c>true</c> if the value was set by the user
            </summary>
        </member>
        <member name="T:dnlib.W32Resources.ResourceData">
            <summary>
            A resource blob
            </summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceData.CreateReader">
            <summary>
            Gets the data reader
            </summary>
            <returns></returns>
        </member>
        <member name="P:dnlib.W32Resources.ResourceData.CodePage">
            <summary>
            Gets/sets the code page
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.ResourceData.Reserved">
            <summary>
            Gets/sets the reserved field
            </summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceData.#ctor(dnlib.W32Resources.ResourceName)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:dnlib.W32Resources.ResourceData.#ctor(dnlib.W32Resources.ResourceName,dnlib.IO.DataReaderFactory,System.UInt32,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="dataReaderFactory">Data reader factory</param>
            <param name="offset">Offset of resource data</param>
            <param name="length">Length of resource data</param>
            <param name="name">Name</param>
        </member>
        <member name="M:dnlib.W32Resources.ResourceData.#ctor(dnlib.W32Resources.ResourceName,dnlib.IO.DataReaderFactory,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="dataReaderFactory">Data reader factory</param>
            <param name="offset">Offset of resource data</param>
            <param name="length">Length of resource data</param>
            <param name="name">Name</param>
            <param name="codePage">Code page</param>
            <param name="reserved">Reserved value</param>
        </member>
        <member name="T:dnlib.W32Resources.ResourceDirectory">
            <summary>
            A Win32 resource directory (see IMAGE_RESOURCE_DIRECTORY in the Windows SDK)
            </summary>
        </member>
        <member name="F:dnlib.W32Resources.ResourceDirectory.characteristics">
            <summary>See <see cref="P:dnlib.W32Resources.ResourceDirectory.Characteristics"/></summary>
        </member>
        <member name="F:dnlib.W32Resources.ResourceDirectory.timeDateStamp">
            <summary>See <see cref="P:dnlib.W32Resources.ResourceDirectory.TimeDateStamp"/></summary>
        </member>
        <member name="F:dnlib.W32Resources.ResourceDirectory.majorVersion">
            <summary>See <see cref="P:dnlib.W32Resources.ResourceDirectory.MajorVersion"/></summary>
        </member>
        <member name="F:dnlib.W32Resources.ResourceDirectory.minorVersion">
            <summary>See <see cref="P:dnlib.W32Resources.ResourceDirectory.MinorVersion"/></summary>
        </member>
        <member name="F:dnlib.W32Resources.ResourceDirectory.directories">
            <summary>See <see cref="P:dnlib.W32Resources.ResourceDirectory.Directories"/></summary>
        </member>
        <member name="F:dnlib.W32Resources.ResourceDirectory.data">
            <summary>See <see cref="P:dnlib.W32Resources.ResourceDirectory.Data"/></summary>
        </member>
        <member name="P:dnlib.W32Resources.ResourceDirectory.Characteristics">
            <summary>
            Gets/sets the characteristics
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.ResourceDirectory.TimeDateStamp">
            <summary>
            Gets/sets the time date stamp
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.ResourceDirectory.MajorVersion">
            <summary>
            Gets/sets the major version number
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.ResourceDirectory.MinorVersion">
            <summary>
            Gets/sets the minor version number
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.ResourceDirectory.Directories">
            <summary>
            Gets all directory entries
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.ResourceDirectory.Data">
            <summary>
            Gets all resource data
            </summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceDirectory.#ctor(dnlib.W32Resources.ResourceName)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:dnlib.W32Resources.ResourceDirectory.FindDirectory(dnlib.W32Resources.ResourceName)">
            <summary>
            Finds a <see cref="T:dnlib.W32Resources.ResourceDirectory"/> by name
            </summary>
            <param name="name">Name</param>
            <returns>A <see cref="T:dnlib.W32Resources.ResourceDirectory"/> or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="M:dnlib.W32Resources.ResourceDirectory.FindData(dnlib.W32Resources.ResourceName)">
            <summary>
            Finds a <see cref="T:dnlib.W32Resources.ResourceData"/> by name
            </summary>
            <param name="name">Name</param>
            <returns>A <see cref="T:dnlib.W32Resources.ResourceData"/> or <c>null</c> if it wasn't found</returns>
        </member>
        <member name="T:dnlib.W32Resources.ResourceDirectoryUser">
            <summary>
            A Win32 resource directory created by the user
            </summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceDirectoryUser.#ctor(dnlib.W32Resources.ResourceName)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="T:dnlib.W32Resources.ResourceDirectoryPE">
            <summary>
            A Win32 resource directory created from a PE file
            </summary>
        </member>
        <member name="F:dnlib.W32Resources.ResourceDirectoryPE.MAX_DIR_DEPTH">
            <summary>
            To make sure we don't get stuck in an infinite loop, don't allow more than this
            many sub directories.
            </summary>
        </member>
        <member name="F:dnlib.W32Resources.ResourceDirectoryPE.resources">
            <summary>Owner</summary>
        </member>
        <member name="F:dnlib.W32Resources.ResourceDirectoryPE.depth">
            <summary>Directory depth. When creating more <see cref="T:dnlib.W32Resources.ResourceDirectoryPE"/>'s,
            the instances get this value + 1</summary>
        </member>
        <member name="F:dnlib.W32Resources.ResourceDirectoryPE.dataInfos">
            <summary>
            Info about all <see cref="T:dnlib.W32Resources.ResourceData"/>'s we haven't created yet
            </summary>
        </member>
        <member name="F:dnlib.W32Resources.ResourceDirectoryPE.dirInfos">
            <summary>
            Info about all <see cref="T:dnlib.W32Resources.ResourceDirectory"/>'s we haven't created yet
            </summary>
        </member>
        <member name="F:dnlib.W32Resources.ResourceDirectoryPE.EntryInfo.offset">
            <summary>Offset of resource directory / data</summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceDirectoryPE.#ctor(System.UInt32,dnlib.W32Resources.ResourceName,dnlib.W32Resources.Win32ResourcesPE,dnlib.IO.DataReader@)">
            <summary>
            Constructor
            </summary>
            <param name="depth">Starts from 0. If it's big enough, we'll stop reading more data.</param>
            <param name="name">Name</param>
            <param name="resources">Resources</param>
            <param name="reader">Reader positioned at the start of this resource directory</param>
        </member>
        <member name="M:dnlib.W32Resources.ResourceDirectoryPE.Initialize(dnlib.IO.DataReader@)">
            <summary>
            Reads the directory header and initializes <see cref="F:dnlib.W32Resources.ResourceDirectory.directories"/> and
            <see cref="F:dnlib.W32Resources.ResourceDirectory.data"/>.
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:dnlib.W32Resources.ResourceDirectoryPE.ReadString(dnlib.IO.DataReader@,System.UInt32)">
            <summary>
            Reads a string
            </summary>
            <param name="reader">Reader</param>
            <param name="offset">Offset of string</param>
            <returns>The string or <c>null</c> if we could not read it</returns>
        </member>
        <member name="T:dnlib.W32Resources.ResourceDirectoryEntry">
            <summary>
            Base class of <see cref="T:dnlib.W32Resources.ResourceDirectory"/> and <see cref="T:dnlib.W32Resources.ResourceData"/>
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.ResourceDirectoryEntry.Name">
            <summary>
            Gets/sets the name
            </summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceDirectoryEntry.#ctor(dnlib.W32Resources.ResourceName)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:dnlib.W32Resources.ResourceDirectoryEntry.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.W32Resources.ResourceName">
            <summary>
            A Win32 resource name. It can be either an integer or a string.
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.ResourceName.HasId">
            <summary>
            <c>true</c> if <see cref="P:dnlib.W32Resources.ResourceName.Id"/> is valid
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.ResourceName.HasName">
            <summary>
            <c>true</c> if <see cref="P:dnlib.W32Resources.ResourceName.Name"/> is valid
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.ResourceName.Id">
            <summary>
            The ID. It's only valid if <see cref="P:dnlib.W32Resources.ResourceName.HasId"/> is <c>true</c>
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.ResourceName.Name">
            <summary>
            The name. It's only valid if <see cref="P:dnlib.W32Resources.ResourceName.HasName"/> is <c>true</c>
            </summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="id">ID</param>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.op_Implicit(System.Int32)~dnlib.W32Resources.ResourceName">
            <summary>Converts input to a <see cref="T:dnlib.W32Resources.ResourceName"/></summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.op_Implicit(System.String)~dnlib.W32Resources.ResourceName">
            <summary>Converts input to a <see cref="T:dnlib.W32Resources.ResourceName"/></summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.op_LessThan(dnlib.W32Resources.ResourceName,dnlib.W32Resources.ResourceName)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.op_LessThanOrEqual(dnlib.W32Resources.ResourceName,dnlib.W32Resources.ResourceName)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.op_GreaterThan(dnlib.W32Resources.ResourceName,dnlib.W32Resources.ResourceName)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.op_GreaterThanOrEqual(dnlib.W32Resources.ResourceName,dnlib.W32Resources.ResourceName)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.op_Equality(dnlib.W32Resources.ResourceName,dnlib.W32Resources.ResourceName)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.op_Inequality(dnlib.W32Resources.ResourceName,dnlib.W32Resources.ResourceName)">
            <summary>Overloaded operator</summary>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.CompareTo(dnlib.W32Resources.ResourceName)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.Equals(dnlib.W32Resources.ResourceName)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.W32Resources.ResourceName.ToString">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.W32Resources.Win32Resources">
            <summary>
            Win32 resources base class
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.Win32Resources.Root">
            <summary>
            Gets/sets the root directory
            </summary>
        </member>
        <member name="M:dnlib.W32Resources.Win32Resources.Find(dnlib.W32Resources.ResourceName)">
            <summary>
            Finds a <see cref="T:dnlib.W32Resources.ResourceDirectory"/>
            </summary>
            <param name="type">Type</param>
            <returns>The <see cref="T:dnlib.W32Resources.ResourceDirectory"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.W32Resources.Win32Resources.Find(dnlib.W32Resources.ResourceName,dnlib.W32Resources.ResourceName)">
            <summary>
            Finds a <see cref="T:dnlib.W32Resources.ResourceDirectory"/>
            </summary>
            <param name="type">Type</param>
            <param name="name">Name</param>
            <returns>The <see cref="T:dnlib.W32Resources.ResourceDirectory"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.W32Resources.Win32Resources.Find(dnlib.W32Resources.ResourceName,dnlib.W32Resources.ResourceName,dnlib.W32Resources.ResourceName)">
            <summary>
            Finds a <see cref="T:dnlib.W32Resources.ResourceData"/>
            </summary>
            <param name="type">Type</param>
            <param name="name">Name</param>
            <param name="langId">Language ID</param>
            <returns>The <see cref="T:dnlib.W32Resources.ResourceData"/> or <c>null</c> if none found</returns>
        </member>
        <member name="M:dnlib.W32Resources.Win32Resources.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.W32Resources.Win32Resources.Dispose(System.Boolean)">
            <summary>
            Dispose method
            </summary>
            <param name="disposing"><c>true</c> if called by <see cref="M:dnlib.W32Resources.Win32Resources.Dispose"/></param>
        </member>
        <member name="T:dnlib.W32Resources.Win32ResourcesUser">
            <summary>
            Win32 resources class created by the user
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.Win32ResourcesUser.Root">
            <inheritdoc/>
        </member>
        <member name="T:dnlib.W32Resources.Win32ResourcesPE">
            <summary>
            Win32 resources class created from a PE file
            </summary>
        </member>
        <member name="F:dnlib.W32Resources.Win32ResourcesPE.rvaConverter">
            <summary>
            Converts data RVAs to file offsets in <see cref="F:dnlib.W32Resources.Win32ResourcesPE.dataReader_factory"/>
            </summary>
        </member>
        <member name="F:dnlib.W32Resources.Win32ResourcesPE.dataReader_factory">
            <summary>
            This reader only reads the raw data. The data RVA is found in the data header and
            it's first converted to a file offset using <see cref="F:dnlib.W32Resources.Win32ResourcesPE.rvaConverter"/>. This file
            offset is where we'll read from using this reader.
            </summary>
        </member>
        <member name="F:dnlib.W32Resources.Win32ResourcesPE.rsrcReader_factory">
            <summary>
            This reader only reads the directory entries and data headers. The data is read
            by <see cref="F:dnlib.W32Resources.Win32ResourcesPE.dataReader_factory"/>
            </summary>
        </member>
        <member name="P:dnlib.W32Resources.Win32ResourcesPE.Root">
            <inheritdoc/>
        </member>
        <member name="M:dnlib.W32Resources.Win32ResourcesPE.GetResourceReader">
            <summary>
            Gets the resource reader
            </summary>
        </member>
        <member name="M:dnlib.W32Resources.Win32ResourcesPE.#ctor(dnlib.PE.IRvaFileOffsetConverter,dnlib.IO.DataReaderFactory,System.UInt32,System.UInt32,System.Boolean,dnlib.IO.DataReaderFactory,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="rvaConverter"><see cref="T:dnlib.PE.RVA"/>/<see cref="T:dnlib.IO.FileOffset"/> converter</param>
            <param name="rsrcReader_factory">Reader for the whole Win32 resources section (usually
            the .rsrc section). It's used to read <see cref="T:dnlib.W32Resources.ResourceDirectory"/>'s and
            <see cref="T:dnlib.W32Resources.ResourceData"/>'s but not the actual data blob.</param>
            <param name="rsrcReader_offset">Offset of resource section</param>
            <param name="rsrcReader_length">Length of resource section</param>
            <param name="owns_rsrcReader_factory">true if this instance can dispose of <paramref name="rsrcReader_factory"/></param>
            <param name="dataReader_factory">Data reader (it's used after converting an <see cref="T:dnlib.PE.RVA"/>
            to a <see cref="T:dnlib.IO.FileOffset"/>)</param>
            <param name="dataReader_offset">Offset of resource section</param>
            <param name="dataReader_length">Length of resource section</param>
            <param name="owns_dataReader_factory">true if this instance can dispose of <paramref name="dataReader_factory"/></param>
        </member>
        <member name="M:dnlib.W32Resources.Win32ResourcesPE.#ctor(dnlib.PE.IPEImage)">
            <summary>
            Constructor
            </summary>
            <param name="peImage">The PE image</param>
        </member>
        <member name="M:dnlib.W32Resources.Win32ResourcesPE.#ctor(dnlib.PE.IPEImage,dnlib.IO.DataReaderFactory,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="peImage">The PE image</param>
            <param name="rsrcReader_factory">Reader for the whole Win32 resources section (usually
            the .rsrc section) or <c>null</c> if we should create one from the resource data
            directory in the optional header</param>
            <param name="rsrcReader_offset">Offset of resource section</param>
            <param name="rsrcReader_length">Length of resource section</param>
            <param name="owns_rsrcReader_factory">true if this instance can dispose of <paramref name="rsrcReader_factory"/></param>
        </member>
        <member name="M:dnlib.W32Resources.Win32ResourcesPE.CreateReader(dnlib.PE.RVA,System.UInt32)">
            <summary>
            Creates a new data reader
            </summary>
            <param name="rva">RVA of data</param>
            <param name="size">Size of data</param>
            <returns></returns>
        </member>
        <member name="M:dnlib.W32Resources.Win32ResourcesPE.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
    </members>
</doc>
